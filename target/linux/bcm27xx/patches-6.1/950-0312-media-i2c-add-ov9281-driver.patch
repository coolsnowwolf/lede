From d26583e9c31d10919c8d4b965b938724fde1ba3c Mon Sep 17 00:00:00 2001
From: Zefa Chen <zefa.chen@rock-chips.com>
Date: Fri, 17 May 2019 18:23:03 +0800
Subject: [PATCH] media: i2c: add ov9281 driver.

Change-Id: I7b77250bbc56d2f861450cf77271ad15f9b88ab1
Signed-off-by: Zefa Chen <zefa.chen@rock-chips.com>

media: i2c: ov9281: fix mclk issue when probe multiple camera.

Takes the ov9281 part only from the Rockchip's patch.

Change-Id: I30e833baf2c1bb07d6d87ddb3b00759ab45a90e4
Signed-off-by: Zefa Chen <zefa.chen@rock-chips.com>

media: i2c: ov9281: add enum_frame_interval function for iq tool 2.2 and hal3

Adds the ov9281 parts of the Rockchip patch adding enum_frame_interval to
a large number of drivers.

Change-Id: I03344cd6cf278dd7c18fce8e97479089ef185a5c
Signed-off-by: Zefa Chen <zefa.chen@rock-chips.com>

media: i2c: ov9281: Fixup for recent kernel releases, and remove custom code

The Rockchip driver was based on a 4.4 kernel, and had several custom
Rockchip parts.

Update to 5.4 kernel APIs, with the relevant controls required by
libcamera, and remove custom Rockchip parts.

Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.com>

media: i2c: ov9281: Read chip ID via 2 reads

Vision Components have made an OV9281 module which blocks reading
back the majority of registers to comply with NDAs, and in doing
so doesn't allow auto-increment register reading as used when
reading the chip ID.

Use two reads and manually combine the results.

Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.com>

media: i2c: ov9281: Add support for 8 bit readout

The sensor supports 8 bit mode as well as 10bit, so add the
relevant code to allow selection of this.

Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.com>

media: ov9281: Add 1280x720 and 640x480 modes

Breaks out common register set and adds the different registers
for 1280x720 (cropped) and 640x480 (skipped) modes

Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.com>

Fixed picture line bug in all ov9281 modes

Signed-off-by: Mathias Anhalt <mathiasanhalt@web.de>

Added hflip and vflip controls to ov9281

Signed-off-by: Mathias Anhalt <mathiasanhalt@web.de>

media: i2c: ov9281: Remove override of subdev name

From the original Rockchip driver, the subdev was renamed
from the default to being "mov9281 <dev_name>" whereas the
default would have been "ov9281 <dev_name>".

Remove the override to drop back to the default rather than
a vendor custom string.

Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.com>

media: v4l2-subdev: add subdev-wide state struct

Signed-off-by: Dom Cobley <popcornmix@gmail.com>

media: i2c: ov9281: Add fwnode properties controls

Add call to v4l2_ctrl_new_fwnode_properties to read and
create the fwnode based controls.

Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.com>

media: i2c: ov9281: Sensor should report RAW color space

Tested on Raspberry Pi running libcamera.

Signed-off-by: David Plowman <david.plowman@raspberrypi.com>
---
 drivers/media/i2c/Kconfig                     |   11 +
 drivers/media/i2c/Makefile                    |    1 +
 drivers/media/i2c/imx290.c                    |    9 +-
 drivers/media/i2c/imx477.c                    |   30 +-
 drivers/media/i2c/irs1125.c                   |   12 +-
 drivers/media/i2c/ov9281.c                    | 1290 +++++++++++++++++
 .../media/platform/bcm2835/bcm2835-unicam.c   |   20 +-
 .../bcm2835-isp/bcm2835-v4l2-isp.c            |    4 +-
 8 files changed, 1341 insertions(+), 36 deletions(-)
 create mode 100644 drivers/media/i2c/ov9281.c

--- a/drivers/media/i2c/Kconfig
+++ b/drivers/media/i2c/Kconfig
@@ -1343,6 +1343,17 @@ config VIDEO_TW2804
 	  To compile this driver as a module, choose M here: the
 	  module will be called tw2804.
 
+config VIDEO_OV9281
+	tristate "OmniVision OV9281 sensor support"
+	depends on I2C && VIDEO_DEV
+	depends on MEDIA_CAMERA_SUPPORT
+	help
+	  This is a Video4Linux2 sensor-level driver for the OmniVision
+	  OV9281 camera.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called ov9281.
+
 config VIDEO_TW9903
 	tristate "Techwell TW9903 video decoder"
 	depends on VIDEO_DEV && I2C
--- a/drivers/media/i2c/Makefile
+++ b/drivers/media/i2c/Makefile
@@ -98,6 +98,7 @@ obj-$(CONFIG_VIDEO_OV772X) += ov772x.o
 obj-$(CONFIG_VIDEO_OV7740) += ov7740.o
 obj-$(CONFIG_VIDEO_OV8856) += ov8856.o
 obj-$(CONFIG_VIDEO_OV8865) += ov8865.o
+obj-$(CONFIG_VIDEO_OV9281) += ov9281.o
 obj-$(CONFIG_VIDEO_OV9282) += ov9282.o
 obj-$(CONFIG_VIDEO_OV9640) += ov9640.o
 obj-$(CONFIG_VIDEO_OV9650) += ov9650.o
--- a/drivers/media/i2c/imx290.c
+++ b/drivers/media/i2c/imx290.c
@@ -982,12 +982,13 @@ static int imx290_write_current_format(s
 }
 
 static const struct v4l2_rect *
-__imx290_get_pad_crop(struct imx290 *imx290, struct v4l2_subdev_pad_config *cfg,
+__imx290_get_pad_crop(struct imx290 *imx290,
+		      struct v4l2_subdev_state *sd_state,
 		      unsigned int pad, enum v4l2_subdev_format_whence which)
 {
 	switch (which) {
 	case V4L2_SUBDEV_FORMAT_TRY:
-		return v4l2_subdev_get_try_crop(&imx290->sd, cfg, pad);
+		return v4l2_subdev_get_try_crop(&imx290->sd, sd_state, pad);
 	case V4L2_SUBDEV_FORMAT_ACTIVE:
 		return &imx290->current_mode->crop;
 	}
@@ -996,7 +997,7 @@ __imx290_get_pad_crop(struct imx290 *imx
 }
 
 static int imx290_get_selection(struct v4l2_subdev *sd,
-				struct v4l2_subdev_pad_config *cfg,
+				struct v4l2_subdev_state *sd_state,
 				struct v4l2_subdev_selection *sel)
 {
 	switch (sel->target) {
@@ -1004,7 +1005,7 @@ static int imx290_get_selection(struct v
 		struct imx290 *imx290 = to_imx290(sd);
 
 		mutex_lock(&imx290->lock);
-		sel->r = *__imx290_get_pad_crop(imx290, cfg, sel->pad,
+		sel->r = *__imx290_get_pad_crop(imx290, sd_state, sel->pad,
 						sel->which);
 		mutex_unlock(&imx290->lock);
 
--- a/drivers/media/i2c/imx477.c
+++ b/drivers/media/i2c/imx477.c
@@ -1272,9 +1272,9 @@ static int imx477_open(struct v4l2_subde
 {
 	struct imx477 *imx477 = to_imx477(sd);
 	struct v4l2_mbus_framefmt *try_fmt_img =
-		v4l2_subdev_get_try_format(sd, fh->pad, IMAGE_PAD);
+		v4l2_subdev_get_try_format(sd, fh->state, IMAGE_PAD);
 	struct v4l2_mbus_framefmt *try_fmt_meta =
-		v4l2_subdev_get_try_format(sd, fh->pad, METADATA_PAD);
+		v4l2_subdev_get_try_format(sd, fh->state, METADATA_PAD);
 	struct v4l2_rect *try_crop;
 
 	mutex_lock(&imx477->mutex);
@@ -1293,7 +1293,7 @@ static int imx477_open(struct v4l2_subde
 	try_fmt_meta->field = V4L2_FIELD_NONE;
 
 	/* Initialize try_crop */
-	try_crop = v4l2_subdev_get_try_crop(sd, fh->pad, IMAGE_PAD);
+	try_crop = v4l2_subdev_get_try_crop(sd, fh->state, IMAGE_PAD);
 	try_crop->left = IMX477_PIXEL_ARRAY_LEFT;
 	try_crop->top = IMX477_PIXEL_ARRAY_TOP;
 	try_crop->width = IMX477_PIXEL_ARRAY_WIDTH;
@@ -1425,7 +1425,7 @@ static const struct v4l2_ctrl_ops imx477
 };
 
 static int imx477_enum_mbus_code(struct v4l2_subdev *sd,
-				 struct v4l2_subdev_pad_config *cfg,
+				 struct v4l2_subdev_state *sd_state,
 				 struct v4l2_subdev_mbus_code_enum *code)
 {
 	struct imx477 *imx477 = to_imx477(sd);
@@ -1450,7 +1450,7 @@ static int imx477_enum_mbus_code(struct
 }
 
 static int imx477_enum_frame_size(struct v4l2_subdev *sd,
-				  struct v4l2_subdev_pad_config *cfg,
+				  struct v4l2_subdev_state *sd_state,
 				  struct v4l2_subdev_frame_size_enum *fse)
 {
 	struct imx477 *imx477 = to_imx477(sd);
@@ -1516,7 +1516,7 @@ static void imx477_update_metadata_pad_f
 }
 
 static int imx477_get_pad_format(struct v4l2_subdev *sd,
-				 struct v4l2_subdev_pad_config *cfg,
+				 struct v4l2_subdev_state *sd_state,
 				 struct v4l2_subdev_format *fmt)
 {
 	struct imx477 *imx477 = to_imx477(sd);
@@ -1528,7 +1528,8 @@ static int imx477_get_pad_format(struct
 
 	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {
 		struct v4l2_mbus_framefmt *try_fmt =
-			v4l2_subdev_get_try_format(&imx477->sd, cfg, fmt->pad);
+			v4l2_subdev_get_try_format(&imx477->sd, sd_state,
+						   fmt->pad);
 		/* update the code which could change due to vflip or hflip: */
 		try_fmt->code = fmt->pad == IMAGE_PAD ?
 				imx477_get_format_code(imx477, try_fmt->code) :
@@ -1593,7 +1594,7 @@ static void imx477_set_framing_limits(st
 }
 
 static int imx477_set_pad_format(struct v4l2_subdev *sd,
-				 struct v4l2_subdev_pad_config *cfg,
+				 struct v4l2_subdev_state *sd_state,
 				 struct v4l2_subdev_format *fmt)
 {
 	struct v4l2_mbus_framefmt *framefmt;
@@ -1622,7 +1623,7 @@ static int imx477_set_pad_format(struct
 					      fmt->format.height);
 		imx477_update_image_pad_format(imx477, mode, fmt);
 		if (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {
-			framefmt = v4l2_subdev_get_try_format(sd, cfg,
+			framefmt = v4l2_subdev_get_try_format(sd, sd_state,
 							      fmt->pad);
 			*framefmt = fmt->format;
 		} else if (imx477->mode != mode) {
@@ -1632,7 +1633,7 @@ static int imx477_set_pad_format(struct
 		}
 	} else {
 		if (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {
-			framefmt = v4l2_subdev_get_try_format(sd, cfg,
+			framefmt = v4l2_subdev_get_try_format(sd, sd_state,
 							      fmt->pad);
 			*framefmt = fmt->format;
 		} else {
@@ -1647,12 +1648,13 @@ static int imx477_set_pad_format(struct
 }
 
 static const struct v4l2_rect *
-__imx477_get_pad_crop(struct imx477 *imx477, struct v4l2_subdev_pad_config *cfg,
+__imx477_get_pad_crop(struct imx477 *imx477,
+		      struct v4l2_subdev_state *sd_state,
 		      unsigned int pad, enum v4l2_subdev_format_whence which)
 {
 	switch (which) {
 	case V4L2_SUBDEV_FORMAT_TRY:
-		return v4l2_subdev_get_try_crop(&imx477->sd, cfg, pad);
+		return v4l2_subdev_get_try_crop(&imx477->sd, sd_state, pad);
 	case V4L2_SUBDEV_FORMAT_ACTIVE:
 		return &imx477->mode->crop;
 	}
@@ -1661,7 +1663,7 @@ __imx477_get_pad_crop(struct imx477 *imx
 }
 
 static int imx477_get_selection(struct v4l2_subdev *sd,
-				struct v4l2_subdev_pad_config *cfg,
+				struct v4l2_subdev_state *sd_state,
 				struct v4l2_subdev_selection *sel)
 {
 	switch (sel->target) {
@@ -1669,7 +1671,7 @@ static int imx477_get_selection(struct v
 		struct imx477 *imx477 = to_imx477(sd);
 
 		mutex_lock(&imx477->mutex);
-		sel->r = *__imx477_get_pad_crop(imx477, cfg, sel->pad,
+		sel->r = *__imx477_get_pad_crop(imx477, sd_state, sel->pad,
 						sel->which);
 		mutex_unlock(&imx477->mutex);
 
--- a/drivers/media/i2c/irs1125.c
+++ b/drivers/media/i2c/irs1125.c
@@ -562,8 +562,8 @@ static const struct v4l2_subdev_video_op
 };
 
 static int irs1125_enum_mbus_code(struct v4l2_subdev *sd,
-				  struct v4l2_subdev_pad_config *cfg,
-	struct v4l2_subdev_mbus_code_enum *code)
+				  struct v4l2_subdev_state *sd_state,
+				  struct v4l2_subdev_mbus_code_enum *code)
 {
 	if (code->index > 0)
 		return -EINVAL;
@@ -574,7 +574,7 @@ static int irs1125_enum_mbus_code(struct
 }
 
 static int irs1125_set_get_fmt(struct v4l2_subdev *sd,
-			       struct v4l2_subdev_pad_config *cfg,
+			       struct v4l2_subdev_state *sd_state,
 			       struct v4l2_subdev_format *format)
 {
 	struct v4l2_mbus_framefmt *fmt = &format->format;
@@ -930,7 +930,7 @@ static int irs1125_detect(struct v4l2_su
 static int irs1125_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
 {
 	struct v4l2_mbus_framefmt *format =
-	v4l2_subdev_get_try_format(sd, fh->pad, 0);
+	v4l2_subdev_get_try_format(sd, fh->state, 0);
 
 	format->code = MEDIA_BUS_FMT_Y12_1X12;
 	format->width = IRS1125_WINDOW_WIDTH_DEF;
@@ -1161,7 +1161,7 @@ mutex_remove:
 	return ret;
 }
 
-static int irs1125_remove(struct i2c_client *client)
+static void irs1125_remove(struct i2c_client *client)
 {
 	struct v4l2_subdev *sd = i2c_get_clientdata(client);
 	struct irs1125 *irs1125 = to_state(sd);
@@ -1171,8 +1171,6 @@ static int irs1125_remove(struct i2c_cli
 	v4l2_device_unregister_subdev(sd);
 	mutex_destroy(&irs1125->lock);
 	v4l2_ctrl_handler_free(&irs1125->ctrl_handler);
-
-	return 0;
 }
 
 #if IS_ENABLED(CONFIG_OF)
--- /dev/null
+++ b/drivers/media/i2c/ov9281.c
@@ -0,0 +1,1290 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Omnivision OV9281 1280x800 global shutter image sensor driver
+ *
+ * This driver has been taken from
+ * https://github.com/rockchip-linux/kernel/blob/develop-4.4/drivers/media/i2c/ov9281.c
+ * cleaned up, made to compile against mainline kernels instead of the Rockchip
+ * vendor kernel, and the relevant controls added to work with libcamera.
+ *
+ * Copyright (C) 2017 Fuzhou Rockchip Electronics Co., Ltd.
+ * V0.0X01.0X02 fix mclk issue when probe multiple camera.
+ * V0.0X01.0X03 add enum_frame_interval function.
+ */
+
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/regulator/consumer.h>
+#include <linux/sysfs.h>
+#include <linux/slab.h>
+#include <media/media-entity.h>
+#include <media/v4l2-async.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-subdev.h>
+
+#define OV9281_LINK_FREQ_400MHZ		400000000
+#define OV9281_LANES			2
+
+/* pixel rate = link frequency * 2 * lanes / BITS_PER_SAMPLE */
+#define OV9281_PIXEL_RATE_10BIT		(OV9281_LINK_FREQ_400MHZ * 2 * \
+					 OV9281_LANES / 10)
+#define OV9281_PIXEL_RATE_8BIT		(OV9281_LINK_FREQ_400MHZ * 2 * \
+					 OV9281_LANES / 8)
+#define OV9281_XVCLK_FREQ		24000000
+
+#define CHIP_ID				0x9281
+#define OV9281_REG_CHIP_ID		0x300a
+
+#define OV9281_REG_TIMING_FORMAT_1		0x3820
+#define OV9281_REG_TIMING_FORMAT_2		0x3821
+#define OV9281_FLIP_BIT				BIT(2)
+
+#define OV9281_REG_CTRL_MODE		0x0100
+#define OV9281_MODE_SW_STANDBY		0x0
+#define OV9281_MODE_STREAMING		BIT(0)
+
+#define OV9281_REG_EXPOSURE		0x3500
+#define	OV9281_EXPOSURE_MIN		4
+#define	OV9281_EXPOSURE_STEP		1
+#define OV9281_VTS_MAX			0x7fff
+
+#define OV9281_REG_GAIN_H		0x3508
+#define OV9281_REG_GAIN_L		0x3509
+#define OV9281_GAIN_H_MASK		0x07
+#define OV9281_GAIN_H_SHIFT		8
+#define OV9281_GAIN_L_MASK		0xff
+#define OV9281_GAIN_MIN			0x10
+#define OV9281_GAIN_MAX			0xf8
+#define OV9281_GAIN_STEP		1
+#define OV9281_GAIN_DEFAULT		0x10
+
+#define OV9281_REG_TEST_PATTERN		0x5e00
+#define OV9281_TEST_PATTERN_ENABLE	0x80
+#define OV9281_TEST_PATTERN_DISABLE	0x0
+
+#define OV9281_REG_VTS			0x380e
+
+/*
+ * OV9281 native and active pixel array size.
+ * Datasheet not available to confirm these values, so assume there are no
+ * border pixels.
+ */
+#define OV9281_NATIVE_WIDTH		1280U
+#define OV9281_NATIVE_HEIGHT		800U
+#define OV9281_PIXEL_ARRAY_LEFT		0U
+#define OV9281_PIXEL_ARRAY_TOP		0U
+#define OV9281_PIXEL_ARRAY_WIDTH	1280U
+#define OV9281_PIXEL_ARRAY_HEIGHT	800U
+
+#define REG_NULL			0xFFFF
+
+#define OV9281_REG_VALUE_08BIT		1
+#define OV9281_REG_VALUE_16BIT		2
+#define OV9281_REG_VALUE_24BIT		3
+
+#define OV9281_NAME			"ov9281"
+
+static const char * const ov9281_supply_names[] = {
+	"avdd",		/* Analog power */
+	"dovdd",	/* Digital I/O power */
+	"dvdd",		/* Digital core power */
+};
+
+#define OV9281_NUM_SUPPLIES ARRAY_SIZE(ov9281_supply_names)
+
+struct regval {
+	u16 addr;
+	u8 val;
+};
+
+struct ov9281_mode {
+	u32 width;
+	u32 height;
+	u32 hts_def;
+	u32 vts_def;
+	u32 exp_def;
+	struct v4l2_rect crop;
+	const struct regval *reg_list;
+};
+
+struct ov9281 {
+	struct i2c_client	*client;
+	struct clk		*xvclk;
+	struct gpio_desc	*reset_gpio;
+	struct gpio_desc	*pwdn_gpio;
+	struct regulator_bulk_data supplies[OV9281_NUM_SUPPLIES];
+
+	struct v4l2_subdev	subdev;
+	struct media_pad	pad;
+	struct v4l2_ctrl_handler ctrl_handler;
+	struct v4l2_ctrl	*exposure;
+	struct v4l2_ctrl	*anal_gain;
+	struct v4l2_ctrl	*digi_gain;
+	struct v4l2_ctrl	*hblank;
+	struct v4l2_ctrl	*vblank;
+	struct v4l2_ctrl	*hflip;
+	struct v4l2_ctrl	*vflip;
+	struct v4l2_ctrl	*pixel_rate;
+	struct v4l2_ctrl	*test_pattern;
+	struct mutex		mutex;
+	bool			streaming;
+	bool			power_on;
+	const struct ov9281_mode *cur_mode;
+	u32			code;
+};
+
+#define to_ov9281(sd) container_of(sd, struct ov9281, subdev)
+
+/*
+ * Xclk 24Mhz
+ * max_framerate 120fps for 10 bit, 144fps for 8 bit.
+ * mipi_datarate per lane 800Mbps
+ */
+static const struct regval ov9281_common_regs[] = {
+	{0x0103, 0x01},
+	{0x0302, 0x32},
+	{0x030e, 0x02},
+	{0x3001, 0x00},
+	{0x3004, 0x00},
+	{0x3005, 0x00},
+	{0x3006, 0x04},
+	{0x3011, 0x0a},
+	{0x3013, 0x18},
+	{0x3022, 0x01},
+	{0x3023, 0x00},
+	{0x302c, 0x00},
+	{0x302f, 0x00},
+	{0x3030, 0x04},
+	{0x3039, 0x32},
+	{0x303a, 0x00},
+	{0x303f, 0x01},
+	{0x3500, 0x00},
+	{0x3501, 0x2a},
+	{0x3502, 0x90},
+	{0x3503, 0x08},
+	{0x3505, 0x8c},
+	{0x3507, 0x03},
+	{0x3508, 0x00},
+	{0x3509, 0x10},
+	{0x3610, 0x80},
+	{0x3611, 0xa0},
+	{0x3620, 0x6f},
+	{0x3632, 0x56},
+	{0x3633, 0x78},
+	{0x3666, 0x00},
+	{0x366f, 0x5a},
+	{0x3680, 0x84},
+	{0x3712, 0x80},
+	{0x372d, 0x22},
+	{0x3731, 0x80},
+	{0x3732, 0x30},
+	{0x377d, 0x22},
+	{0x3788, 0x02},
+	{0x3789, 0xa4},
+	{0x378a, 0x00},
+	{0x378b, 0x4a},
+	{0x3799, 0x20},
+	{0x3881, 0x42},
+	{0x38b1, 0x00},
+	{0x3920, 0xff},
+	{0x4010, 0x40},
+	{0x4043, 0x40},
+	{0x4307, 0x30},
+	{0x4317, 0x00},
+	{0x4501, 0x00},
+	{0x450a, 0x08},
+	{0x4601, 0x04},
+	{0x470f, 0x00},
+	{0x4f07, 0x00},
+	{0x4800, 0x00},
+	{0x5000, 0x9f},
+	{0x5001, 0x00},
+	{0x5e00, 0x00},
+	{0x5d00, 0x07},
+	{0x5d01, 0x00},
+	{REG_NULL, 0x00},
+};
+
+static const struct regval ov9281_1280x800_regs[] = {
+	{0x3778, 0x00},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0x00},
+	{0x3804, 0x05},
+	{0x3805, 0x0f},
+	{0x3806, 0x03},
+	{0x3807, 0x2f},
+	{0x3808, 0x05},
+	{0x3809, 0x00},
+	{0x380a, 0x03},
+	{0x380b, 0x20},
+	{0x380c, 0x02},
+	{0x380d, 0xd8},
+	{0x380e, 0x03},
+	{0x380f, 0x8e},
+	{0x3810, 0x00},
+	{0x3811, 0x08},
+	{0x3812, 0x00},
+	{0x3813, 0x08},
+	{0x3814, 0x11},
+	{0x3815, 0x11},
+	{0x3820, 0x40},
+	{0x3821, 0x00},
+	{0x4003, 0x40},
+	{0x4008, 0x04},
+	{0x4009, 0x0b},
+	{0x400c, 0x00},
+	{0x400d, 0x07},
+	{0x4507, 0x00},
+	{0x4509, 0x00},
+	{REG_NULL, 0x00},
+};
+
+static const struct regval ov9281_1280x720_regs[] = {
+	{0x3778, 0x00},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0x28},
+	{0x3804, 0x05},
+	{0x3805, 0x0f},
+	{0x3806, 0x03},
+	{0x3807, 0x07},
+	{0x3808, 0x05},
+	{0x3809, 0x00},
+	{0x380a, 0x02},
+	{0x380b, 0xd0},
+	{0x380c, 0x02},
+	{0x380d, 0xd8},
+	{0x380e, 0x03},
+	{0x380f, 0x8e},
+	{0x3810, 0x00},
+	{0x3811, 0x08},
+	{0x3812, 0x00},
+	{0x3813, 0x08},
+	{0x3814, 0x11},
+	{0x3815, 0x11},
+	{0x3820, 0x40},
+	{0x3821, 0x00},
+	{0x4003, 0x40},
+	{0x4008, 0x04},
+	{0x4009, 0x0b},
+	{0x400c, 0x00},
+	{0x400d, 0x07},
+	{0x4507, 0x00},
+	{0x4509, 0x00},
+	{REG_NULL, 0x00},
+};
+
+static const struct regval ov9281_640x400_regs[] = {
+	{0x3778, 0x10},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0x00},
+	{0x3804, 0x05},
+	{0x3805, 0x0f},
+	{0x3806, 0x03},
+	{0x3807, 0x2f},
+	{0x3808, 0x02},
+	{0x3809, 0x80},
+	{0x380a, 0x01},
+	{0x380b, 0x90},
+	{0x380c, 0x02},
+	{0x380d, 0xd8},
+	{0x380e, 0x02},
+	{0x380f, 0x08},
+	{0x3810, 0x00},
+	{0x3811, 0x04},
+	{0x3812, 0x00},
+	{0x3813, 0x04},
+	{0x3814, 0x31},
+	{0x3815, 0x22},
+	{0x3820, 0x60},
+	{0x3821, 0x01},
+	{0x4008, 0x02},
+	{0x4009, 0x05},
+	{0x400c, 0x00},
+	{0x400d, 0x03},
+	{0x4507, 0x03},
+	{0x4509, 0x80},
+	{REG_NULL, 0x00},
+};
+
+static const struct regval op_10bit[] = {
+	{0x030d, 0x50},
+	{0x3662, 0x05},
+	{REG_NULL, 0x00},
+};
+
+static const struct regval op_8bit[] = {
+	{0x030d, 0x60},
+	{0x3662, 0x07},
+	{REG_NULL, 0x00},
+};
+
+static const struct ov9281_mode supported_modes[] = {
+	{
+		.width = 1280,
+		.height = 800,
+		.exp_def = 0x0320,
+		.hts_def = 0x05b0,	/* 0x2d8*2 */
+		.vts_def = 0x038e,
+		.crop = {
+			.left = 0,
+			.top = 0,
+			.width = 1280,
+			.height = 800
+		},
+		.reg_list = ov9281_1280x800_regs,
+	},
+	{
+		.width = 1280,
+		.height = 720,
+		.exp_def = 0x0320,
+		.hts_def = 0x05b0,
+		.vts_def = 761,
+		.crop = {
+			.left = 0,
+			.top = 40,
+			.width = 1280,
+			.height = 720
+		},
+		.reg_list = ov9281_1280x720_regs,
+	},
+	{
+		.width = 640,
+		.height = 400,
+		.exp_def = 0x0320,
+		.hts_def = 0x05b0,
+		.vts_def = 421,
+		.crop = {
+			.left = 0,
+			.top = 0,
+			.width = 1280,
+			.height = 800
+		},
+		.reg_list = ov9281_640x400_regs,
+	},
+};
+
+static const s64 link_freq_menu_items[] = {
+	OV9281_LINK_FREQ_400MHZ
+};
+
+static const char * const ov9281_test_pattern_menu[] = {
+	"Disabled",
+	"Vertical Color Bar Type 1",
+	"Vertical Color Bar Type 2",
+	"Vertical Color Bar Type 3",
+	"Vertical Color Bar Type 4"
+};
+
+/* Write registers up to 4 at a time */
+static int ov9281_write_reg(struct i2c_client *client, u16 reg,
+			    u32 len, u32 val)
+{
+	u32 buf_i, val_i;
+	u8 buf[6];
+	u8 *val_p;
+	__be32 val_be;
+
+	if (len > 4)
+		return -EINVAL;
+
+	buf[0] = reg >> 8;
+	buf[1] = reg & 0xff;
+
+	val_be = cpu_to_be32(val);
+	val_p = (u8 *)&val_be;
+	buf_i = 2;
+	val_i = 4 - len;
+
+	while (val_i < 4)
+		buf[buf_i++] = val_p[val_i++];
+
+	if (i2c_master_send(client, buf, len + 2) != len + 2)
+		return -EIO;
+
+	return 0;
+}
+
+static int ov9281_write_array(struct i2c_client *client,
+			      const struct regval *regs)
+{
+	u32 i;
+	int ret = 0;
+
+	for (i = 0; ret == 0 && regs[i].addr != REG_NULL; i++)
+		ret = ov9281_write_reg(client, regs[i].addr,
+				       OV9281_REG_VALUE_08BIT, regs[i].val);
+
+	return ret;
+}
+
+/* Read registers up to 4 at a time */
+static int ov9281_read_reg(struct i2c_client *client, u16 reg, unsigned int len,
+			   u32 *val)
+{
+	struct i2c_msg msgs[2];
+	u8 *data_be_p;
+	__be32 data_be = 0;
+	__be16 reg_addr_be = cpu_to_be16(reg);
+	int ret;
+
+	if (len > 4 || !len)
+		return -EINVAL;
+
+	data_be_p = (u8 *)&data_be;
+	/* Write register address */
+	msgs[0].addr = client->addr;
+	msgs[0].flags = 0;
+	msgs[0].len = 2;
+	msgs[0].buf = (u8 *)&reg_addr_be;
+
+	/* Read data from register */
+	msgs[1].addr = client->addr;
+	msgs[1].flags = I2C_M_RD;
+	msgs[1].len = len;
+	msgs[1].buf = &data_be_p[4 - len];
+
+	ret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));
+	if (ret != ARRAY_SIZE(msgs))
+		return -EIO;
+
+	*val = be32_to_cpu(data_be);
+
+	return 0;
+}
+
+static int ov9281_get_reso_dist(const struct ov9281_mode *mode,
+				struct v4l2_mbus_framefmt *framefmt)
+{
+	return abs(mode->width - framefmt->width) +
+	       abs(mode->height - framefmt->height);
+}
+
+static const struct ov9281_mode *
+ov9281_find_best_fit(struct v4l2_subdev_format *fmt)
+{
+	struct v4l2_mbus_framefmt *framefmt = &fmt->format;
+	int dist;
+	int cur_best_fit = 0;
+	int cur_best_fit_dist = -1;
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(supported_modes); i++) {
+		dist = ov9281_get_reso_dist(&supported_modes[i], framefmt);
+		if (cur_best_fit_dist == -1 || dist < cur_best_fit_dist) {
+			cur_best_fit_dist = dist;
+			cur_best_fit = i;
+		}
+	}
+
+	return &supported_modes[cur_best_fit];
+}
+
+static int ov9281_set_fmt(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_state *sd_state,
+			  struct v4l2_subdev_format *fmt)
+{
+	struct ov9281 *ov9281 = to_ov9281(sd);
+	const struct ov9281_mode *mode;
+	s64 h_blank, vblank_def, pixel_rate;
+
+	mutex_lock(&ov9281->mutex);
+
+	mode = ov9281_find_best_fit(fmt);
+	if (fmt->format.code != MEDIA_BUS_FMT_Y8_1X8)
+		fmt->format.code = MEDIA_BUS_FMT_Y10_1X10;
+	fmt->format.width = mode->width;
+	fmt->format.height = mode->height;
+	fmt->format.field = V4L2_FIELD_NONE;
+	fmt->format.colorspace = V4L2_COLORSPACE_RAW;
+	fmt->format.ycbcr_enc =
+			V4L2_MAP_YCBCR_ENC_DEFAULT(fmt->format.colorspace);
+	fmt->format.quantization =
+		V4L2_MAP_QUANTIZATION_DEFAULT(true, fmt->format.colorspace,
+					      fmt->format.ycbcr_enc);
+	fmt->format.xfer_func =
+		V4L2_MAP_XFER_FUNC_DEFAULT(fmt->format.colorspace);
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {
+		*v4l2_subdev_get_try_format(sd, sd_state, fmt->pad) = fmt->format;
+	} else {
+		ov9281->cur_mode = mode;
+		ov9281->code = fmt->format.code;
+		h_blank = mode->hts_def - mode->width;
+		__v4l2_ctrl_modify_range(ov9281->hblank, h_blank,
+					 h_blank, 1, h_blank);
+		__v4l2_ctrl_s_ctrl(ov9281->hblank, h_blank);
+		vblank_def = mode->vts_def - mode->height;
+		__v4l2_ctrl_modify_range(ov9281->vblank, vblank_def,
+					 OV9281_VTS_MAX - mode->height,
+					 1, vblank_def);
+		__v4l2_ctrl_s_ctrl(ov9281->vblank, vblank_def);
+
+		pixel_rate = (fmt->format.code == MEDIA_BUS_FMT_Y10_1X10) ?
+			OV9281_PIXEL_RATE_10BIT : OV9281_PIXEL_RATE_8BIT;
+		__v4l2_ctrl_modify_range(ov9281->pixel_rate, pixel_rate,
+					 pixel_rate, 1, pixel_rate);
+	}
+
+	mutex_unlock(&ov9281->mutex);
+
+	return 0;
+}
+
+static int ov9281_get_fmt(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_state *sd_state,
+			  struct v4l2_subdev_format *fmt)
+{
+	struct ov9281 *ov9281 = to_ov9281(sd);
+	const struct ov9281_mode *mode = ov9281->cur_mode;
+
+	mutex_lock(&ov9281->mutex);
+	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {
+		fmt->format = *v4l2_subdev_get_try_format(sd, sd_state,
+							  fmt->pad);
+	} else {
+		fmt->format.width = mode->width;
+		fmt->format.height = mode->height;
+		fmt->format.code = ov9281->code;
+		fmt->format.field = V4L2_FIELD_NONE;
+		fmt->format.colorspace = V4L2_COLORSPACE_RAW;
+		fmt->format.ycbcr_enc =
+			V4L2_MAP_YCBCR_ENC_DEFAULT(fmt->format.colorspace);
+		fmt->format.quantization =
+			V4L2_MAP_QUANTIZATION_DEFAULT(true,
+						      fmt->format.colorspace,
+						      fmt->format.ycbcr_enc);
+		fmt->format.xfer_func =
+			V4L2_MAP_XFER_FUNC_DEFAULT(fmt->format.colorspace);
+	}
+	mutex_unlock(&ov9281->mutex);
+
+	return 0;
+}
+
+static int ov9281_enum_mbus_code(struct v4l2_subdev *sd,
+				 struct v4l2_subdev_state *sd_state,
+				 struct v4l2_subdev_mbus_code_enum *code)
+{
+	switch (code->index) {
+	default:
+		return -EINVAL;
+	case 0:
+		code->code = MEDIA_BUS_FMT_Y10_1X10;
+		break;
+	case 1:
+		code->code = MEDIA_BUS_FMT_Y8_1X8;
+		break;
+	}
+
+	return 0;
+}
+
+static int ov9281_enum_frame_sizes(struct v4l2_subdev *sd,
+				   struct v4l2_subdev_state *sd_state,
+				   struct v4l2_subdev_frame_size_enum *fse)
+{
+	if (fse->index >= ARRAY_SIZE(supported_modes))
+		return -EINVAL;
+
+	if (fse->code != MEDIA_BUS_FMT_Y10_1X10 &&
+	    fse->code != MEDIA_BUS_FMT_Y8_1X8)
+		return -EINVAL;
+
+	fse->min_width  = supported_modes[fse->index].width;
+	fse->max_width  = supported_modes[fse->index].width;
+	fse->max_height = supported_modes[fse->index].height;
+	fse->min_height = supported_modes[fse->index].height;
+
+	return 0;
+}
+
+static int ov9281_enable_test_pattern(struct ov9281 *ov9281, u32 pattern)
+{
+	u32 val;
+
+	if (pattern)
+		val = (pattern - 1) | OV9281_TEST_PATTERN_ENABLE;
+	else
+		val = OV9281_TEST_PATTERN_DISABLE;
+
+	return ov9281_write_reg(ov9281->client, OV9281_REG_TEST_PATTERN,
+				OV9281_REG_VALUE_08BIT, val);
+}
+
+static int ov9281_set_ctrl_hflip(struct ov9281 *ov9281, int value)
+{
+	u32 current_val;
+	int ret = ov9281_read_reg(ov9281->client, OV9281_REG_TIMING_FORMAT_2,
+					OV9281_REG_VALUE_08BIT, &current_val);
+	if (!ret) {
+		if (value)
+			current_val |= OV9281_FLIP_BIT;
+		else
+			current_val &= ~OV9281_FLIP_BIT;
+		return ov9281_write_reg(ov9281->client,
+						OV9281_REG_TIMING_FORMAT_2,
+						OV9281_REG_VALUE_08BIT,
+						current_val);
+	}
+	return ret;
+}
+
+static int ov9281_set_ctrl_vflip(struct ov9281 *ov9281, int value)
+{
+	u32 current_val;
+	int ret = ov9281_read_reg(ov9281->client, OV9281_REG_TIMING_FORMAT_1,
+					OV9281_REG_VALUE_08BIT, &current_val);
+	if (!ret) {
+		if (value)
+			current_val |= OV9281_FLIP_BIT;
+		else
+			current_val &= ~OV9281_FLIP_BIT;
+		return ov9281_write_reg(ov9281->client,
+						OV9281_REG_TIMING_FORMAT_1,
+						OV9281_REG_VALUE_08BIT,
+						current_val);
+	}
+	return ret;
+}
+
+static const struct v4l2_rect *
+__ov9281_get_pad_crop(struct ov9281 *ov9281,
+		      struct v4l2_subdev_state *sd_state,
+		      unsigned int pad, enum v4l2_subdev_format_whence which)
+{
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		return v4l2_subdev_get_try_crop(&ov9281->subdev, sd_state,
+						pad);
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		return &ov9281->cur_mode->crop;
+	}
+
+	return NULL;
+}
+
+static int ov9281_get_selection(struct v4l2_subdev *sd,
+				struct v4l2_subdev_state *sd_state,
+				struct v4l2_subdev_selection *sel)
+{
+	switch (sel->target) {
+	case V4L2_SEL_TGT_CROP: {
+		struct ov9281 *ov9281 = to_ov9281(sd);
+
+		mutex_lock(&ov9281->mutex);
+		sel->r = *__ov9281_get_pad_crop(ov9281, sd_state, sel->pad,
+						sel->which);
+		mutex_unlock(&ov9281->mutex);
+
+		return 0;
+	}
+
+	case V4L2_SEL_TGT_NATIVE_SIZE:
+		sel->r.top = 0;
+		sel->r.left = 0;
+		sel->r.width = OV9281_NATIVE_WIDTH;
+		sel->r.height = OV9281_NATIVE_HEIGHT;
+
+		return 0;
+
+	case V4L2_SEL_TGT_CROP_DEFAULT:
+	case V4L2_SEL_TGT_CROP_BOUNDS:
+		sel->r.top = OV9281_PIXEL_ARRAY_TOP;
+		sel->r.left = OV9281_PIXEL_ARRAY_LEFT;
+		sel->r.width = OV9281_PIXEL_ARRAY_WIDTH;
+		sel->r.height = OV9281_PIXEL_ARRAY_HEIGHT;
+
+		return 0;
+	}
+
+	return -EINVAL;
+}
+
+static int __ov9281_start_stream(struct ov9281 *ov9281)
+{
+	int ret;
+
+	ret = ov9281_write_array(ov9281->client, ov9281_common_regs);
+	if (ret)
+		return ret;
+
+	ret = ov9281_write_array(ov9281->client, ov9281->cur_mode->reg_list);
+	if (ret)
+		return ret;
+
+	if (ov9281->code == MEDIA_BUS_FMT_Y10_1X10)
+		ret = ov9281_write_array(ov9281->client, op_10bit);
+	else
+		ret = ov9281_write_array(ov9281->client, op_8bit);
+	if (ret)
+		return ret;
+
+	/* In case these controls are set before streaming */
+	mutex_unlock(&ov9281->mutex);
+	ret = v4l2_ctrl_handler_setup(&ov9281->ctrl_handler);
+	mutex_lock(&ov9281->mutex);
+	if (ret)
+		return ret;
+
+	return ov9281_write_reg(ov9281->client, OV9281_REG_CTRL_MODE,
+				OV9281_REG_VALUE_08BIT, OV9281_MODE_STREAMING);
+}
+
+static int __ov9281_stop_stream(struct ov9281 *ov9281)
+{
+	return ov9281_write_reg(ov9281->client, OV9281_REG_CTRL_MODE,
+				OV9281_REG_VALUE_08BIT, OV9281_MODE_SW_STANDBY);
+}
+
+static int ov9281_s_stream(struct v4l2_subdev *sd, int on)
+{
+	struct ov9281 *ov9281 = to_ov9281(sd);
+	struct i2c_client *client = ov9281->client;
+	int ret = 0;
+
+	mutex_lock(&ov9281->mutex);
+	on = !!on;
+	if (on == ov9281->streaming)
+		goto unlock_and_return;
+
+	if (on) {
+		ret = pm_runtime_get_sync(&client->dev);
+		if (ret < 0) {
+			pm_runtime_put_noidle(&client->dev);
+			goto unlock_and_return;
+		}
+
+		ret = __ov9281_start_stream(ov9281);
+		if (ret) {
+			v4l2_err(sd, "start stream failed while write regs\n");
+			pm_runtime_put(&client->dev);
+			goto unlock_and_return;
+		}
+	} else {
+		__ov9281_stop_stream(ov9281);
+		pm_runtime_put(&client->dev);
+	}
+
+	ov9281->streaming = on;
+
+unlock_and_return:
+	mutex_unlock(&ov9281->mutex);
+
+	return ret;
+}
+
+static int ov9281_s_power(struct v4l2_subdev *sd, int on)
+{
+	struct ov9281 *ov9281 = to_ov9281(sd);
+	struct i2c_client *client = ov9281->client;
+	int ret = 0;
+
+	mutex_lock(&ov9281->mutex);
+
+	/* If the power state is not modified - no work to do. */
+	if (ov9281->power_on == !!on)
+		goto unlock_and_return;
+
+	if (on) {
+		ret = pm_runtime_get_sync(&client->dev);
+		if (ret < 0) {
+			pm_runtime_put_noidle(&client->dev);
+			goto unlock_and_return;
+		}
+		ov9281->power_on = true;
+	} else {
+		pm_runtime_put(&client->dev);
+		ov9281->power_on = false;
+	}
+
+unlock_and_return:
+	mutex_unlock(&ov9281->mutex);
+
+	return ret;
+}
+
+/* Calculate the delay in us by clock rate and clock cycles */
+static inline u32 ov9281_cal_delay(u32 cycles)
+{
+	return DIV_ROUND_UP(cycles, OV9281_XVCLK_FREQ / 1000 / 1000);
+}
+
+static int __ov9281_power_on(struct ov9281 *ov9281)
+{
+	int ret;
+	u32 delay_us;
+	struct device *dev = &ov9281->client->dev;
+
+	ret = clk_set_rate(ov9281->xvclk, OV9281_XVCLK_FREQ);
+	if (ret < 0)
+		dev_warn(dev, "Failed to set xvclk rate (24MHz)\n");
+	if (clk_get_rate(ov9281->xvclk) != OV9281_XVCLK_FREQ)
+		dev_warn(dev, "xvclk mismatched, modes are based on 24MHz - rate is %lu\n",
+			 clk_get_rate(ov9281->xvclk));
+
+	ret = clk_prepare_enable(ov9281->xvclk);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable xvclk\n");
+		return ret;
+	}
+
+	if (!IS_ERR(ov9281->reset_gpio))
+		gpiod_set_value_cansleep(ov9281->reset_gpio, 0);
+
+	ret = regulator_bulk_enable(OV9281_NUM_SUPPLIES, ov9281->supplies);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulators\n");
+		goto disable_clk;
+	}
+
+	if (!IS_ERR(ov9281->reset_gpio))
+		gpiod_set_value_cansleep(ov9281->reset_gpio, 1);
+
+	usleep_range(500, 1000);
+	if (!IS_ERR(ov9281->pwdn_gpio))
+		gpiod_set_value_cansleep(ov9281->pwdn_gpio, 1);
+
+	/* 8192 cycles prior to first SCCB transaction */
+	delay_us = ov9281_cal_delay(8192);
+	usleep_range(delay_us, delay_us * 2);
+
+	return 0;
+
+disable_clk:
+	clk_disable_unprepare(ov9281->xvclk);
+
+	return ret;
+}
+
+static void __ov9281_power_off(struct ov9281 *ov9281)
+{
+	if (!IS_ERR(ov9281->pwdn_gpio))
+		gpiod_set_value_cansleep(ov9281->pwdn_gpio, 0);
+	clk_disable_unprepare(ov9281->xvclk);
+	if (!IS_ERR(ov9281->reset_gpio))
+		gpiod_set_value_cansleep(ov9281->reset_gpio, 0);
+	regulator_bulk_disable(OV9281_NUM_SUPPLIES, ov9281->supplies);
+}
+
+static int ov9281_runtime_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ov9281 *ov9281 = to_ov9281(sd);
+
+	return __ov9281_power_on(ov9281);
+}
+
+static int ov9281_runtime_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ov9281 *ov9281 = to_ov9281(sd);
+
+	__ov9281_power_off(ov9281);
+
+	return 0;
+}
+
+static int ov9281_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct ov9281 *ov9281 = to_ov9281(sd);
+	struct v4l2_mbus_framefmt *try_fmt =
+				v4l2_subdev_get_try_format(sd, fh->state, 0);
+	const struct ov9281_mode *def_mode = &supported_modes[0];
+
+	mutex_lock(&ov9281->mutex);
+	/* Initialize try_fmt */
+	try_fmt->width = def_mode->width;
+	try_fmt->height = def_mode->height;
+	try_fmt->code = MEDIA_BUS_FMT_Y10_1X10;
+	try_fmt->field = V4L2_FIELD_NONE;
+	try_fmt->colorspace = V4L2_COLORSPACE_RAW;
+	try_fmt->ycbcr_enc = V4L2_MAP_YCBCR_ENC_DEFAULT(try_fmt->colorspace);
+	try_fmt->quantization =
+		V4L2_MAP_QUANTIZATION_DEFAULT(true, try_fmt->colorspace,
+					      try_fmt->ycbcr_enc);
+	try_fmt->xfer_func = V4L2_MAP_XFER_FUNC_DEFAULT(try_fmt->colorspace);
+
+	mutex_unlock(&ov9281->mutex);
+	/* No crop or compose */
+
+	return 0;
+}
+
+static const struct dev_pm_ops ov9281_pm_ops = {
+	SET_RUNTIME_PM_OPS(ov9281_runtime_suspend,
+			   ov9281_runtime_resume, NULL)
+};
+
+static const struct v4l2_subdev_internal_ops ov9281_internal_ops = {
+	.open = ov9281_open,
+};
+
+static const struct v4l2_subdev_core_ops ov9281_core_ops = {
+	.s_power = ov9281_s_power,
+};
+
+static const struct v4l2_subdev_video_ops ov9281_video_ops = {
+	.s_stream = ov9281_s_stream,
+};
+
+static const struct v4l2_subdev_pad_ops ov9281_pad_ops = {
+	.enum_mbus_code = ov9281_enum_mbus_code,
+	.enum_frame_size = ov9281_enum_frame_sizes,
+	.get_fmt = ov9281_get_fmt,
+	.set_fmt = ov9281_set_fmt,
+	.get_selection = ov9281_get_selection,
+};
+
+static const struct v4l2_subdev_ops ov9281_subdev_ops = {
+	.core	= &ov9281_core_ops,
+	.video	= &ov9281_video_ops,
+	.pad	= &ov9281_pad_ops,
+};
+
+static int ov9281_set_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct ov9281 *ov9281 = container_of(ctrl->handler,
+					     struct ov9281, ctrl_handler);
+	struct i2c_client *client = ov9281->client;
+	s64 max;
+	int ret = 0;
+
+	/* Propagate change of current control to all related controls */
+	switch (ctrl->id) {
+	case V4L2_CID_VBLANK:
+		/* Update max exposure while meeting expected vblanking */
+		max = ov9281->cur_mode->height + ctrl->val - 4;
+		__v4l2_ctrl_modify_range(ov9281->exposure,
+					 ov9281->exposure->minimum, max,
+					 ov9281->exposure->step,
+					 ov9281->exposure->default_value);
+		break;
+	}
+
+	if (pm_runtime_get(&client->dev) <= 0)
+		return 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_HFLIP:
+		ret = ov9281_set_ctrl_hflip(ov9281, ctrl->val);
+		break;
+	case V4L2_CID_VFLIP:
+		ret = ov9281_set_ctrl_vflip(ov9281, ctrl->val);
+		break;
+	case V4L2_CID_EXPOSURE:
+		/* 4 least significant bits of expsoure are fractional part */
+		ret = ov9281_write_reg(ov9281->client, OV9281_REG_EXPOSURE,
+				       OV9281_REG_VALUE_24BIT, ctrl->val << 4);
+		break;
+	case V4L2_CID_ANALOGUE_GAIN:
+		ret = ov9281_write_reg(ov9281->client, OV9281_REG_GAIN_H,
+				       OV9281_REG_VALUE_08BIT,
+				       (ctrl->val >> OV9281_GAIN_H_SHIFT) &
+							OV9281_GAIN_H_MASK);
+		ret |= ov9281_write_reg(ov9281->client, OV9281_REG_GAIN_L,
+				       OV9281_REG_VALUE_08BIT,
+				       ctrl->val & OV9281_GAIN_L_MASK);
+		break;
+	case V4L2_CID_VBLANK:
+		ret = ov9281_write_reg(ov9281->client, OV9281_REG_VTS,
+				       OV9281_REG_VALUE_16BIT,
+				       ctrl->val + ov9281->cur_mode->height);
+		break;
+	case V4L2_CID_TEST_PATTERN:
+		ret = ov9281_enable_test_pattern(ov9281, ctrl->val);
+		break;
+	default:
+		dev_warn(&client->dev, "%s Unhandled id:0x%x, val:0x%x\n",
+			 __func__, ctrl->id, ctrl->val);
+		break;
+	}
+
+	pm_runtime_put(&client->dev);
+
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops ov9281_ctrl_ops = {
+	.s_ctrl = ov9281_set_ctrl,
+};
+
+static int ov9281_initialize_controls(struct ov9281 *ov9281)
+{
+	struct v4l2_fwnode_device_properties props;
+	const struct ov9281_mode *mode;
+	struct v4l2_ctrl_handler *handler;
+	struct v4l2_ctrl *ctrl;
+	s64 exposure_max, vblank_def;
+	u32 h_blank;
+	int ret;
+
+	handler = &ov9281->ctrl_handler;
+	mode = ov9281->cur_mode;
+	ret = v4l2_ctrl_handler_init(handler, 11);
+	if (ret)
+		return ret;
+	handler->lock = &ov9281->mutex;
+
+	ctrl = v4l2_ctrl_new_int_menu(handler, NULL, V4L2_CID_LINK_FREQ,
+				      0, 0, link_freq_menu_items);
+	if (ctrl)
+		ctrl->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+
+	ov9281->pixel_rate = v4l2_ctrl_new_std(handler, NULL,
+					       V4L2_CID_PIXEL_RATE,
+					       OV9281_PIXEL_RATE_10BIT,
+					       OV9281_PIXEL_RATE_10BIT, 1,
+					       OV9281_PIXEL_RATE_10BIT);
+
+	h_blank = mode->hts_def - mode->width;
+	ov9281->hblank = v4l2_ctrl_new_std(handler, NULL, V4L2_CID_HBLANK,
+					   h_blank, h_blank, 1, h_blank);
+	if (ov9281->hblank)
+		ov9281->hblank->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+
+	vblank_def = mode->vts_def - mode->height;
+	ov9281->vblank = v4l2_ctrl_new_std(handler, &ov9281_ctrl_ops,
+					   V4L2_CID_VBLANK, vblank_def,
+					   OV9281_VTS_MAX - mode->height, 1,
+					   vblank_def);
+
+	exposure_max = mode->vts_def - 4;
+	ov9281->exposure = v4l2_ctrl_new_std(handler, &ov9281_ctrl_ops,
+					     V4L2_CID_EXPOSURE,
+					     OV9281_EXPOSURE_MIN, exposure_max,
+					     OV9281_EXPOSURE_STEP,
+					     mode->exp_def);
+
+	ov9281->anal_gain = v4l2_ctrl_new_std(handler, &ov9281_ctrl_ops,
+					      V4L2_CID_ANALOGUE_GAIN,
+					      OV9281_GAIN_MIN, OV9281_GAIN_MAX,
+					      OV9281_GAIN_STEP,
+					      OV9281_GAIN_DEFAULT);
+
+	ov9281->vflip = v4l2_ctrl_new_std(handler, &ov9281_ctrl_ops,
+					  V4L2_CID_VFLIP,
+						0, 1, 1, 0);
+
+	ov9281->hflip = v4l2_ctrl_new_std(handler, &ov9281_ctrl_ops,
+					  V4L2_CID_HFLIP,
+						0, 1, 1, 0);
+
+	ov9281->test_pattern =
+		v4l2_ctrl_new_std_menu_items(handler, &ov9281_ctrl_ops,
+					     V4L2_CID_TEST_PATTERN,
+					     ARRAY_SIZE(ov9281_test_pattern_menu) - 1,
+					     0, 0, ov9281_test_pattern_menu);
+
+	if (handler->error) {
+		ret = handler->error;
+		dev_err(&ov9281->client->dev,
+			"Failed to init controls(%d)\n", ret);
+		goto err_free_handler;
+	}
+
+	ret = v4l2_fwnode_device_parse(&ov9281->client->dev, &props);
+	if (ret)
+		goto err_free_handler;
+
+	ret = v4l2_ctrl_new_fwnode_properties(handler, &ov9281_ctrl_ops,
+					      &props);
+	if (ret)
+		goto err_free_handler;
+
+	ov9281->subdev.ctrl_handler = handler;
+
+	return 0;
+
+err_free_handler:
+	v4l2_ctrl_handler_free(handler);
+
+	return ret;
+}
+
+static int ov9281_check_sensor_id(struct ov9281 *ov9281,
+				  struct i2c_client *client)
+{
+	struct device *dev = &ov9281->client->dev;
+	u32 id = 0, id_msb;
+	int ret;
+
+	ret = ov9281_read_reg(client, OV9281_REG_CHIP_ID + 1,
+			      OV9281_REG_VALUE_08BIT, &id);
+	if (!ret)
+		ret = ov9281_read_reg(client, OV9281_REG_CHIP_ID,
+				      OV9281_REG_VALUE_08BIT, &id_msb);
+	id |= (id_msb << 8);
+	if (ret || id != CHIP_ID) {
+		dev_err(dev, "Unexpected sensor id(%04x), ret(%d)\n", id, ret);
+		return -ENODEV;
+	}
+
+	dev_info(dev, "Detected OV%06x sensor\n", CHIP_ID);
+
+	return 0;
+}
+
+static int ov9281_configure_regulators(struct ov9281 *ov9281)
+{
+	unsigned int i;
+
+	for (i = 0; i < OV9281_NUM_SUPPLIES; i++)
+		ov9281->supplies[i].supply = ov9281_supply_names[i];
+
+	return devm_regulator_bulk_get(&ov9281->client->dev,
+				       OV9281_NUM_SUPPLIES,
+				       ov9281->supplies);
+}
+
+static int ov9281_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct device *dev = &client->dev;
+	struct ov9281 *ov9281;
+	struct v4l2_subdev *sd;
+	int ret;
+
+	ov9281 = devm_kzalloc(dev, sizeof(*ov9281), GFP_KERNEL);
+	if (!ov9281)
+		return -ENOMEM;
+
+	ov9281->client = client;
+	ov9281->cur_mode = &supported_modes[0];
+
+	ov9281->xvclk = devm_clk_get(dev, "xvclk");
+	if (IS_ERR(ov9281->xvclk)) {
+		dev_err(dev, "Failed to get xvclk\n");
+		return -EINVAL;
+	}
+
+	ov9281->reset_gpio = devm_gpiod_get_optional(dev, "reset",
+						     GPIOD_OUT_LOW);
+	if (IS_ERR(ov9281->reset_gpio))
+		dev_warn(dev, "Failed to get reset-gpios\n");
+
+	ov9281->pwdn_gpio = devm_gpiod_get_optional(dev, "pwdn", GPIOD_OUT_LOW);
+	if (IS_ERR(ov9281->pwdn_gpio))
+		dev_warn(dev, "Failed to get pwdn-gpios\n");
+
+	ret = ov9281_configure_regulators(ov9281);
+	if (ret) {
+		dev_err(dev, "Failed to get power regulators\n");
+		return ret;
+	}
+
+	mutex_init(&ov9281->mutex);
+
+	sd = &ov9281->subdev;
+	v4l2_i2c_subdev_init(sd, client, &ov9281_subdev_ops);
+	ret = ov9281_initialize_controls(ov9281);
+	if (ret)
+		goto err_destroy_mutex;
+
+	ret = __ov9281_power_on(ov9281);
+	if (ret)
+		goto err_free_handler;
+
+	ret = ov9281_check_sensor_id(ov9281, client);
+	if (ret)
+		goto err_power_off;
+
+	sd->internal_ops = &ov9281_internal_ops;
+	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+	ov9281->pad.flags = MEDIA_PAD_FL_SOURCE;
+	sd->entity.function = MEDIA_ENT_F_CAM_SENSOR;
+	ret = media_entity_pads_init(&sd->entity, 1, &ov9281->pad);
+	if (ret < 0)
+		goto err_power_off;
+
+	ret = v4l2_async_register_subdev_sensor(sd);
+	if (ret) {
+		dev_err(dev, "v4l2 async register subdev failed\n");
+		goto err_clean_entity;
+	}
+
+	pm_runtime_set_active(dev);
+	pm_runtime_enable(dev);
+	pm_runtime_idle(dev);
+
+	return 0;
+
+err_clean_entity:
+	media_entity_cleanup(&sd->entity);
+err_power_off:
+	__ov9281_power_off(ov9281);
+err_free_handler:
+	v4l2_ctrl_handler_free(&ov9281->ctrl_handler);
+err_destroy_mutex:
+	mutex_destroy(&ov9281->mutex);
+
+	return ret;
+}
+
+static void ov9281_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ov9281 *ov9281 = to_ov9281(sd);
+
+	v4l2_async_unregister_subdev(sd);
+	media_entity_cleanup(&sd->entity);
+	v4l2_ctrl_handler_free(&ov9281->ctrl_handler);
+	mutex_destroy(&ov9281->mutex);
+
+	pm_runtime_disable(&client->dev);
+	if (!pm_runtime_status_suspended(&client->dev))
+		__ov9281_power_off(ov9281);
+	pm_runtime_set_suspended(&client->dev);
+}
+
+static const struct of_device_id ov9281_of_match[] = {
+	{ .compatible = "ovti,ov9281" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, ov9281_of_match);
+
+static const struct i2c_device_id ov9281_match_id[] = {
+	{ "ovti,ov9281", 0 },
+	{ },
+};
+
+static struct i2c_driver ov9281_i2c_driver = {
+	.driver = {
+		.name = OV9281_NAME,
+		.pm = &ov9281_pm_ops,
+		.of_match_table = of_match_ptr(ov9281_of_match),
+	},
+	.probe		= &ov9281_probe,
+	.remove		= &ov9281_remove,
+	.id_table	= ov9281_match_id,
+};
+
+static int __init sensor_mod_init(void)
+{
+	return i2c_add_driver(&ov9281_i2c_driver);
+}
+
+static void __exit sensor_mod_exit(void)
+{
+	i2c_del_driver(&ov9281_i2c_driver);
+}
+
+device_initcall_sync(sensor_mod_init);
+module_exit(sensor_mod_exit);
+
+MODULE_DESCRIPTION("OmniVision ov9281 sensor driver");
+MODULE_LICENSE("GPL v2");
--- a/drivers/media/platform/bcm2835/bcm2835-unicam.c
+++ b/drivers/media/platform/bcm2835/bcm2835-unicam.c
@@ -443,7 +443,7 @@ struct unicam_device {
 	/* ptr to  sub device */
 	struct v4l2_subdev *sensor;
 	/* Pad config for the sensor */
-	struct v4l2_subdev_pad_config *sensor_config;
+	struct v4l2_subdev_state *sensor_state;
 
 	enum v4l2_mbus_type bus_type;
 	/*
@@ -594,7 +594,7 @@ static int __subdev_get_format(struct un
 	};
 	int ret;
 
-	ret = v4l2_subdev_call(dev->sensor, pad, get_fmt, dev->sensor_config,
+	ret = v4l2_subdev_call(dev->sensor, pad, get_fmt, dev->sensor_state,
 			       &sd_fmt);
 	if (ret < 0)
 		return ret;
@@ -618,7 +618,7 @@ static int __subdev_set_format(struct un
 
 	sd_fmt.format = *fmt;
 
-	ret = v4l2_subdev_call(dev->sensor, pad, set_fmt, dev->sensor_config,
+	ret = v4l2_subdev_call(dev->sensor, pad, set_fmt, dev->sensor_state,
 			       &sd_fmt);
 	if (ret < 0)
 		return ret;
@@ -1094,7 +1094,7 @@ static int unicam_try_fmt_vid_cap(struct
 	 */
 	mbus_fmt->field = V4L2_FIELD_NONE;
 
-	ret = v4l2_subdev_call(dev->sensor, pad, set_fmt, dev->sensor_config,
+	ret = v4l2_subdev_call(dev->sensor, pad, set_fmt, dev->sensor_state,
 			       &sd_fmt);
 	if (ret && ret != -ENOIOCTLCMD && ret != -ENODEV)
 		return ret;
@@ -1116,7 +1116,7 @@ static int unicam_try_fmt_vid_cap(struct
 			mbus_fmt->code = fmt->code;
 
 			ret = v4l2_subdev_call(dev->sensor, pad, set_fmt,
-					       dev->sensor_config, &sd_fmt);
+					       dev->sensor_state, &sd_fmt);
 			if (ret && ret != -ENOIOCTLCMD && ret != -ENODEV)
 				return ret;
 
@@ -2320,8 +2320,8 @@ static void unicam_release(struct kref *
 	v4l2_ctrl_handler_free(&unicam->ctrl_handler);
 	media_device_cleanup(&unicam->mdev);
 
-	if (unicam->sensor_config)
-		v4l2_subdev_free_pad_config(unicam->sensor_config);
+	if (unicam->sensor_state)
+		__v4l2_subdev_state_free(unicam->sensor_state);
 
 	kfree(unicam);
 }
@@ -2579,12 +2579,14 @@ static void unregister_nodes(struct unic
 
 static int unicam_probe_complete(struct unicam_device *unicam)
 {
+	static struct lock_class_key key;
 	int ret;
 
 	unicam->v4l2_dev.notify = unicam_notify;
 
-	unicam->sensor_config = v4l2_subdev_alloc_pad_config(unicam->sensor);
-	if (!unicam->sensor_config)
+	unicam->sensor_state = __v4l2_subdev_state_alloc(unicam->sensor,
+							 "unicam:async->lock", &key);
+	if (!unicam->sensor_state)
 		return -ENOMEM;
 
 	unicam->sensor_embedded_data = (unicam->sensor->entity.num_pads >= 2);
--- a/drivers/staging/vc04_services/bcm2835-isp/bcm2835-v4l2-isp.c
+++ b/drivers/staging/vc04_services/bcm2835-isp/bcm2835-v4l2-isp.c
@@ -1465,7 +1465,7 @@ queue_cleanup:
 }
 
 /* Unregister one of the /dev/video<N> nodes associated with the ISP. */
-static void unregister_node(struct bcm2835_isp_node *node)
+static void bcm2835_unregister_node(struct bcm2835_isp_node *node)
 {
 	struct bcm2835_isp_dev *dev = node_get_dev(node);
 
@@ -1668,7 +1668,7 @@ static int bcm2835_isp_remove(struct pla
 	media_controller_unregister(dev);
 
 	for (i = 0; i < BCM2835_ISP_NUM_NODES; i++)
-		unregister_node(&dev->node[i]);
+		bcm2835_unregister_node(&dev->node[i]);
 
 	v4l2_device_unregister(&dev->v4l2_dev);
 
