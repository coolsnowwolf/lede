From 6ef818eed60db70e9caf6bdf74cc1f9943994226 Mon Sep 17 00:00:00 2001
From: Naushir Patuck <naush@raspberrypi.com>
Date: Fri, 16 Jun 2023 16:24:19 +0100
Subject: [PATCH] drivers: media: bcm2835_unicam: Improve frame sequence count
 handling

Ensure that the frame sequence counter is incremented only if a previous
frame start interrupt has occurred, or a frame start + frame end has
occurred simultaneously.

This corresponds the sequence number with the actual number of frames
produced by the sensor, not the number of frame buffers dequeued back
to userland.

Signed-off-by: Naushir Patuck <naush@raspberrypi.com>
---
 .../media/platform/bcm2835/bcm2835-unicam.c   | 19 ++++++++++++++++++-
 1 file changed, 18 insertions(+), 1 deletion(-)

--- a/drivers/media/platform/bcm2835/bcm2835-unicam.c
+++ b/drivers/media/platform/bcm2835/bcm2835-unicam.c
@@ -522,6 +522,7 @@ struct unicam_device {
 	/* subdevice async Notifier */
 	struct v4l2_async_notifier notifier;
 	unsigned int sequence;
+	bool frame_started;
 
 	/* ptr to  sub device */
 	struct v4l2_subdev *sensor;
@@ -914,6 +915,8 @@ static irqreturn_t unicam_isr(int irq, v
 	 * buffer forever.
 	 */
 	if (fe) {
+		bool inc_seq = unicam->frame_started;
+
 		/*
 		 * Ensure we have swapped buffers already as we can't
 		 * stop the peripheral. If no buffer is available, use a
@@ -949,11 +952,23 @@ static irqreturn_t unicam_isr(int irq, v
 				unicam_process_buffer_complete(node, sequence);
 				node->cur_frm = node->next_frm;
 				node->next_frm = NULL;
+				inc_seq = true;
 			} else {
 				node->cur_frm = node->next_frm;
 			}
 		}
-		unicam->sequence++;
+
+		/*
+		 * Increment the sequence number conditionally on either a FS
+		 * having already occurred, or in the FE + FS condition as
+		 * caught in the FE handler above. This ensures the sequence
+		 * number corresponds to the frames generated by the sensor, not
+		 * the frames dequeued to userland.
+		 */
+		if (inc_seq) {
+			unicam->sequence++;
+			unicam->frame_started = false;
+		}
 	}
 
 	if (ista & UNICAM_FSI) {
@@ -996,6 +1011,7 @@ static irqreturn_t unicam_isr(int irq, v
 		}
 
 		unicam_queue_event_sof(unicam);
+		unicam->frame_started = true;
 	}
 
 	/*
@@ -2600,6 +2616,7 @@ static int unicam_start_streaming(struct
 			vb2_dma_contig_plane_dma_addr(&buf->vb.vb2_buf, 0);
 	}
 
+	dev->frame_started = false;
 	unicam_start_rx(dev, buffer_addr);
 
 	ret = v4l2_subdev_call(dev->sensor, video, s_stream, 1);
