From 663b9f99bb35dbc0c7b685f71ee3668a60d31320 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <kabel@kernel.org>
Date: Mon, 10 Jan 2022 02:02:00 +0100
Subject: [PATCH] PCI: aardvark: Make main irq_chip structure a static driver
 structure
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Marc Zyngier says [1] that we should use struct irq_chip as a global
static struct in the driver. Even though the structure currently
contains a dynamic member (parent_device), Marc says [2] that he plans
to kill it and make the structure completely static.

We have already converted others irq_chip structures in this driver in
this way, but we omitted this one because the .name member is
dynamically created from device's name, and the name is displayed in
sysfs, so changing it would break sysfs ABI.

The rationale for changing the name (to "advk-INT") in spite of sysfs
ABI, and thus allowing to convert to a static structure, is that after
the other changes we made in this series, the IRQ chip is basically
something different: it no logner generates ERR and PME interrupts (they
are generated by emulated bridge's rp_irq_chip).

[1] https://lore.kernel.org/linux-pci/877dbcvngf.wl-maz@kernel.org/
[2] https://lore.kernel.org/linux-pci/874k6gvkhz.wl-maz@kernel.org/

Signed-off-by: Marek Beh√∫n <kabel@kernel.org>
---
 drivers/pci/controller/pci-aardvark.c | 25 +++++++------------------
 1 file changed, 7 insertions(+), 18 deletions(-)

--- a/drivers/pci/controller/pci-aardvark.c
+++ b/drivers/pci/controller/pci-aardvark.c
@@ -275,7 +275,6 @@ struct advk_pcie {
 	u8 wins_count;
 	struct irq_domain *rp_irq_domain;
 	struct irq_domain *irq_domain;
-	struct irq_chip irq_chip;
 	raw_spinlock_t irq_lock;
 	struct irq_domain *msi_domain;
 	struct irq_domain *msi_inner_domain;
@@ -1345,14 +1344,19 @@ static void advk_pcie_irq_unmask(struct
 	raw_spin_unlock_irqrestore(&pcie->irq_lock, flags);
 }
 
+static struct irq_chip advk_irq_chip = {
+	.name		= "advk-INT",
+	.irq_mask	= advk_pcie_irq_mask,
+	.irq_unmask	= advk_pcie_irq_unmask,
+};
+
 static int advk_pcie_irq_map(struct irq_domain *h,
 			     unsigned int virq, irq_hw_number_t hwirq)
 {
 	struct advk_pcie *pcie = h->host_data;
 
 	irq_set_status_flags(virq, IRQ_LEVEL);
-	irq_set_chip_and_handler(virq, &pcie->irq_chip,
-				 handle_level_irq);
+	irq_set_chip_and_handler(virq, &advk_irq_chip, handle_level_irq);
 	irq_set_chip_data(virq, pcie);
 
 	return 0;
@@ -1411,7 +1415,6 @@ static int advk_pcie_init_irq_domain(str
 	struct device *dev = &pcie->pdev->dev;
 	struct device_node *node = dev->of_node;
 	struct device_node *pcie_intc_node;
-	struct irq_chip *irq_chip;
 	int ret = 0;
 
 	raw_spin_lock_init(&pcie->irq_lock);
@@ -1422,28 +1425,14 @@ static int advk_pcie_init_irq_domain(str
 		return -ENODEV;
 	}
 
-	irq_chip = &pcie->irq_chip;
-
-	irq_chip->name = devm_kasprintf(dev, GFP_KERNEL, "%s-irq",
-					dev_name(dev));
-	if (!irq_chip->name) {
-		ret = -ENOMEM;
-		goto out_put_node;
-	}
-
-	irq_chip->irq_mask = advk_pcie_irq_mask;
-	irq_chip->irq_unmask = advk_pcie_irq_unmask;
-
 	pcie->irq_domain =
 		irq_domain_add_linear(pcie_intc_node, PCI_NUM_INTX,
 				      &advk_pcie_irq_domain_ops, pcie);
 	if (!pcie->irq_domain) {
 		dev_err(dev, "Failed to get a INTx IRQ domain\n");
 		ret = -ENOMEM;
-		goto out_put_node;
 	}
 
-out_put_node:
 	of_node_put(pcie_intc_node);
 	return ret;
 }
