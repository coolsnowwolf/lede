diff --git a/lib/param/param_functions.c b/lib/param/param_functions.c
index 41b44b6..3e45935 100644
--- a/lib/param/param_functions.c
+++ b/lib/param/param_functions.c
@@ -109,6 +109,7 @@ FN_LOCAL_BOOL(onlyuser, bOnlyUser)
 FN_LOCAL_PARM_BOOL(manglednames, bMangledNames)
 FN_LOCAL_BOOL(symlinks, bSymlinks)
 FN_LOCAL_BOOL(syncalways, bSyncAlways)
+FN_LOCAL_BOOL(skip_ftruncate, bSkipFtruncate)
 FN_LOCAL_BOOL(strict_allocate, bStrictAllocate)
 FN_LOCAL_BOOL(delete_readonly, bDeleteReadonly)
 FN_LOCAL_BOOL(fake_oplocks, bFakeOplocks)
diff --git a/lib/param/param_table.c b/lib/param/param_table.c
index 0916023..27cc873 100644
--- a/lib/param/param_table.c
+++ b/lib/param/param_table.c
@@ -1869,6 +1869,15 @@ static struct parm_struct parm_table[] = {
 		.flags		= FLAG_ADVANCED,
 	},
 	{
+		.label		= "skip ftruncate",
+		.type		= P_BOOL,
+		.p_class	= P_LOCAL,
+		.offset		= LOCAL_VAR(bSkipFtruncate),
+		.special	= NULL,
+		.enum_list	= NULL,
+		.flags		= FLAG_ADVANCED | FLAG_SHARE,
+	},
+	{
 		.label		= "strict allocate",
 		.type		= P_BOOL,
 		.p_class	= P_LOCAL,
diff --git a/source3/autoconf/lib/param/param_local.h b/source3/autoconf/lib/param/param_local.h
deleted file mode 100644
index 89eb6c3..0000000
--- a/source3/autoconf/lib/param/param_local.h
+++ /dev/null
@@ -1,142 +0,0 @@
-#ifndef __AUTOCONF_LIB_PARAM_PARAM_LOCAL_H__
-#define __AUTOCONF_LIB_PARAM_PARAM_LOCAL_H__
-
-/* This file was automatically generated by mkparamdefs.pl. DO NOT EDIT */
-
-/**
- * This structure describes a single service.
- */
-struct loadparm_service 
-{
-	char *  szPath;
-	const char **  szHostsallow;
-	const char **  szHostsdeny;
-	char *  fstype;
-	const char **  ntvfs_handler;
-	bool   bMSDfsRoot;
-	bool   bBrowseable;
-	bool   bRead_only;
-	bool   bPrint_ok;
-	bool   bMap_hidden;
-	bool   bMap_archive;
-	bool   bOpLocks;
-	bool   bStrictSync;
-	bool   bMap_system;
-	int   iMaxConnections;
-	int   iCSCPolicy;
-	int   iCreate_mask;
-	int   iCreate_force_mode;
-	int   iDir_mask;
-	int   iDir_force_mode;
-	char *  szPreExec;
-	char *  szPostExec;
-	char *  szRootPreExec;
-	char *  szRootPostExec;
-	char *  szDontdescend;
-	char *  szUsername;
-	const char **  szInvalidUsers;
-	const char **  szValidUsers;
-	const char **  szAdminUsers;
-	char *  szPrintcommand;
-	char *  szLpqcommand;
-	char *  szLprmcommand;
-	char *  szLppausecommand;
-	char *  szLpresumecommand;
-	char *  szQueuepausecommand;
-	char *  szQueueresumecommand;
-	char *  szPrintername;
-	char *  szPrintjobUsername;
-	char *  szMagicScript;
-	char *  szMagicOutput;
-	char *  comment;
-	char *  force_user;
-	char *  force_group;
-	const char **  readlist;
-	const char **  writelist;
-	const char **  printer_admin;
-	const char **  szVfsObjects;
-	char *  szMSDfsProxy;
-	char *  volume;
-	char *  szVetoFiles;
-	char *  szHideFiles;
-	char *  szVetoOplockFiles;
-	char *  szAioWriteBehind;
-	char *  szDfree;
-	bool   autoloaded;
-	bool   bPreexecClose;
-	bool   bRootpreexecClose;
-	int   iCaseSensitive;
-	bool   bCasePreserve;
-	bool   bShortCasePreserve;
-	bool   bHideDotFiles;
-	bool   bHideSpecialFiles;
-	bool   bHideUnReadable;
-	bool   bHideUnWriteableFiles;
-	bool   bAccessBasedShareEnum;
-	bool   bNo_set_dir;
-	bool   bGuest_ok;
-	bool   bGuest_only;
-	bool   bAdministrative_share;
-	bool   bPrintNotifyBackchannel;
-	bool   bStoreDosAttributes;
-	bool   bDmapiSupport;
-	bool   bLocking;
-	int   iStrictLocking;
-	bool   bPosixLocking;
-	bool   bKernelOplocks;
-	bool   bLevel2OpLocks;
-	bool   bKernelShareModes;
-	bool   bOnlyUser;
-	bool   bMangledNames;
-	bool   bSymlinks;
-	bool   bSyncAlways;
-	bool   bStrictAllocate;
-	bool   bDeleteReadonly;
-	bool   bFakeOplocks;
-	bool   bDeleteVetoFiles;
-	bool   bDosFilemode;
-	bool   bDosFiletimes;
-	bool   bDosFiletimeResolution;
-	bool   bFakeDirCreateTimes;
-	bool   bBlockingLocks;
-	bool   bInheritPerms;
-	bool   bInheritACLS;
-	bool   bInheritOwner;
-	bool   bUseClientDriver;
-	bool   bDefaultDevmode;
-	bool   bForcePrintername;
-	bool   bNTAclSupport;
-	bool   bForceUnknownAclUser;
-	bool   bEASupport;
-	bool   bUseSendfile;
-	bool   bProfileAcls;
-	bool   bMap_acl_inherit;
-	bool   bAfs_Share;
-	bool   bAclCheckPermissions;
-	bool   bAclGroupControl;
-	bool   bAclMapFullControl;
-	bool   bAclAllowExecuteAlways;
-	int   iDefaultCase;
-	int   iMinPrintSpace;
-	int   iPrinting;
-	int   iMaxReportedPrintJobs;
-	int   iOplockContentionLimit;
-	int   iWriteCacheSize;
-	int   iBlock_size;
-	int   iDfreeCacheTime;
-	int   iallocation_roundup_size;
-	int   iAioReadSize;
-	int   iAioWriteSize;
-	int   iMap_readonly;
-	int   iDirectoryNameCacheSize;
-	int   ismb_encrypt;
-	char   magic_char;
-	char *  szCupsOptions;
-	bool   bChangeNotify;
-	bool   bKernelChangeNotify;
-	bool   bDurableHandles;
-LOADPARM_EXTRA_LOCALS
-};
-
-#endif /* __AUTOCONF_LIB_PARAM_PARAM_LOCAL_H__ */
-
diff --git a/source3/include/proto.h b/source3/include/proto.h
index 1d2eaf5..6be58fb 100644
--- a/source3/include/proto.h
+++ b/source3/include/proto.h
@@ -1299,6 +1299,7 @@ bool lp_widelinks(int );
 bool lp_symlinks(int );
 bool lp_syncalways(int );
 bool lp_strict_allocate(int );
+bool lp_skip_ftruncate(int );
 bool lp_strict_sync(int );
 bool lp_map_system(int );
 bool lp_delete_readonly(int );
diff --git a/source3/modules/vfs_default.c b/source3/modules/vfs_default.c
index 429fca1..1b3244c 100644
--- a/source3/modules/vfs_default.c
+++ b/source3/modules/vfs_default.c
@@ -1687,7 +1697,31 @@ static int vfswrap_ftruncate(vfs_handle_struct *handle, files_struct *fsp, off_t
 		END_PROFILE(syscall_ftruncate);
 		return result;
 	}
+	/* check for an MSDOS (FAT) filesystem and don't truncate. Ftruncate on an MSDOS filesystem can time causeing failures when the file
+	   size reaches about 300MB to 600MB depending in the speed of the system. Allow forcing the ftruncate for shrinking files as not
+	   shrinking a file can cause worse problems and for things like smbpasswd that won't timeout.
+	 */
+	if(lp_skip_ftruncate(SNUM(fsp->conn)) && !fsp->is_sparse) {
+#if 1
+		struct statfs   s;
+		if(fstatfs(fsp->fh->fd, &s)) {	/* get filesystem type */
+			syslog("Samba: fstatfs fail\n");
+			goto done;	
+		}
+		if(s.f_type == 0x2011bab0 ) {
+			syslog("Samba: exFAT Filesystem,length:0x%X\n", len);
+			goto done;
+		}
+ 		else if(s.f_type == 0x4d44) {
+ 			syslog("Samba: vFAT/FAT Filesystem,length:0x%X\n", len);
+			goto done;
+		} else 
+			syslog("Samba: Skip Filesystem:0x%X\n", s.f_type);
+#else
+		goto done;
+#endif
 
+	}	
 	/* we used to just check HAVE_FTRUNCATE_EXTEND and only use
 	   ftruncate if the system supports it. Then I discovered that
 	   you can have some filesystems that support ftruncate
diff --git a/source3/param/loadparm.c b/source3/param/loadparm.c
index 878cc3a..53e04f9 100644
--- a/source3/param/loadparm.c
+++ b/source3/param/loadparm.c
@@ -235,6 +235,7 @@ static struct loadparm_service sDefault =
 	.bWidelinks = false,
 	.bSymlinks = true,
 	.bSyncAlways = false,
+	.bSkipFtruncate = false,
 	.bStrictAllocate = false,
 	.bStrictSync = false,
 	.magic_char = '~',
