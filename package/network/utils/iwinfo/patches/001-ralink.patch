--- /dev/null
+++ b/api/ralink.h
@@ -0,0 +1,207 @@
+#ifndef _RALINK_H
+#define _RALINK_H
+
+#define MAX_NUMBER_OF_MAC		    64
+
+#define MODE_CCK		0
+#define MODE_OFDM		1
+#define MODE_HTMIX		2
+#define MODE_HTGREENFIELD	3
+
+#define BW_20			0
+#define BW_40			1
+#define BW_BOTH			2
+#define BW_10			3
+
+#define 		MAC_ADDR_LEN 6
+#define 		ETH_LENGTH_OF_ADDRESS 6
+#define 		MAX_LEN_OF_MAC_TABLE 64
+
+#define RT_PRIV_IOCTL				(SIOCIWFIRSTPRIV + 0x01)
+#define RTPRIV_IOCTL_SET			(SIOCIWFIRSTPRIV + 0x02)
+
+#define RTPRIV_IOCTL_BBP			(SIOCIWFIRSTPRIV + 0x03)
+#define RTPRIV_IOCTL_MAC			(SIOCIWFIRSTPRIV + 0x05)
+#define RTPRIV_IOCTL_E2P			(SIOCIWFIRSTPRIV + 0x07)
+
+#define RTPRIV_IOCTL_STATISTICS				(SIOCIWFIRSTPRIV + 0x09)
+#define RTPRIV_IOCTL_ADD_PMKID_CACHE		(SIOCIWFIRSTPRIV + 0x0A)
+#define RTPRIV_IOCTL_RADIUS_DATA			(SIOCIWFIRSTPRIV + 0x0C)
+#define RTPRIV_IOCTL_GSITESURVEY			(SIOCIWFIRSTPRIV + 0x0D)
+#define RTPRIV_IOCTL_ADD_WPA_KEY			(SIOCIWFIRSTPRIV + 0x0E)
+#define RTPRIV_IOCTL_GET_MAC_TABLE			(SIOCIWFIRSTPRIV + 0x0F)
+#define RTPRIV_IOCTL_GET_MAC_TABLE_STRUCT	(SIOCIWFIRSTPRIV + 0x1F)
+#define RTPRIV_IOCTL_STATIC_WEP_COPY		(SIOCIWFIRSTPRIV + 0x10)
+#define RTPRIV_IOCTL_WSC_PROFILE			(SIOCIWFIRSTPRIV + 0x12)
+#define	RTPRIV_IOCTL_GSTAINFO				(SIOCIWFIRSTPRIV + 0x1A)
+#define	RTPRIV_IOCTL_GSTAT					(SIOCIWFIRSTPRIV + 0x1B)
+#define RTPRIV_IOCTL_GRSSI					(SIOCIWFIRSTPRIV + 0x1C)
+#define RTPRIV_IOCTL_GTXBFCALP				(SIOCIWFIRSTPRIV + 0x1D)
+
+#define RT_QUERY_ATE_TXDONE_COUNT			0x0401
+#define OID_GET_SET_TOGGLE					0x8000
+
+#define OID_802_11_NETWORK_TYPES_SUPPORTED          0x0103
+#define OID_802_11_NETWORK_TYPE_IN_USE		   0x0104
+#define OID_802_11_RSSI_TRIGGER		          0x0107
+#define RT_OID_802_11_RSSI							0x0108 //rt2860 only , kathy
+#define RT_OID_802_11_RSSI_1						0x0109 //rt2860 only , kathy
+#define RT_OID_802_11_RSSI_2						0x010A //rt2860 only , kathy
+#define OID_802_11_NUMBER_OF_ANTENNAS		    0x010B
+#define OID_802_11_RX_ANTENNA_SELECTED		   0x010C
+#define OID_802_11_TX_ANTENNA_SELECTED		   0x010D
+#define OID_802_11_SUPPORTED_RATES		       0x010E
+#define OID_802_11_ADD_WEP				    0x0112
+#define OID_802_11_REMOVE_WEP				 0x0113
+#define OID_802_11_DISASSOCIATE		          0x0114
+#define OID_802_11_PRIVACY_FILTER		        0x0118
+#define OID_802_11_ASSOCIATION_INFORMATION          0x011E
+#define OID_802_11_TEST				       0x011F
+#define RT_OID_802_11_COUNTRY_REGION		     0x0507
+#define OID_802_11_BSSID_LIST_SCAN		       0x0508
+#define OID_802_11_SSID				       0x0509
+#define OID_802_11_BSSID				      0x050A
+#define RT_OID_802_11_RADIO				   0x050B
+#define RT_OID_802_11_PHY_MODE				0x050C
+#define RT_OID_802_11_STA_CONFIG		         0x050D
+#define OID_802_11_DESIRED_RATES		         0x050E
+#define RT_OID_802_11_PREAMBLE				0x050F
+#define OID_802_11_WEP_STATUS				 0x0510
+#define OID_802_11_AUTHENTICATION_MODE		   0x0511
+#define OID_802_11_INFRASTRUCTURE_MODE		   0x0512
+#define RT_OID_802_11_RESET_COUNTERS		     0x0513
+#define OID_802_11_RTS_THRESHOLD		         0x0514
+#define OID_802_11_FRAGMENTATION_THRESHOLD          0x0515
+#define OID_802_11_POWER_MODE				 0x0516
+#define OID_802_11_TX_POWER_LEVEL		        0x0517
+#define RT_OID_802_11_ADD_WPA				 0x0518
+#define OID_802_11_REMOVE_KEY				 0x0519
+#define OID_802_11_ADD_KEY				    0x0520
+#define OID_802_11_CONFIGURATION		         0x0521
+#define OID_802_11_TX_PACKET_BURST					0x0522
+#define RT_OID_802_11_QUERY_NOISE_LEVEL		  0x0523
+#define RT_OID_802_11_EXTRA_INFO		         0x0524
+#define RT_OID_802_11_HARDWARE_REGISTER		  0x0525
+#define OID_802_11_ENCRYPTION_STATUS		     OID_802_11_WEP_STATUS
+
+#define RT_OID_DEVICE_NAME				    0x0607
+#define RT_OID_VERSION_INFO				   0x0608
+#define OID_802_11_BSSID_LIST				 0x0609
+#define OID_802_3_CURRENT_ADDRESS		        0x060A
+#define OID_GEN_MEDIA_CONNECT_STATUS		     0x060B
+#define RT_OID_802_11_QUERY_LINK_STATUS		  0x060C
+#define OID_802_11_RSSI				       0x060D
+#define OID_802_11_STATISTICS				 0x060E
+#define OID_GEN_RCV_OK				        0x060F
+#define OID_GEN_RCV_NO_BUFFER				 0x0610
+#define RT_OID_802_11_QUERY_EEPROM_VERSION          0x0611
+#define RT_OID_802_11_QUERY_FIRMWARE_VERSION        0x0612
+#define RT_OID_802_11_QUERY_LAST_RX_RATE		 0x0613
+#define RT_OID_802_11_TX_POWER_LEVEL_1		   0x0614
+#define RT_OID_802_11_QUERY_PIDVID		       0x0615
+
+//#if WPA_SUPPLICANT_SUPPORT
+#define OID_SET_COUNTERMEASURES		          0x0616
+#define OID_802_11_SET_IEEE8021X		         0x0617
+#define OID_802_11_SET_IEEE8021X_REQUIRE_KEY        0x0618
+#define OID_802_11_PMKID				      0x0620
+#define RT_OID_WPA_SUPPLICANT_SUPPORT					0x0621
+#define RT_OID_WE_VERSION_COMPILED		       0x0622
+//#endif
+
+//rt2860 , kathy
+#define	RT_OID_802_11_SNR_0							0x0630
+#define	RT_OID_802_11_SNR_1							0x0631
+#define	RT_OID_802_11_QUERY_LAST_TX_RATE			0x0632
+#define	RT_OID_802_11_QUERY_HT_PHYMODE				0x0633
+#define	RT_OID_802_11_SET_HT_PHYMODE				0x0634
+#define	OID_802_11_RELOAD_DEFAULTS					0x0635
+#define	RT_OID_802_11_QUERY_APSD_SETTING			0x0636
+#define	RT_OID_802_11_SET_APSD_SETTING				0x0637
+#define	RT_OID_802_11_QUERY_APSD_PSM				0x0638
+#define	RT_OID_802_11_SET_APSD_PSM					0x0639
+#define	RT_OID_802_11_QUERY_DLS						0x063A
+#define	RT_OID_802_11_SET_DLS						0x063B
+#define	RT_OID_802_11_QUERY_DLS_PARAM				0x063C
+#define	RT_OID_802_11_SET_DLS_PARAM					0x063D
+#define RT_OID_802_11_QUERY_WMM		   		0x063E
+#define RT_OID_802_11_SET_WMM      					0x063F
+#define RT_OID_802_11_QUERY_IMME_BA_CAP				0x0640
+#define RT_OID_802_11_SET_IMME_BA_CAP				0x0641
+#define RT_OID_802_11_QUERY_BATABLE					0x0642
+#define RT_OID_802_11_ADD_IMME_BA					0x0643
+#define RT_OID_802_11_TEAR_IMME_BA					0x0644
+#define RT_OID_DRIVER_DEVICE_NAME		        0x0645
+#define RT_OID_802_11_QUERY_DAT_HT_PHYMODE          0x0646
+#define RT_OID_QUERY_MULTIPLE_CARD_SUPPORT          0x0647
+#define OID_802_11_SET_PSPXLINK_MODE				0x0648
+#define OID_802_11_SET_PASSPHRASE					0x0649
+#define RT_OID_802_11_SNR_2							0x064a
+#define RT_OID_802_11_STREAM_SNR					0x064b
+#define RT_OID_802_11_QUERY_TXBF_TABLE				0x0650
+#define RT_OID_802_11_WSC_QUERY_PROFILE				0x0750
+#define RT_OID_WSC_UUID				       0x0753
+
+
+#define RT_OID_802_11_BSSID		        (OID_GET_SET_TOGGLE | OID_802_11_BSSID)
+#define RT_OID_802_11_SSID		         (OID_GET_SET_TOGGLE | OID_802_11_SSID)
+#define RT_OID_802_11_INFRASTRUCTURE_MODE     (OID_GET_SET_TOGGLE | OID_802_11_INFRASTRUCTURE_MODE)
+#define RT_OID_802_11_ADD_WEP		      (OID_GET_SET_TOGGLE | OID_802_11_ADD_WEP)
+#define RT_OID_802_11_ADD_KEY		      (OID_GET_SET_TOGGLE | OID_802_11_ADD_KEY)
+#define RT_OID_802_11_REMOVE_WEP		   (OID_GET_SET_TOGGLE | OID_802_11_REMOVE_WEP)
+#define RT_OID_802_11_REMOVE_KEY		   (OID_GET_SET_TOGGLE | OID_802_11_REMOVE_KEY)
+#define RT_OID_802_11_DISASSOCIATE		 (OID_GET_SET_TOGGLE | OID_802_11_DISASSOCIATE)
+#define RT_OID_802_11_AUTHENTICATION_MODE     (OID_GET_SET_TOGGLE | OID_802_11_AUTHENTICATION_MODE)
+#define RT_OID_802_11_PRIVACY_FILTER          (OID_GET_SET_TOGGLE | OID_802_11_PRIVACY_FILTER)
+#define RT_OID_802_11_BSSID_LIST_SCAN         (OID_GET_SET_TOGGLE | OID_802_11_BSSID_LIST_SCAN)
+#define RT_OID_802_11_WEP_STATUS		   (OID_GET_SET_TOGGLE | OID_802_11_WEP_STATUS)
+#define RT_OID_802_11_RELOAD_DEFAULTS         (OID_GET_SET_TOGGLE | OID_802_11_RELOAD_DEFAULTS)
+#define RT_OID_802_11_NETWORK_TYPE_IN_USE     (OID_GET_SET_TOGGLE | OID_802_11_NETWORK_TYPE_IN_USE)
+#define RT_OID_802_11_TX_POWER_LEVEL          (OID_GET_SET_TOGGLE | OID_802_11_TX_POWER_LEVEL)
+#define RT_OID_802_11_RSSI_TRIGGER		 (OID_GET_SET_TOGGLE | OID_802_11_RSSI_TRIGGER)
+#define RT_OID_802_11_FRAGMENTATION_THRESHOLD (OID_GET_SET_TOGGLE | OID_802_11_FRAGMENTATION_THRESHOLD)
+#define RT_OID_802_11_RTS_THRESHOLD		(OID_GET_SET_TOGGLE | OID_802_11_RTS_THRESHOLD)
+#define RT_OID_802_11_RX_ANTENNA_SELECTED     (OID_GET_SET_TOGGLE | OID_802_11_RX_ANTENNA_SELECTED)
+#define RT_OID_802_11_TX_ANTENNA_SELECTED     (OID_GET_SET_TOGGLE | OID_802_11_TX_ANTENNA_SELECTED)
+#define RT_OID_802_11_SUPPORTED_RATES         (OID_GET_SET_TOGGLE | OID_802_11_SUPPORTED_RATES)
+#define RT_OID_802_11_DESIRED_RATES		(OID_GET_SET_TOGGLE | OID_802_11_DESIRED_RATES)
+#define RT_OID_802_11_CONFIGURATION		(OID_GET_SET_TOGGLE | OID_802_11_CONFIGURATION)
+#define RT_OID_802_11_POWER_MODE		   (OID_GET_SET_TOGGLE | OID_802_11_POWER_MODE)
+
+typedef union _MACHTTRANSMIT_SETTING {
+	struct  {
+		unsigned short	MCS:6;  // MCS
+		unsigned short	ldpc:1;
+		unsigned short	BW:2;   //channel bandwidth 20MHz or 40 MHz
+		unsigned short	ShortGI:1;
+		unsigned short	STBC:1; //SPACE
+		unsigned short	eTxBF:1;
+		unsigned short	iTxBF:1;
+		unsigned short	MODE:3; // Use definition MODE_xxx.
+	} field;
+	unsigned short	word;
+} MACHTTRANSMIT_SETTING;
+
+typedef struct _RT_802_11_MAC_ENTRY {
+	unsigned char		ApIdx;
+	unsigned char		Addr[6];
+	unsigned char		Aid;
+	unsigned char		Psm;     // 0:PWR_ACTIVE, 1:PWR_SAVE
+	unsigned char		MimoPs;  // 0:MMPS_STATIC, 1:MMPS_DYNAMIC, 3:MMPS_Enabled
+	char			AvgRssi0;
+	char			AvgRssi1;
+	char			AvgRssi2;
+	unsigned int		ConnectedTime;
+	MACHTTRANSMIT_SETTING	TxRate;
+	unsigned int		LastRxRate;
+
+	short			StreamSnr[3];
+	short			SoundingRespSnr[3];
+} RT_802_11_MAC_ENTRY;
+
+typedef struct _RT_802_11_MAC_TABLE {
+	unsigned long		Num;
+	RT_802_11_MAC_ENTRY	Entry[64]; //MAX_LEN_OF_MAC_TABLE = 64
+} RT_802_11_MAC_TABLE;
+
+#endif
--- a/include/iwinfo/lua.h
+++ b/include/iwinfo/lua.h
@@ -37,6 +37,10 @@
 #define IWINFO_MADWIFI_META	"iwinfo.madwifi"
 #endif
 
+#ifdef USE_RA
+#define IWINFO_RA_META     "iwinfo.ra"
+#endif
+
 #ifdef USE_NL80211
 #define IWINFO_NL80211_META	"iwinfo.nl80211"
 #endif
--- a/include/iwinfo.h
+++ b/include/iwinfo.h
@@ -259,6 +259,7 @@ extern const struct iwinfo_ops wext_ops;
 extern const struct iwinfo_ops madwifi_ops;
 extern const struct iwinfo_ops nl80211_ops;
 extern const struct iwinfo_ops wl_ops;
+extern const struct iwinfo_ops ra_ops;
 
 #include "iwinfo/utils.h"
 
--- a/iwinfo_lib.c
+++ b/iwinfo_lib.c
@@ -334,6 +334,9 @@ static const struct iwinfo_ops *backends
 #ifdef USE_WL
 	&wl_ops,
 #endif
+#ifdef USE_RA
+	&ra_ops,
+#endif
 	&wext_ops,
 };
 
--- a/iwinfo_lua.c
+++ b/iwinfo_lua.c
@@ -659,6 +659,35 @@ static int iwinfo_L_countrylist(lua_Stat
 	return 1;
 }
 
+#ifdef USE_RA
+/* Ralink */
+LUA_WRAP_INT_OP(ra,channel)
+LUA_WRAP_INT_OP(ra,frequency)
+LUA_WRAP_INT_OP(ra,frequency_offset)
+LUA_WRAP_INT_OP(ra,txpower)
+LUA_WRAP_INT_OP(ra,txpower_offset)
+LUA_WRAP_INT_OP(ra,bitrate)
+LUA_WRAP_INT_OP(ra,signal)
+LUA_WRAP_INT_OP(ra,noise)
+LUA_WRAP_INT_OP(ra,quality)
+LUA_WRAP_INT_OP(ra,quality_max)
+LUA_WRAP_STRING_OP(ra,ssid)
+LUA_WRAP_STRING_OP(ra,bssid)
+LUA_WRAP_STRING_OP(ra,country)
+LUA_WRAP_STRING_OP(ra,hardware_name)
+LUA_WRAP_STRING_OP(ra,phyname)
+LUA_WRAP_STRUCT_OP(ra,mode)
+LUA_WRAP_STRUCT_OP(ra,assoclist)
+LUA_WRAP_STRUCT_OP(ra,txpwrlist)
+LUA_WRAP_STRUCT_OP(ra,scanlist)
+LUA_WRAP_STRUCT_OP(ra,freqlist)
+LUA_WRAP_STRUCT_OP(ra,countrylist)
+LUA_WRAP_STRUCT_OP(ra,hwmodelist)
+LUA_WRAP_STRUCT_OP(ra,htmodelist)
+LUA_WRAP_STRUCT_OP(ra,encryption)
+LUA_WRAP_STRUCT_OP(ra,mbssid_support)
+LUA_WRAP_STRUCT_OP(ra,hardware_id)
+#endif
 
 #ifdef USE_WL
 /* Broadcom */
@@ -908,6 +937,41 @@ static const luaL_reg R_wext[] = {
 	{ NULL, NULL }
 };
 
+#ifdef USE_RA
+/* Ralink table */
+static const luaL_reg R_ra[] = {
+   LUA_REG(ra,channel),
+   LUA_REG(ra,frequency),
+   LUA_REG(ra,frequency_offset),
+   LUA_REG(ra,txpower),
+   LUA_REG(ra,txpower_offset),
+   LUA_REG(ra,bitrate),
+   LUA_REG(ra,signal),
+   LUA_REG(ra,noise),
+   LUA_REG(ra,quality),
+   LUA_REG(ra,quality_max),
+   LUA_REG(ra,mode),
+   LUA_REG(ra,ssid),
+   LUA_REG(ra,bssid),
+   LUA_REG(ra,country),
+   LUA_REG(ra,assoclist),
+   LUA_REG(ra,txpwrlist),
+   LUA_REG(ra,scanlist),
+   LUA_REG(ra,freqlist),
+   LUA_REG(ra,countrylist),
+   LUA_REG(ra,hwmodelist),
+   LUA_REG(ra,htmodelist),
+   LUA_REG(ra,encryption),
+   LUA_REG(ra,mbssid_support),
+   LUA_REG(ra,hardware_id),
+   LUA_REG(ra,hardware_name),
+   LUA_REG(ra,phyname),
+   { NULL, NULL }
+};
+
+#endif
+
+
 /* Common */
 static const luaL_reg R_common[] = {
 	{ "type", iwinfo_L_type },
@@ -919,6 +983,15 @@ static const luaL_reg R_common[] = {
 LUALIB_API int luaopen_iwinfo(lua_State *L) {
 	luaL_register(L, IWINFO_META, R_common);
 
+
+#ifdef USE_RA
+   luaL_newmetatable(L, IWINFO_RA_META);
+   luaL_register(L, NULL, R_ra);
+   lua_pushvalue(L, -1);
+   lua_setfield(L, -2, "__index");
+   lua_setfield(L, -2, "ra");
+#endif
+
 #ifdef USE_WL
 	luaL_newmetatable(L, IWINFO_WL_META);
 	luaL_register(L, NULL, R_common);
--- /dev/null
+++ b/iwinfo_ra.c
@@ -0,0 +1,1000 @@
+#include "iwinfo.h"
+#include "iwinfo_ra.h"
+#include "iwinfo_wext.h"
+
+#define MIDFIX5G "x"
+
+/*
+ * Ralink ISO 3166 to Country/Region Code mapping.
+ */
+
+static struct ISO3166_to_CCode
+{
+	u_int16_t iso3166;
+	u_int16_t ccode;
+} CountryCodes[] =
+    {
+	{0x3030 /* 00 */, 0},	/* World */
+	{0x4145 /* AE */, 784}, /* U.A.E. */
+	{0x414C /* AL */, 8},	/* Albania */
+	{0x414D /* AM */, 51},	/* Armenia */
+	{0x4152 /* AR */, 32},	/* Argentina */
+	{0x4154 /* AT */, 40},	/* Austria */
+	{0x4155 /* AU */, 36},	/* Australia */
+	{0x415A /* AZ */, 31},	/* Azerbaijan */
+	{0x4245 /* BE */, 56},	/* Belgium */
+	{0x4247 /* BG */, 100}, /* Bulgaria */
+	{0x4248 /* BH */, 48},	/* Bahrain */
+	{0x424E /* BN */, 96},	/* Brunei Darussalam */
+	{0x424F /* BO */, 68},	/* Bolivia */
+	{0x4252 /* BR */, 76},	/* Brazil */
+	{0x4259 /* BY */, 112}, /* Belarus */
+	{0x425A /* BZ */, 84},	/* Belize */
+	{0x4341 /* CA */, 124}, /* Canada */
+	{0x4348 /* CH */, 756}, /* Switzerland */
+	{0x434C /* CL */, 152}, /* Chile */
+	{0x434E /* CN */, 156}, /* People's Republic of China */
+	{0x434F /* CO */, 170}, /* Colombia */
+	{0x4352 /* CR */, 188}, /* Costa Rica */
+	{0x4359 /* CY */, 196}, /* Cyprus */
+	{0x435A /* CZ */, 203}, /* Czech Republic */
+	{0x4445 /* DE */, 276}, /* Germany */
+	{0x444B /* DK */, 208}, /* Denmark */
+	{0x444F /* DO */, 214}, /* Dominican Republic */
+	{0x445A /* DZ */, 12},	/* Algeria */
+	{0x4543 /* EC */, 218}, /* Ecuador */
+	{0x4545 /* EE */, 233}, /* Estonia */
+	{0x4547 /* EG */, 818}, /* Egypt */
+	{0x4553 /* ES */, 724}, /* Spain */
+	{0x4649 /* FI */, 246}, /* Finland */
+	{0x464F /* FO */, 234}, /* Faeroe Islands */
+	{0x4652 /* FR */, 250}, /* France */
+	{0x4652 /* FR */, 255}, /* France2 */
+	{0x4742 /* GB */, 826}, /* United Kingdom */
+	{0x4745 /* GE */, 268}, /* Georgia */
+	{0x4752 /* GR */, 300}, /* Greece */
+	{0x4754 /* GT */, 320}, /* Guatemala */
+	{0x484B /* HK */, 344}, /* Hong Kong S.A.R., P.R.C. */
+	{0x484E /* HN */, 340}, /* Honduras */
+	{0x4852 /* HR */, 191}, /* Croatia */
+	{0x4855 /* HU */, 348}, /* Hungary */
+	{0x4944 /* ID */, 360}, /* Indonesia */
+	{0x4945 /* IE */, 372}, /* Ireland */
+	{0x494C /* IL */, 376}, /* Israel */
+	{0x494E /* IN */, 356}, /* India */
+	{0x4951 /* IQ */, 368}, /* Iraq */
+	{0x4952 /* IR */, 364}, /* Iran */
+	{0x4953 /* IS */, 352}, /* Iceland */
+	{0x4954 /* IT */, 380}, /* Italy */
+	{0x4A4D /* JM */, 388}, /* Jamaica */
+	{0x4A4F /* JO */, 400}, /* Jordan */
+	{0x4A50 /* JP */, 392}, /* Japan */
+	{0x4A50 /* JP */, 393}, /* Japan (JP1) */
+	{0x4A50 /* JP */, 394}, /* Japan (JP0) */
+	{0x4A50 /* JP */, 395}, /* Japan (JP1-1) */
+	{0x4A50 /* JP */, 396}, /* Japan (JE1) */
+	{0x4A50 /* JP */, 397}, /* Japan (JE2) */
+	{0x4A50 /* JP */, 399}, /* Japan (JP6) */
+	{0x4A50 /* JP */, 900}, /* Japan */
+	{0x4A50 /* JP */, 901}, /* Japan */
+	{0x4A50 /* JP */, 902}, /* Japan */
+	{0x4A50 /* JP */, 903}, /* Japan */
+	{0x4A50 /* JP */, 904}, /* Japan */
+	{0x4A50 /* JP */, 905}, /* Japan */
+	{0x4A50 /* JP */, 906}, /* Japan */
+	{0x4A50 /* JP */, 907}, /* Japan */
+	{0x4A50 /* JP */, 908}, /* Japan */
+	{0x4A50 /* JP */, 909}, /* Japan */
+	{0x4A50 /* JP */, 910}, /* Japan */
+	{0x4A50 /* JP */, 911}, /* Japan */
+	{0x4A50 /* JP */, 912}, /* Japan */
+	{0x4A50 /* JP */, 913}, /* Japan */
+	{0x4A50 /* JP */, 914}, /* Japan */
+	{0x4A50 /* JP */, 915}, /* Japan */
+	{0x4A50 /* JP */, 916}, /* Japan */
+	{0x4A50 /* JP */, 917}, /* Japan */
+	{0x4A50 /* JP */, 918}, /* Japan */
+	{0x4A50 /* JP */, 919}, /* Japan */
+	{0x4A50 /* JP */, 920}, /* Japan */
+	{0x4A50 /* JP */, 921}, /* Japan */
+	{0x4A50 /* JP */, 922}, /* Japan */
+	{0x4A50 /* JP */, 923}, /* Japan */
+	{0x4A50 /* JP */, 924}, /* Japan */
+	{0x4A50 /* JP */, 925}, /* Japan */
+	{0x4A50 /* JP */, 926}, /* Japan */
+	{0x4A50 /* JP */, 927}, /* Japan */
+	{0x4A50 /* JP */, 928}, /* Japan */
+	{0x4A50 /* JP */, 929}, /* Japan */
+	{0x4A50 /* JP */, 930}, /* Japan */
+	{0x4A50 /* JP */, 931}, /* Japan */
+	{0x4A50 /* JP */, 932}, /* Japan */
+	{0x4A50 /* JP */, 933}, /* Japan */
+	{0x4A50 /* JP */, 934}, /* Japan */
+	{0x4A50 /* JP */, 935}, /* Japan */
+	{0x4A50 /* JP */, 936}, /* Japan */
+	{0x4A50 /* JP */, 937}, /* Japan */
+	{0x4A50 /* JP */, 938}, /* Japan */
+	{0x4A50 /* JP */, 939}, /* Japan */
+	{0x4A50 /* JP */, 940}, /* Japan */
+	{0x4A50 /* JP */, 941}, /* Japan */
+	{0x4B45 /* KE */, 404}, /* Kenya */
+	{0x4B50 /* KP */, 408}, /* North Korea */
+	{0x4B52 /* KR */, 410}, /* South Korea */
+	{0x4B52 /* KR */, 411}, /* South Korea */
+	{0x4B57 /* KW */, 414}, /* Kuwait */
+	{0x4B5A /* KZ */, 398}, /* Kazakhstan */
+	{0x4C42 /* LB */, 422}, /* Lebanon */
+	{0x4C49 /* LI */, 438}, /* Liechtenstein */
+	{0x4C54 /* LT */, 440}, /* Lithuania */
+	{0x4C55 /* LU */, 442}, /* Luxembourg */
+	{0x4C56 /* LV */, 428}, /* Latvia */
+	{0x4C59 /* LY */, 434}, /* Libya */
+	{0x4D41 /* MA */, 504}, /* Morocco */
+	{0x4D43 /* MC */, 492}, /* Principality of Monaco */
+	{0x4D4B /* MK */, 807}, /* the Former Yugoslav Republic of Macedonia */
+	{0x4D4F /* MO */, 446}, /* Macau */
+	{0x4D58 /* MX */, 484}, /* Mexico */
+	{0x4D59 /* MY */, 458}, /* Malaysia */
+	{0x4E49 /* NI */, 558}, /* Nicaragua */
+	{0x4E4C /* NL */, 528}, /* Netherlands */
+	{0x4E4F /* NO */, 578}, /* Norway */
+	{0x4E5A /* NZ */, 554}, /* New Zealand */
+	{0x4F4D /* OM */, 512}, /* Oman */
+	{0x5041 /* PA */, 591}, /* Panama */
+	{0x5045 /* PE */, 604}, /* Peru */
+	{0x5048 /* PH */, 608}, /* Republic of the Philippines */
+	{0x504B /* PK */, 586}, /* Islamic Republic of Pakistan */
+	{0x504C /* PL */, 616}, /* Poland */
+	{0x5052 /* PR */, 630}, /* Puerto Rico */
+	{0x5054 /* PT */, 620}, /* Portugal */
+	{0x5059 /* PY */, 600}, /* Paraguay */
+	{0x5141 /* QA */, 634}, /* Qatar */
+	{0x524F /* RO */, 642}, /* Romania */
+	{0x5255 /* RU */, 643}, /* Russia */
+	{0x5341 /* SA */, 682}, /* Saudi Arabia */
+	{0x5345 /* SE */, 752}, /* Sweden */
+	{0x5347 /* SG */, 702}, /* Singapore */
+	{0x5349 /* SI */, 705}, /* Slovenia */
+	{0x534B /* SK */, 703}, /* Slovak Republic */
+	{0x5356 /* SV */, 222}, /* El Salvador */
+	{0x5359 /* SY */, 760}, /* Syria */
+	{0x5448 /* TH */, 764}, /* Thailand */
+	{0x544E /* TN */, 788}, /* Tunisia */
+	{0x5452 /* TR */, 792}, /* Turkey */
+	{0x5454 /* TT */, 780}, /* Trinidad y Tobago */
+	{0x5457 /* TW */, 158}, /* Taiwan */
+	{0x5541 /* UA */, 804}, /* Ukraine */
+	{0x554B /* UK */, 826}, /* United Kingdom */
+	{0x5553 /* US */, 840}, /* United States */
+	{0x5553 /* US */, 842}, /* United States (Public Safety)*/
+	{0x5559 /* UY */, 858}, /* Uruguay */
+	{0x555A /* UZ */, 860}, /* Uzbekistan */
+	{0x5645 /* VE */, 862}, /* Venezuela */
+	{0x564E /* VN */, 704}, /* Viet Nam */
+	{0x5945 /* YE */, 887}, /* Yemen */
+	{0x5A41 /* ZA */, 710}, /* South Africa */
+	{0x5A57 /* ZW */, 716}, /* Zimbabwe */
+};
+
+int is_5g(const char *ifname)
+{
+	if (!strncmp(ifname, "ra"MIDFIX5G, 3))
+		return 1;
+	else if (!strncmp(ifname, "wds"MIDFIX5G, 4))
+		return 1;
+	else if (!strncmp(ifname, "apcli"MIDFIX5G, 6))
+		return 1;
+
+	return 0;
+}
+
+static int ra_ioctl(const char *ifname, int cmd, struct iwreq *wrq)
+{
+	if (!strncmp(ifname, "mon.", 4))
+		strncpy(wrq->ifr_name, &ifname[4], IFNAMSIZ);
+	else
+		strncpy(wrq->ifr_name, ifname, IFNAMSIZ);
+
+	return iwinfo_ioctl(cmd, wrq);
+}
+
+int ra_oid_ioctl(const char *ifname, unsigned long oid, char *ptr, unsigned long ptr_len)
+{
+	struct iwreq wrq;
+	int cmd = RT_PRIV_IOCTL;
+	strcpy(wrq.ifr_name, ifname);
+	wrq.u.data.length = ptr_len;
+	wrq.u.data.pointer = ptr;
+	wrq.u.data.flags = oid;
+
+	return iwinfo_ioctl(RT_PRIV_IOCTL, &wrq);
+}
+
+int iwpriv_set(const char *name, const char *key, const char *val)
+{
+	int socket_id, ret = 0;
+	struct iwreq wrq;
+	char data[64];
+	snprintf(data, 64, "%s=%s", key, val);
+	socket_id = socket(AF_INET, SOCK_DGRAM, 0);
+
+	wrq.u.data.length = strlen(data);
+	wrq.u.data.pointer = data;
+	wrq.u.data.flags = 0;
+	ret = ra_ioctl(name, RTPRIV_IOCTL_SET, &wrq);
+	close(socket_id);
+	return ret;
+}
+
+int ra_probe(const char *ifname)
+{
+	unsigned char data[12];
+	int version;
+	if (strncmp(ifname, "ra", 2) && strncmp(ifname, "wds", 3) && strncmp(ifname, "apcli", 5))
+		return 0;
+	if (ra_oid_ioctl(ifname, RT_OID_VERSION_INFO, data, sizeof(data)) == 0)
+	{
+		data[1] = data[2];
+		data[2] = data[4];
+		data[3] = data[6];
+		data[4] = '\0';
+		version = atoi(data);
+		if (version >= 2500)
+			return 1;
+		else
+			return 0;
+	}
+	else
+		return -1;
+}
+
+void ra_close(void)
+{
+	iwinfo_close();
+}
+
+int ra_get_mode(const char *ifname, int *buf)
+{
+	if (strncmp(ifname, "ra", 2) == 0)
+		*buf = IWINFO_OPMODE_MASTER;
+	else if (strncmp(ifname, "apcli", 5) == 0)
+		*buf = IWINFO_OPMODE_CLIENT;
+	else if (strncmp(ifname, "wds", 3) == 0)
+		*buf = IWINFO_OPMODE_WDS;
+	else
+		*buf = IWINFO_OPMODE_UNKNOWN;
+
+	return 0;
+}
+
+int ra_get_ssid(const char *ifname, char *buf)
+{
+	struct iwreq wrq;
+
+	wrq.u.essid.pointer = (caddr_t)buf;
+	wrq.u.essid.length = IW_ESSID_MAX_SIZE + 1;
+	wrq.u.essid.flags = 0;
+
+	if (ra_ioctl(ifname, SIOCGIWESSID, &wrq) >= 0)
+		return 0;
+
+	return -1;
+}
+
+int ra_get_bssid(const char *ifname, char *buf)
+{
+	struct iwreq wrq;
+
+	if (ra_ioctl(ifname, SIOCGIWAP, &wrq) >= 0)
+	{
+		sprintf(buf, "%02X:%02X:%02X:%02X:%02X:%02X",
+			(uint8_t)wrq.u.ap_addr.sa_data[0], (uint8_t)wrq.u.ap_addr.sa_data[1],
+			(uint8_t)wrq.u.ap_addr.sa_data[2], (uint8_t)wrq.u.ap_addr.sa_data[3],
+			(uint8_t)wrq.u.ap_addr.sa_data[4], (uint8_t)wrq.u.ap_addr.sa_data[5]);
+
+		return 0;
+	}
+
+	return -1;
+}
+
+static int32_t ra_freq2mhz(const struct iw_freq *in)
+{
+	int i;
+	int32_t res = in->m;
+	if (in->e == 6) {
+		return res;
+	} else if (in->e > 6) {
+		for (i=in->e; i>6; --i) {
+			res *= 10;
+		}
+	} else {
+		for (i=in->e; i<6; ++i) {
+			res /= 10;
+		}
+	}
+	return res;
+}
+
+int ra_get_channel(const char *ifname, int *buf)
+{
+	struct iwreq wrq;
+
+	if (ra_ioctl(ifname, SIOCGIWFREQ, &wrq) >= 0)
+	{
+		*buf = wrq.u.freq.i;
+		return 0;
+	}
+
+	return -1;
+}
+
+int ra_get_frequency(const char *ifname, int *buf)
+{
+	struct iwreq wrq;
+
+	if (ra_ioctl(ifname, SIOCGIWFREQ, &wrq) >= 0)
+	{
+		*buf = ra_freq2mhz(&wrq.u.freq);
+		return 0;
+	}
+	return -1;
+}
+
+int ra_get_txpower(const char *ifname, int *buf)
+{
+	*buf = 20;
+	return 0;
+}
+
+int ra_get_bitrate(const char *ifname, int *buf)
+{
+	struct iwreq wrq;
+
+	if (ra_ioctl(ifname, SIOCGIWRATE, &wrq) >= 0)
+	{
+		*buf = (wrq.u.bitrate.value / 1000);
+		return 0;
+	}
+
+	return -1;
+}
+
+int ra_get_signal(const char *ifname, int *buf)
+{
+	int ra_snr_sum, num;
+	char tmp_buf[8192];
+	struct iwinfo_assoclist_entry tmp;
+	int ret_len, i;
+
+	if (ra_get_assoclist(ifname, tmp_buf, &ret_len) == 0)
+	{
+		num = ret_len / sizeof(struct iwinfo_assoclist_entry);
+		ra_snr_sum = 0;
+		for (i = 0; i < num; i++)
+		{
+			memset(&tmp, 0, sizeof(struct iwinfo_assoclist_entry));
+			memcpy(&tmp, tmp_buf + i * sizeof(struct iwinfo_assoclist_entry), sizeof(struct iwinfo_assoclist_entry));
+
+			ra_snr_sum -= tmp.signal;
+		}
+		if (num > 0)
+			*buf = -(ra_snr_sum / num);
+		else
+			*buf = -95;
+
+		return 0;
+	}
+	else
+		return -1;
+}
+
+int ra_get_noise(const char *ifname, int *buf)
+{
+	*buf = -95;
+	return 0;
+}
+
+int ra_get_quality(const char *ifname, int *buf)
+{
+	int tmp;
+
+	if (ra_get_signal(ifname, &tmp) == 0)
+		*buf = 100 - (tmp / -95 * 100);
+	else
+		*buf = 100;
+
+	return 0;
+}
+
+int ra_get_quality_max(const char *ifname, int *buf)
+{
+	*buf = 100;
+	return 0;
+}
+
+static char *ra_array_get(char *p, int idx) {
+	int i;
+	char *tail;
+	for (i=0; i<idx; ++i) {
+		p = strchr(p, ';');
+		if (p == NULL) {
+			return NULL;
+		}
+		p += 1;
+	}
+	tail = strchr(p, ';');
+	if (!tail) {
+		tail = strchr(p, '\n');
+	}
+	if (!tail) {
+		*tail = '\0';
+	}
+	return p;
+}
+
+int ra_get_encryption(const char *ifname, char *buf)
+{
+	FILE *fp;
+	const char *filename;
+	long filesize;
+	int ret = -1;
+	char buffer[256] = {0};
+	char *p = NULL;
+	int idx;
+	int aes = 0;
+
+	struct iwinfo_crypto_entry *enc = (struct iwinfo_crypto_entry *)buf;
+
+	char data[10];
+	if (ra_oid_ioctl(ifname, RT_OID_VERSION_INFO, data, sizeof(data)) < 0)
+		return -1;
+
+	if (is_5g(ifname)) {
+		filename = "/tmp/profiles/mt_dbdc_5g.dat";
+	} else {
+		filename = "/tmp/profiles/mt_dbdc_2g.dat";
+	}
+	fp = fopen(filename, "r");
+	if (fp == NULL)
+	{
+		fprintf(stderr, "open ifname:%s failed.\n", ifname);
+		return -1;
+	}
+	idx = ifname[strlen(ifname)-1] - '0';
+	while (fgets(buffer, sizeof(buffer), fp) != NULL) {
+		if (!strncmp(buffer, "AuthMode=", 9)) {
+			p = buffer + 9;
+			p = ra_array_get(p, idx);
+			if (!p)
+				goto end;
+			if (strstr(p, "WPA"))
+			{
+				enc->enabled = 1;
+				if (strstr(p, "WPA1PSKWPA2PSK"))
+					enc->wpa_version = 3;
+				else if (strstr(p, "WPA2PSK"))
+					enc->wpa_version = 2;
+				else if (strstr(p, "WPAPSK"))
+					enc->wpa_version = 1;
+				else
+					enc->wpa_version = 1;
+
+				enc->auth_suites |= IWINFO_KMGMT_PSK;
+			}
+			else if (strstr(p, "WEP"))
+			{
+				enc->enabled = 1;
+				enc->auth_algs |= IWINFO_AUTH_OPEN;
+				enc->pair_ciphers |= IWINFO_CIPHER_WEP104;
+				enc->auth_suites |= IWINFO_KMGMT_NONE;
+				enc->group_ciphers = enc->pair_ciphers;
+			}
+		} else if (!strncmp(buffer, "EncrypType=", 11)) {
+			if (enc->pair_ciphers & IWINFO_CIPHER_WEP104)
+				continue;
+			p = buffer + 11;
+			p = ra_array_get(p, idx);
+			if (!p)
+				goto end;
+			if (strstr(p, "AES"))
+				aes = 1;
+		}
+	}
+
+	if (enc->enabled && enc->auth_suites & IWINFO_KMGMT_PSK) {
+		if (aes)
+			enc->pair_ciphers |= IWINFO_CIPHER_CCMP;
+		else
+			enc->pair_ciphers |= IWINFO_CIPHER_TKIP;
+
+		enc->group_ciphers = enc->pair_ciphers;
+	}
+
+	ret = 0;
+end:
+	fclose(fp);
+	return ret;
+}
+
+int ra_get_phyname(const char *ifname, char *buf) {
+	if (is_5g(ifname)) {
+		strcpy(buf, "ra"MIDFIX5G);
+	} else {
+		strcpy(buf, "ra");
+	}
+	return 0;
+}
+
+int getRate(MACHTTRANSMIT_SETTING HTSetting)
+{
+	int MCSMappingRateTable[] =
+	    {
+		2, 4, 11, 22,								    /* CCK*/
+		12, 18, 24, 36, 48, 72, 96, 108,					    /* OFDM*/
+		13, 26, 39, 52, 78, 104, 117, 130, 26, 52, 78, 104, 156, 208, 234, 260,	    /* 20MHz, 800ns GI, MCS: 0 ~ 15*/
+		39, 78, 117, 156, 234, 312, 351, 390,					    /* 20MHz, 800ns GI, MCS: 16 ~ 23*/
+		27, 54, 81, 108, 162, 216, 243, 270, 54, 108, 162, 216, 324, 432, 486, 540, /* 40MHz, 800ns GI, MCS: 0 ~ 15*/
+		81, 162, 243, 324, 486, 648, 729, 810,					    /* 40MHz, 800ns GI, MCS: 16 ~ 23*/
+		14, 29, 43, 57, 87, 115, 130, 144, 29, 59, 87, 115, 173, 230, 260, 288,	    /* 20MHz, 400ns GI, MCS: 0 ~ 15*/
+		43, 87, 130, 173, 260, 317, 390, 433,					    /* 20MHz, 400ns GI, MCS: 16 ~ 23*/
+		30, 60, 90, 120, 180, 240, 270, 300, 60, 120, 180, 240, 360, 480, 540, 600, /* 40MHz, 400ns GI, MCS: 0 ~ 15*/
+		90, 180, 270, 360, 540, 720, 810, 900,
+		13, 26, 39, 52, 78, 104, 117, 130, 156,		 /* 11ac: 20Mhz, 800ns GI, MCS: 0~8 */
+		27, 54, 81, 108, 162, 216, 243, 270, 324, 360,	 /*11ac: 40Mhz, 800ns GI, MCS: 0~9 */
+		59, 117, 176, 234, 351, 468, 527, 585, 702, 780, /*11ac: 80Mhz, 800ns GI, MCS: 0~9 */
+		14, 29, 43, 57, 87, 115, 130, 144, 173,		 /* 11ac: 20Mhz, 400ns GI, MCS: 0~8 */
+		30, 60, 90, 120, 180, 240, 270, 300, 360, 400,	 /*11ac: 40Mhz, 400ns GI, MCS: 0~9 */
+		65, 130, 195, 260, 390, 520, 585, 650, 780, 867	 /*11ac: 80Mhz, 400ns GI, MCS: 0~9 */
+	    };
+
+	int rate_count = sizeof(MCSMappingRateTable) / sizeof(int);
+	int rate_index = 0;
+	int value = 0;
+
+	if (HTSetting.field.MODE >= 4)
+	{
+		if (HTSetting.field.BW == 0)
+		{
+			rate_index = 108 +
+				     ((unsigned char)HTSetting.field.ShortGI * 29) +
+				     ((unsigned char)HTSetting.field.MCS);
+		}
+		else if (HTSetting.field.BW == 1)
+		{
+			rate_index = 117 +
+				     ((unsigned char)HTSetting.field.ShortGI * 29) +
+				     ((unsigned char)HTSetting.field.MCS);
+		}
+		else if (HTSetting.field.BW == 2)
+		{
+			rate_index = 127 +
+				     ((unsigned char)HTSetting.field.ShortGI * 29) +
+				     ((unsigned char)HTSetting.field.MCS);
+		}
+	}
+	else if (HTSetting.field.MODE >= 2)
+	{
+		/*    	rate_index = 12 + ((UCHAR)ht_setting.field.BW *16) + ((UCHAR)ht_setting.field.ShortGI *32) + ((UCHAR)ht_setting.field.MCS);*/
+		rate_index = 12 + ((unsigned char)HTSetting.field.BW * 24) + ((unsigned char)HTSetting.field.ShortGI * 48) + ((unsigned char)HTSetting.field.MCS);
+	}
+	else if (HTSetting.field.MODE == 1)
+		rate_index = (unsigned char)(HTSetting.field.MCS) + 4;
+	else if (HTSetting.field.MODE == 0)
+		rate_index = (unsigned char)(HTSetting.field.MCS);
+
+	if (rate_index < 0)
+		rate_index = 0;
+
+	if (rate_index >= rate_count)
+		rate_index = rate_count - 1;
+
+	return (MCSMappingRateTable[rate_index] * 5 * 100);
+}
+
+int ra_get_assoclist(const char *ifname, char *buf, int *len)
+{
+	int ret, i;
+	int bl = 0, tl, noise;
+	struct iwreq wrq;
+	struct iwinfo_assoclist_entry entry;
+
+	if (!strncmp(ifname, "apcli", 5))
+		return -1;
+
+	char table[8192];
+
+	strcpy(wrq.ifr_ifrn.ifrn_name, ifname);
+	wrq.u.data.pointer = (caddr_t)&table;
+	wrq.u.data.flags = 0;
+
+	ret = ra_ioctl(ifname, RTPRIV_IOCTL_GET_MAC_TABLE_STRUCT, &wrq);
+	if (ret < 0)
+	{
+		fprintf(stderr, "assoclist ioctl fails\n");
+		return -1;
+	}
+
+	RT_802_11_MAC_TABLE *a = &table;
+
+	*len = a->Num * sizeof(struct iwinfo_assoclist_entry);
+
+	for (i = 0; i < a->Num; i++)
+	{
+		RT_802_11_MAC_ENTRY *pe = &(a->Entry[i]);
+		memset(&entry, 0, sizeof(entry));
+
+		entry.signal = ((int)(pe->AvgRssi0) + (int)(pe->AvgRssi1)) / 2;
+
+		entry.noise = -95;
+		entry.inactive = pe->ConnectedTime * 1000;
+
+		memcpy(&entry.mac, &pe->Addr, sizeof(entry.mac));
+
+		entry.tx_packets = 0;
+		entry.rx_packets = 0;
+
+		entry.tx_rate.rate = getRate(pe->TxRate);
+		entry.tx_rate.mcs = pe->TxRate.field.MCS;
+		entry.tx_rate.is_40mhz = pe->TxRate.field.BW;
+		entry.tx_rate.is_short_gi = pe->TxRate.field.ShortGI;
+
+		entry.rx_rate = entry.tx_rate;
+
+		memcpy(&buf[bl], &entry, sizeof(struct iwinfo_assoclist_entry));
+
+		bl += sizeof(struct iwinfo_assoclist_entry);
+
+		*len = bl;
+	}
+	return 0;
+}
+
+int ra_get_txpwrlist(const char *ifname, char *buf, int *len)
+{
+	struct iwinfo_txpwrlist_entry entry;
+	uint8_t dbm[9] = {0, 6, 8, 10, 12, 14, 16, 18, 20};
+	uint8_t mw[9] = {1, 3, 6, 10, 15, 25, 39, 63, 100};
+	int i;
+
+	for (i = 0; i < 9; i++)
+	{
+		entry.dbm = dbm[i];
+		entry.mw = mw[i];
+		memcpy(&buf[i * sizeof(entry)], &entry, sizeof(entry));
+	}
+
+	*len = 9 * sizeof(entry);
+	return 0;
+}
+
+static void bssid2mac(char *macStr, unsigned char *mac)
+{
+	unsigned int iMac[6];
+	int i;
+	sscanf(macStr, "%x:%x:%x:%x:%x:%x", &iMac[0], &iMac[1], &iMac[2], &iMac[3], &iMac[4], &iMac[5]);
+	for (i = 0; i < 6; i++)
+		mac[i] = (unsigned char)iMac[i];
+}
+
+static void parse_security(char *sec, struct iwinfo_crypto_entry *enc)
+{
+	memset(enc, 0, sizeof(struct iwinfo_crypto_entry));
+	enc->enabled = 0;
+	if (strstr(sec, "WPA"))
+	{
+		enc->enabled = 1;
+		if (strstr(sec, "WPAPSKWPA2PSK"))
+			enc->wpa_version = 3;
+		else if (strstr(sec, "WPA2PSK"))
+			enc->wpa_version = 2;
+		else if (strstr(sec, "WPAPSK"))
+			enc->wpa_version = 1;
+		else if (strstr(sec, "WPA"))
+			enc->wpa_version = 1;
+
+		enc->auth_suites |= IWINFO_KMGMT_PSK;
+
+		if (strstr(sec, "AES"))
+			enc->pair_ciphers |= IWINFO_CIPHER_CCMP;
+		if (strstr(sec, "TKIP"))
+			enc->pair_ciphers |= IWINFO_CIPHER_TKIP;
+
+		enc->group_ciphers = enc->pair_ciphers;
+	}
+	else if (strstr(sec, "WEP"))
+	{
+		enc->enabled = 1;
+		enc->auth_algs |= IWINFO_AUTH_OPEN;
+		enc->pair_ciphers |= IWINFO_CIPHER_WEP104;
+		enc->auth_suites |= IWINFO_KMGMT_NONE;
+		enc->group_ciphers = enc->pair_ciphers;
+	}
+}
+
+int rtrim(char *s)
+{
+	int i;
+
+	i = strlen(s) - 1;
+	while ((s[i] == ' ' || s[i] == '\t') && i >= 0)
+	{
+		i--;
+	};
+	s[i + 1] = '\0';
+	return i + 1;
+}
+
+static void fill_find_entry(char *sp, struct iwinfo_scanlist_entry *e)
+{
+	char site_channel[4];
+	char site_ssid[33];
+	char site_bssid[20];
+	char site_security[23];
+	char site_signal[9];
+	char site_wirelessmode[7];
+	char ssid_str[128];
+	int len;
+
+	sp += 4; // skip No
+	memcpy(site_channel, sp, 4);
+	memcpy(site_ssid, sp + 4, 33);
+	memcpy(site_bssid, sp + 37, 20);
+	memcpy(site_security, sp + 57, 23);
+	memcpy(site_signal, sp + 80, 9);
+
+	rtrim(site_bssid);
+	rtrim(site_channel);
+	rtrim(site_security);
+	rtrim(site_signal);
+
+	e->channel = atoi(site_channel);
+	bssid2mac((unsigned char *)site_bssid, (unsigned char *)e->mac);
+	e->mode = IWINFO_OPMODE_MASTER;
+	//e->crypto.enable = 0;
+	parse_security((char *)site_security, &e->crypto);
+
+	int quality = atoi(site_signal);
+	int8_t rssi;
+	rssi = (quality * 95 / 100) - 95;
+
+	if (quality < 5)
+	{
+		rssi = -95;
+	}
+
+	e->signal = rssi;
+	e->quality = quality;
+	e->quality_max = 100;
+
+	len = rtrim(site_ssid);
+	if (!strlen(site_ssid))
+	{
+		strcpy(site_ssid, "???");
+		len = 3;
+	}
+	memcpy(e->ssid, site_ssid, len);
+}
+
+static char *next_line(char *sp) {
+	while (*sp != '\n' && *sp != '\0')
+		++sp;
+	if (*sp == '\n')
+		++sp; // skip \n
+	return sp;
+}
+
+int ra_get_scanlist(const char *ifname, char *buf, int *len)
+{
+	struct iwreq wrq;
+	char data[8192];
+	char *sp, *empty, *end;
+
+	int line_len, i;
+
+	int is5g = is_5g(ifname);
+
+	iwpriv_set(ifname, "SiteSurvey", "1");
+	sleep(3);
+
+	memset(data, 0, sizeof(data));
+	wrq.u.data.length = sizeof(data);
+	wrq.u.data.pointer = data;
+	wrq.u.data.flags = 0;
+
+	if (ra_ioctl(ifname, RTPRIV_IOCTL_GSITESURVEY, &wrq) >= 0)
+	{
+		struct iwinfo_scanlist_entry e;
+		// No  Ch  SSID                             BSSID               Security               Siganl(%)W-Mode  ExtCH  NT SSID_Len WPS DPID BcnRept
+		line_len = 4 + 4 + 33 + 20 + 23 + 9 + 8 + 7 + 3 + 9; // WPS DPID may not present
+		if (wrq.u.data.length < line_len + 3 + 10)
+			return -1;
+		sp = wrq.u.data.pointer;
+		for (i = 0; i < 3; ++i) {
+			// skip \n+'Total=xxxx'+\n+HEADER+\n
+			sp = next_line(sp);
+		}
+		end = sp + strlen(sp);
+		i = 0;
+		while (*sp >= '0' && end > sp)
+		{
+			memset(&e, 0, sizeof(struct iwinfo_scanlist_entry));
+
+			fill_find_entry(sp, &e);
+			if ((e.channel < 34) ^ is5g) {
+				memcpy(&buf[i * sizeof(struct iwinfo_scanlist_entry)], &e, sizeof(struct iwinfo_scanlist_entry));
+				i++;
+			}
+			sp += line_len;
+			sp = next_line(sp);
+		}
+		*len = i * sizeof(struct iwinfo_scanlist_entry);
+		return 0;
+	}
+	return -1;
+}
+
+#define RA_MAX_CH_2G 13
+static const uint8_t CH5G[]={
+	/* 802.11 UNI / HyperLan 2 */
+	36, 40, 44, 48, 52, 56, 60, 64, //8
+
+	/* 802.11 HyperLan 2 */
+	100, 104, 108, 112, 116, 120, 124, 128, 132, 136, //10
+
+	/* 802.11 UNII */
+	140, 144, 149, 153, 157, 161, 165
+};
+
+int ra_get_freqlist(const char *ifname, char *buf, int *len)
+{
+
+	struct iwinfo_freqlist_entry entry;
+	int i, bl;
+	bl = 0;
+
+	if (is_5g(ifname)) {
+		for (i=0; i<ARRAY_SIZE(CH5G); ++i) {
+			entry.mhz = 5000 + 5 * CH5G[i];
+			entry.channel =  CH5G[i];
+			entry.restricted = 0;
+
+			memcpy(&buf[bl], &entry, sizeof(struct iwinfo_freqlist_entry));
+			bl += sizeof(struct iwinfo_freqlist_entry);
+		}
+	} else {
+		for (i = 0; i < RA_MAX_CH_2G; i++)
+		{
+			entry.mhz = 2412 + 5 * i;
+			entry.channel = i + 1;
+			entry.restricted = 0;
+
+			memcpy(&buf[bl], &entry, sizeof(struct iwinfo_freqlist_entry));
+			bl += sizeof(struct iwinfo_freqlist_entry);
+		}
+	}
+
+	*len = bl;
+	return 0;
+}
+
+int ra_get_country(const char *ifname, char *buf)
+{
+	char data[10];
+	if (ra_oid_ioctl(ifname, RT_OID_VERSION_INFO, data, sizeof(data)) < 0)
+		return -1;
+	strncpy(buf, "US", 2);
+	return 0;
+}
+
+int ra_get_countrylist(const char *ifname, char *buf, int *len)
+{
+
+	int i, count;
+	struct ISO3166_to_CCode *e, *p = NULL;
+	struct iwinfo_country_entry *c = (struct iwinfo_country_entry *)buf;
+	char data[10];
+	if (ra_oid_ioctl(ifname, RT_OID_VERSION_INFO, data, sizeof(data)) < 0)
+		return -1;
+	count = 0;
+
+	for (int i = 0; i < (sizeof(CountryCodes) / sizeof(CountryCodes[0])); i++)
+	{
+		e = &CountryCodes[i];
+
+		if (!p || (e->iso3166 != p->iso3166))
+		{
+			c->iso3166 = e->iso3166;
+			snprintf(c->ccode, sizeof(c->ccode), "%i", e->ccode);
+
+			c++;
+			count++;
+		}
+
+		p = e;
+	}
+
+	*len = (count * sizeof(struct iwinfo_country_entry));
+	return 0;
+}
+
+int ra_get_hwmodelist(const char *ifname, int *buf)
+{
+	char data[10];
+
+	if (ra_oid_ioctl(ifname, RT_OID_VERSION_INFO, data, sizeof(data)) < 0)
+		return -1;
+	if (is_5g(ifname))
+	{
+		*buf |= IWINFO_80211_A;
+		*buf |= IWINFO_80211_N;
+		*buf |= IWINFO_80211_AC;
+	}
+	else
+	{
+		*buf |= IWINFO_80211_B;
+		*buf |= IWINFO_80211_G;
+		*buf |= IWINFO_80211_N;
+	}
+
+	return 0;
+}
+
+int ra_get_htmodelist(const char *ifname, int *buf) {
+	*buf = IWINFO_HTMODE_HT20 | IWINFO_HTMODE_HT40 | IWINFO_HTMODE_VHT20 | IWINFO_HTMODE_VHT40 | IWINFO_HTMODE_VHT80;
+
+	return 0;
+}
+
+int ra_get_mbssid_support(const char *ifname, int *buf)
+{
+	char data[10];
+
+	if (ra_oid_ioctl(ifname, RT_OID_VERSION_INFO, data, sizeof(data)) < 0)
+		return -1;
+	*buf = 1;
+	return 0;
+}
+
+int iwinfo_hardware_id_from_mtd(struct iwinfo_hardware_id *id);
+
+int ra_get_hardware_id(const char *ifname, char *buf)
+{
+	struct iwinfo_hardware_id *id = (struct iwinfo_hardware_id *)buf;
+	memset(id, 0, sizeof(struct iwinfo_hardware_id));
+	char data[10];
+	if (ra_oid_ioctl(ifname, RT_OID_VERSION_INFO, data, sizeof(data)) < 0)
+		return -1;
+	return iwinfo_hardware_id_from_mtd(id);
+}
+
+struct iwinfo_hardware_entry * iwinfo_hardware(struct iwinfo_hardware_id *id);
+
+int ra_get_hardware_name(const char *ifname, char *buf)
+{
+	struct iwinfo_hardware_id id;
+	struct iwinfo_hardware_entry *e;
+
+	if (ra_get_hardware_id(ifname, (char *)&id))
+		return -1;
+
+	e = iwinfo_hardware(&id);
+	if (!e)
+		return -1;
+
+	strcpy(buf, e->device_name);
+
+	return 0;
+}
+
+int ra_get_txpower_offset(const char *ifname, int *buf)
+{
+	/* Stub */
+	*buf = 0;
+	return -1;
+}
+
+int ra_get_frequency_offset(const char *ifname, int *buf)
+{
+	return ra_get_frequency(ifname, buf);
+}
--- /dev/null
+++ b/iwinfo_ra.h
@@ -0,0 +1,74 @@
+#ifndef __IWINFO_RA_H_
+#define __IWINFO_RA_H_
+
+#include <fcntl.h>
+
+#include "iwinfo.h"
+#include "iwinfo/utils.h"
+
+
+#include "api/ralink.h"
+
+int ra_probe(const char *ifname);
+int ra_get_mode(const char *ifname, int *buf);
+int ra_get_ssid(const char *ifname, char *buf);
+int ra_get_bssid(const char *ifname, char *buf);
+int ra_get_country(const char *ifname, char *buf);
+int ra_get_channel(const char *ifname, int *buf);
+int ra_get_frequency(const char *ifname, int *buf);
+int ra_get_frequency_offset(const char *ifname, int *buf);
+int ra_get_txpower(const char *ifname, int *buf);
+int ra_get_txpower_offset(const char *ifname, int *buf);
+int ra_get_bitrate(const char *ifname, int *buf);
+int ra_get_signal(const char *ifname, int *buf);
+int ra_get_noise(const char *ifname, int *buf);
+int ra_get_quality(const char *ifname, int *buf);
+int ra_get_quality_max(const char *ifname, int *buf);
+int ra_get_enctype(const char *ifname, char *buf);
+int ra_get_encryption(const char *ifname, char *buf);
+int ra_get_phyname(const char *ifname, char *buf);
+int ra_get_assoclist(const char *ifname, char *buf, int *len);
+int ra_get_txpwrlist(const char *ifname, char *buf, int *len);
+int ra_get_scanlist(const char *ifname, char *buf, int *len);
+int ra_get_freqlist(const char *ifname, char *buf, int *len);
+int ra_get_countrylist(const char *ifname, char *buf, int *len);
+int ra_get_hwmodelist(const char *ifname, int *buf);
+int ra_get_htmodelist(const char *ifname, int *buf);
+int ra_get_mbssid_support(const char *ifname, int *buf);
+int ra_get_hardware_id(const char *ifname, char *buf);
+int ra_get_hardware_name(const char *ifname, char *buf);
+void ra_close(void);
+
+const struct iwinfo_ops ra_ops = {
+	.name             = "ra",
+	.probe            = ra_probe,
+	.channel          = ra_get_channel,
+	.frequency        = ra_get_frequency,
+	.frequency_offset = ra_get_frequency_offset,
+	.txpower          = ra_get_txpower,
+	.txpower_offset   = ra_get_txpower_offset,
+	.bitrate          = ra_get_bitrate,
+	.signal           = ra_get_signal,
+	.noise            = ra_get_noise,
+	.quality          = ra_get_quality,
+	.quality_max      = ra_get_quality_max,
+	.mbssid_support   = ra_get_mbssid_support,
+	.hwmodelist       = ra_get_hwmodelist,
+	.htmodelist       = ra_get_htmodelist,
+	.mode             = ra_get_mode,
+	.ssid             = ra_get_ssid,
+	.bssid            = ra_get_bssid,
+	.country          = ra_get_country,
+	.hardware_id      = ra_get_hardware_id,
+	.hardware_name    = ra_get_hardware_name,
+	.encryption       = ra_get_encryption,
+	.phyname          = ra_get_phyname,
+	.assoclist        = ra_get_assoclist,
+	.txpwrlist        = ra_get_txpwrlist,
+	.scanlist         = ra_get_scanlist,
+	.freqlist         = ra_get_freqlist,
+	.countrylist      = ra_get_countrylist,
+	.close            = ra_close
+};
+
+#endif
--- a/iwinfo_wext.c
+++ b/iwinfo_wext.c
@@ -185,7 +185,7 @@ static int wext_get_channel(const char *
 	return -1;
 }
 
-static int wext_get_frequency(const char *ifname, int *buf)
+int wext_get_frequency(const char *ifname, int *buf)
 {
 	struct iwreq wrq;
 	struct iw_range range;
@@ -282,7 +282,7 @@ static int wext_get_noise(const char *if
 	return -1;
 }
 
-static int wext_get_quality(const char *ifname, int *buf)
+int wext_get_quality(const char *ifname, int *buf)
 {
 	struct iwreq wrq;
 	struct iw_statistics stats;
@@ -300,7 +300,7 @@ static int wext_get_quality(const char *
 	return -1;
 }
 
-static int wext_get_quality_max(const char *ifname, int *buf)
+int wext_get_quality_max(const char *ifname, int *buf)
 {
 	struct iwreq wrq;
 	struct iw_range range;
@@ -365,7 +365,7 @@ static int wext_get_txpwrlist(const char
 	return -1;
 }
 
-static int wext_get_freqlist(const char *ifname, char *buf, int *len)
+int wext_get_freqlist(const char *ifname, char *buf, int *len)
 {
 	struct iwreq wrq;
 	struct iw_range range;
@@ -409,7 +409,7 @@ static int wext_get_countrylist(const ch
 	return -1;
 }
 
-static int wext_get_hwmodelist(const char *ifname, int *buf)
+int wext_get_hwmodelist(const char *ifname, int *buf)
 {
 	char chans[IWINFO_BUFSIZE] = { 0 };
 	struct iwinfo_freqlist_entry *e = NULL;
--- a/Makefile
+++ b/Makefile
@@ -32,6 +32,15 @@ ifneq ($(filter nl80211,$(IWINFO_BACKEND
 	IWINFO_LIB_OBJ     += iwinfo_nl80211.o
 endif
 
+ifneq ($(filter ra,$(IWINFO_BACKENDS)),)
+   IWINFO_CFLAGS  += -DUSE_RA
+   IWINFO_LIB_OBJ += iwinfo_ra.o
+endif
+
+ifneq ($(filter rt2860v2,$(IWINFO_BACKENDS)),)
+   IWINFO_CFLAGS  += -DUSE_RA -DUSE_RT2860
+   IWINFO_LIB_OBJ += iwinfo_ra.o
+endif
 
 %.o: %.c
 	$(CC) $(IWINFO_CFLAGS) $(FPIC) -c -o $@ $<
--- a/hardware.txt
+++ b/hardware.txt
@@ -173,6 +173,36 @@
 0x1814 0x3662 0x1814 0x000d    0      0  "Ralink"   "Rt3662"
 0x1814 0x3883 0x1814 0x000d    0      0  "Ralink"   "Rt3883"
 0x1814 0x5350 0x1814 0x000f    0      0  "Ralink"   "Rt5350"
+/* MT7620 */
+0x1814 0x7620 0x1814 0x0000    0      0  "Mediatek" "MT7620"
+0x1814 0x7620 0x1814 0xffff    0      0  "Mediatek" "MT7620"
+0x1814 0x7620 0x1814 0x7620    0      0  "Mediatek" "MT7620"
+/* MT7610 */
+0x1814 0x7610 0x1814 0x0000    0      0  "Mediatek" "MT7610"
+0x1814 0x7610 0x1814 0xffff    0      0  "Mediatek" "MT7610"
+0x1814 0x7610 0x1814 0x7610    0      0  "Mediatek" "MT7610"
+/* MT7602/MT7612/MT7662 */
+0x1814 0x7662 0x1814 0x0000    0      0  "Mediatek" "MT7612"
+0x1814 0x7662 0x1814 0xffff    0      0  "Mediatek" "MT7612"
+0x1814 0x7662 0x1814 0x7602    0      0  "Mediatek" "MT7602"
+0x1814 0x7662 0x1814 0x7612    0      0  "Mediatek" "MT7612"
+0x1814 0x7662 0x1814 0x7662    0      0  "Mediatek" "MT7662"
+/* MT7603 */
+0x1814 0x7603 0x1814 0x0000    0      0  "Mediatek" "MT7603"
+0x1814 0x7603 0x1814 0xffff    0      0  "Mediatek" "MT7603"
+0x1814 0x7603 0x1814 0x7603    0      0  "Mediatek" "MT7603"
+/* MT7628/MT7688 */
+0x1814 0x7628 0x1814 0x0000    0      0  "Mediatek" "MT7628"
+0x1814 0x7628 0x1814 0xffff    0      0  "Mediatek" "MT7628"
+0x1814 0x7628 0x1814 0x7628    0      0  "Mediatek" "MT7628"
+0x1814 0x7628 0x1814 0x7688    0      0  "Mediatek" "MT7688"
+/* MT7615 */
+0x1814 0x7615 0x1814 0x0000    0      0  "Mediatek" "MT7615"
+0x1814 0x7615 0x1814 0xffff    0      0  "Mediatek" "MT7615"
+0x1814 0x7615 0x1814 0x7615    0      0  "Mediatek" "MT7615"
+
+0x14c3 0x7615 0x14c3 0x0000    0      0  "MediaTek" "MT7615E"
+
 0x11ab 0x2a55 0x11ab 0x0000    0      0  "Marvell"  "88W8864"
 0x02df 0x9135 0x0000 0x0000    0      0  "Marvell"  "88W8887"
 0x11ab 0x2b40 0x11ab 0x0000    0      0  "Marvell"  "88W8964"
--- a/iwinfo_utils.c
+++ b/iwinfo_utils.c
@@ -259,7 +259,8 @@ int iwinfo_hardware_id_from_mtd(struct i
 
 				/* subsystem from EEPROM_NIC_CONF0_RF_TYPE */
 				id->subsystem_device_id = (bc[off + 0x1a] & 0x0f00) >> 8;
-			} else if ((bc[off] == 0x7620) || (bc[off] == 0x2076) ||
+			} else if ((bc[off] == 0x7615) || (bc[off] == 0x1576) ||
+			           (bc[off] == 0x7620) || (bc[off] == 0x2076) ||
 			           (bc[off] == 0x7628) || (bc[off] == 0x2876) ||
 			           (bc[off] == 0x7688) || (bc[off] == 0x8876)) {
 				/* vendor: MediaTek */
