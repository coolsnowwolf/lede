From f589cfb79c124649a74f09ec6e8534153dda176e Mon Sep 17 00:00:00 2001
From: Joseph Chen <chenjh@rock-chips.com>
Date: Thu, 23 Jan 2025 22:48:16 +0000
Subject: [PATCH 4/9] clk: rockchip: Add support for RK3528

Add clock driver for RK3528.

Imported from vendor U-Boot linux-6.1-stan-rkr5 tag with minor
adjustments and fixes for mainline.

Signed-off-by: Joseph Chen <chenjh@rock-chips.com>
Signed-off-by: Finley Xiao <finley.xiao@rock-chips.com>
Signed-off-by: Jonas Karlman <jonas@kwiboo.se>
---
 arch/arm/include/asm/arch-rockchip/clock.h    |    7 +
 .../include/asm/arch-rockchip/cru_rk3528.h    |  388 ++++
 arch/arm/mach-rockchip/rk3528/Makefile        |    1 +
 arch/arm/mach-rockchip/rk3528/clk_rk3528.c    |   16 +
 drivers/clk/rockchip/Makefile                 |    1 +
 drivers/clk/rockchip/clk_pll.c                |   23 +-
 drivers/clk/rockchip/clk_rk3528.c             | 1744 +++++++++++++++++
 include/dt-bindings/clock/rk3528-cru.h        |  751 +++++++
 8 files changed, 2925 insertions(+), 6 deletions(-)
 create mode 100644 arch/arm/include/asm/arch-rockchip/cru_rk3528.h
 create mode 100644 arch/arm/mach-rockchip/rk3528/clk_rk3528.c
 create mode 100644 drivers/clk/rockchip/clk_rk3528.c
 create mode 100644 include/dt-bindings/clock/rk3528-cru.h

--- a/arch/arm/include/asm/arch-rockchip/clock.h
+++ b/arch/arm/include/asm/arch-rockchip/clock.h
@@ -15,6 +15,13 @@ struct udevice;
 #define RKCLK_PLL_MODE_NORMAL		1
 #define RKCLK_PLL_MODE_DEEP		2
 
+/*
+ * PLL flags
+ */
+#define ROCKCHIP_PLL_SYNC_RATE		BIT(0)
+/* normal mode only. now only for pll_rk3036, pll_rk3328 type */
+#define ROCKCHIP_PLL_FIXED_MODE		BIT(1)
+
 enum {
 	ROCKCHIP_SYSCON_NOC,
 	ROCKCHIP_SYSCON_GRF,
--- /dev/null
+++ b/arch/arm/include/asm/arch-rockchip/cru_rk3528.h
@@ -0,0 +1,388 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2022 Rockchip Electronics Co., Ltd.
+ * Author: Joseph Chen <chenjh@rock-chips.com>
+ */
+
+#ifndef _ASM_ARCH_CRU_RK3528_H
+#define _ASM_ARCH_CRU_RK3528_H
+
+#define MHz		1000000
+#define KHz		1000
+#define OSC_HZ		(24 * MHz)
+
+#define CPU_PVTPLL_HZ	(1200 * MHz)
+#define APLL_HZ		(600 * MHz)
+#define GPLL_HZ		(1188 * MHz)
+#define CPLL_HZ		(996 * MHz)
+#define PPLL_HZ		(1000 * MHz)
+
+/* RK3528 pll id */
+enum rk3528_pll_id {
+	APLL,
+	CPLL,
+	GPLL,
+	PPLL,
+	DPLL,
+	PLL_COUNT,
+};
+
+struct rk3528_clk_priv {
+	struct rk3528_cru *cru;
+	unsigned long ppll_hz;
+	unsigned long gpll_hz;
+	unsigned long cpll_hz;
+	unsigned long armclk_hz;
+	unsigned long armclk_enter_hz;
+	unsigned long armclk_init_hz;
+	bool sync_kernel;
+};
+
+struct rk3528_pll {
+	unsigned int con0;
+	unsigned int con1;
+	unsigned int con2;
+	unsigned int con3;
+	unsigned int con4;
+	unsigned int reserved0[3];
+};
+
+#define RK3528_CRU_BASE			((struct rk3528_cru *)0xff4a0000)
+
+struct rk3528_cru {
+	unsigned int apll_con[5];
+	unsigned int reserved0014[3];
+	unsigned int cpll_con[5];
+	unsigned int reserved0034[11];
+	unsigned int gpll_con[5];
+	unsigned int reserved0074[51 + 32];
+	unsigned int reserved01c0[48];
+	unsigned int mode_con[1];
+	unsigned int reserved0284[31];
+	unsigned int clksel_con[91];
+	unsigned int reserved046c[229];
+	unsigned int gate_con[46];
+	unsigned int reserved08b8[82];
+	unsigned int softrst_con[47];
+	unsigned int reserved0abc[81];
+	unsigned int glb_cnt_th;
+	unsigned int glb_rst_st;
+	unsigned int glb_srst_fst;
+	unsigned int glb_srst_snd;
+	unsigned int glb_rst_con;
+	unsigned int reserved0c14[6];
+	unsigned int corewfi_con;
+	unsigned int reserved0c30[15604];
+
+	/* pmucru */
+	unsigned int reserved10000[192];
+	unsigned int pmuclksel_con[3];
+	unsigned int reserved1030c[317];
+	unsigned int pmugate_con[3];
+	unsigned int reserved1080c[125];
+	unsigned int pmusoftrst_con[3];
+	unsigned int reserved10a08[7550 + 8191];
+
+	/* pciecru */
+	unsigned int reserved20000[32];
+	unsigned int ppll_con[5];
+	unsigned int reserved20094[155];
+	unsigned int pcieclksel_con[2];
+	unsigned int reserved20308[318];
+	unsigned int pciegate_con;
+};
+
+check_member(rk3528_cru, pciegate_con, 0x20800);
+
+struct pll_rate_table {
+	unsigned long rate;
+	unsigned int fbdiv;
+	unsigned int postdiv1;
+	unsigned int refdiv;
+	unsigned int postdiv2;
+	unsigned int dsmpd;
+	unsigned int frac;
+};
+
+#define RK3528_PMU_CRU_BASE			0x10000
+#define RK3528_PCIE_CRU_BASE			0x20000
+#define RK3528_DDRPHY_CRU_BASE			0x28000
+#define RK3528_PLL_CON(x)			((x) * 0x4)
+#define RK3528_PCIE_PLL_CON(x)			((x) * 0x4 + RK3528_PCIE_CRU_BASE)
+#define RK3528_DDRPHY_PLL_CON(x)		((x) * 0x4 + RK3528_DDRPHY_CRU_BASE)
+#define RK3528_MODE_CON				0x280
+#define RK3528_CLKSEL_CON(x)			((x) * 0x4 + 0x300)
+#define RK3528_PMU_CLKSEL_CON(x)		((x) * 0x4 + 0x300 + RK3528_PMU_CRU_BASE)
+#define RK3528_PCIE_CLKSEL_CON(x)		((x) * 0x4 + 0x300 + RK3528_PCIE_CRU_BASE)
+#define RK3528_DDRPHY_MODE_CON			(0x280 + RK3528_DDRPHY_CRU_BASE)
+
+#define RK3528_DIV_ACLK_M_CORE_SHIFT		11
+#define RK3528_DIV_ACLK_M_CORE_MASK		(0x1f << RK3528_DIV_ACLK_M_CORE_SHIFT)
+#define RK3528_DIV_PCLK_DBG_SHIFT		1
+#define RK3528_DIV_PCLK_DBG_MASK		(0x1f << RK3528_DIV_PCLK_DBG_SHIFT)
+
+enum {
+	/* CRU_CLKSEL_CON00 */
+	CLK_MATRIX_50M_SRC_DIV_SHIFT		= 2,
+	CLK_MATRIX_50M_SRC_DIV_MASK		= 0x1F << CLK_MATRIX_50M_SRC_DIV_SHIFT,
+	CLK_MATRIX_100M_SRC_DIV_SHIFT		= 7,
+	CLK_MATRIX_100M_SRC_DIV_MASK		= 0x1F << CLK_MATRIX_100M_SRC_DIV_SHIFT,
+
+	/* CRU_CLKSEL_CON01 */
+	CLK_MATRIX_150M_SRC_DIV_SHIFT		= 0,
+	CLK_MATRIX_150M_SRC_DIV_MASK		= 0x1F << CLK_MATRIX_150M_SRC_DIV_SHIFT,
+	CLK_MATRIX_200M_SRC_DIV_SHIFT		= 5,
+	CLK_MATRIX_200M_SRC_DIV_MASK		= 0x1F << CLK_MATRIX_200M_SRC_DIV_SHIFT,
+	CLK_MATRIX_250M_SRC_DIV_SHIFT		= 10,
+	CLK_MATRIX_250M_SRC_DIV_MASK		= 0x1F << CLK_MATRIX_250M_SRC_DIV_SHIFT,
+	CLK_MATRIX_250M_SRC_SEL_SHIFT		= 15,
+	CLK_MATRIX_250M_SRC_SEL_MASK		= 0x1 << CLK_MATRIX_250M_SRC_SEL_SHIFT,
+
+	/* CRU_CLKSEL_CON02 */
+	CLK_MATRIX_300M_SRC_DIV_SHIFT		= 0,
+	CLK_MATRIX_300M_SRC_DIV_MASK		= 0x1F << CLK_MATRIX_300M_SRC_DIV_SHIFT,
+	CLK_MATRIX_339M_SRC_DIV_SHIFT		= 5,
+	CLK_MATRIX_339M_SRC_DIV_MASK		= 0x1F << CLK_MATRIX_339M_SRC_DIV_SHIFT,
+	CLK_MATRIX_400M_SRC_DIV_SHIFT		= 10,
+	CLK_MATRIX_400M_SRC_DIV_MASK		= 0x1F << CLK_MATRIX_400M_SRC_DIV_SHIFT,
+
+	/* CRU_CLKSEL_CON03 */
+	CLK_MATRIX_500M_SRC_DIV_SHIFT		= 6,
+	CLK_MATRIX_500M_SRC_DIV_MASK		= 0x1F << CLK_MATRIX_500M_SRC_DIV_SHIFT,
+	CLK_MATRIX_500M_SRC_SEL_SHIFT		= 11,
+	CLK_MATRIX_500M_SRC_SEL_MASK		= 0x1 << CLK_MATRIX_500M_SRC_SEL_SHIFT,
+
+	/* CRU_CLKSEL_CON04 */
+	CLK_MATRIX_600M_SRC_DIV_SHIFT		= 0,
+	CLK_MATRIX_600M_SRC_DIV_MASK		= 0x1F << CLK_MATRIX_600M_SRC_DIV_SHIFT,
+	CLK_MATRIX_250M_SRC_SEL_CLK_GPLL_MUX	= 0U,
+	CLK_MATRIX_250M_SRC_SEL_CLK_CPLL_MUX	= 1U,
+	CLK_MATRIX_500M_SRC_SEL_CLK_GPLL_MUX	= 0U,
+	CLK_MATRIX_500M_SRC_SEL_CLK_CPLL_MUX	= 1U,
+
+	/* PMUCRU_CLKSEL_CON00 */
+	CLK_I2C2_SEL_SHIFT			= 0,
+	CLK_I2C2_SEL_MASK			= 0x3 << CLK_I2C2_SEL_SHIFT,
+
+	/* PCIE_CRU_CLKSEL_CON01 */
+	PCIE_CLK_MATRIX_50M_SRC_DIV_SHIFT	= 7,
+	PCIE_CLK_MATRIX_50M_SRC_DIV_MASK	= 0x1f << PCIE_CLK_MATRIX_50M_SRC_DIV_SHIFT,
+	PCIE_CLK_MATRIX_100M_SRC_DIV_SHIFT	= 11,
+	PCIE_CLK_MATRIX_100M_SRC_DIV_MASK	= 0x1f << PCIE_CLK_MATRIX_100M_SRC_DIV_SHIFT,
+
+	/* CRU_CLKSEL_CON32 */
+	DCLK_VOP_SRC0_SEL_SHIFT			= 10,
+	DCLK_VOP_SRC0_SEL_MASK			= 0x1 << DCLK_VOP_SRC0_SEL_SHIFT,
+	DCLK_VOP_SRC0_DIV_SHIFT			= 2,
+	DCLK_VOP_SRC0_DIV_MASK			= 0xFF << DCLK_VOP_SRC0_DIV_SHIFT,
+
+	/* CRU_CLKSEL_CON33 */
+	DCLK_VOP_SRC1_SEL_SHIFT			= 8,
+	DCLK_VOP_SRC1_SEL_MASK			= 0x1 << DCLK_VOP_SRC1_SEL_SHIFT,
+	DCLK_VOP_SRC1_DIV_SHIFT			= 0,
+	DCLK_VOP_SRC1_DIV_MASK			= 0xFF << DCLK_VOP_SRC1_DIV_SHIFT,
+
+	/* CRU_CLKSEL_CON43 */
+	CLK_CORE_CRYPTO_SEL_SHIFT		= 14,
+	CLK_CORE_CRYPTO_SEL_MASK		= 0x3 << CLK_CORE_CRYPTO_SEL_SHIFT,
+	ACLK_BUS_VOPGL_ROOT_DIV_SHIFT		= 0U,
+	ACLK_BUS_VOPGL_ROOT_DIV_MASK		= 0x7U << ACLK_BUS_VOPGL_ROOT_DIV_SHIFT,
+
+	/* CRU_CLKSEL_CON44 */
+	CLK_PWM0_SEL_SHIFT			= 6,
+	CLK_PWM0_SEL_MASK			= 0x3 << CLK_PWM0_SEL_SHIFT,
+	CLK_PWM1_SEL_SHIFT			= 8,
+	CLK_PWM1_SEL_MASK			= 0x3 << CLK_PWM1_SEL_SHIFT,
+	CLK_PWM0_SEL_CLK_MATRIX_100M_SRC	= 0U,
+	CLK_PWM0_SEL_CLK_MATRIX_50M_SRC		= 1U,
+	CLK_PWM0_SEL_XIN_OSC0_FUNC		= 2U,
+	CLK_PWM1_SEL_CLK_MATRIX_100M_SRC	= 0U,
+	CLK_PWM1_SEL_CLK_MATRIX_50M_SRC		= 1U,
+	CLK_PWM1_SEL_XIN_OSC0_FUNC		= 2U,
+	CLK_PKA_CRYPTO_SEL_SHIFT		= 0,
+	CLK_PKA_CRYPTO_SEL_MASK			= 0x3 << CLK_PKA_CRYPTO_SEL_SHIFT,
+	CLK_CORE_CRYPTO_SEL_CLK_MATRIX_300M_SRC	= 0U,
+	CLK_CORE_CRYPTO_SEL_CLK_MATRIX_200M_SRC	= 1U,
+	CLK_CORE_CRYPTO_SEL_CLK_MATRIX_100M_SRC	= 2U,
+	CLK_CORE_CRYPTO_SEL_XIN_OSC0_FUNC	= 3U,
+	CLK_PKA_CRYPTO_SEL_CLK_MATRIX_300M_SRC	= 0U,
+	CLK_PKA_CRYPTO_SEL_CLK_MATRIX_200M_SRC	= 1U,
+	CLK_PKA_CRYPTO_SEL_CLK_MATRIX_100M_SRC	= 2U,
+	CLK_PKA_CRYPTO_SEL_XIN_OSC0_FUNC	= 3U,
+
+	/* CRU_CLKSEL_CON60 */
+	CLK_MATRIX_25M_SRC_DIV_SHIFT		= 2,
+	CLK_MATRIX_25M_SRC_DIV_MASK		= 0xff << CLK_MATRIX_25M_SRC_DIV_SHIFT,
+	CLK_MATRIX_125M_SRC_DIV_SHIFT		= 10,
+	CLK_MATRIX_125M_SRC_DIV_MASK		= 0x1f << CLK_MATRIX_125M_SRC_DIV_SHIFT,
+
+	/* CRU_CLKSEL_CON61 */
+	SCLK_SFC_DIV_SHIFT			= 6,
+	SCLK_SFC_DIV_MASK			= 0x3F << SCLK_SFC_DIV_SHIFT,
+	SCLK_SFC_SEL_SHIFT			= 12,
+	SCLK_SFC_SEL_MASK			= 0x3 << SCLK_SFC_SEL_SHIFT,
+	SCLK_SFC_SEL_CLK_GPLL_MUX		= 0U,
+	SCLK_SFC_SEL_CLK_CPLL_MUX		= 1U,
+	SCLK_SFC_SEL_XIN_OSC0_FUNC		= 2U,
+
+	/* CRU_CLKSEL_CON62 */
+	CCLK_SRC_EMMC_DIV_SHIFT			= 0,
+	CCLK_SRC_EMMC_DIV_MASK			= 0x3F << CCLK_SRC_EMMC_DIV_SHIFT,
+	CCLK_SRC_EMMC_SEL_SHIFT			= 6,
+	CCLK_SRC_EMMC_SEL_MASK			= 0x3 << CCLK_SRC_EMMC_SEL_SHIFT,
+	BCLK_EMMC_SEL_SHIFT			= 8,
+	BCLK_EMMC_SEL_MASK			= 0x3 << BCLK_EMMC_SEL_SHIFT,
+
+	/* CRU_CLKSEL_CON63 */
+	CLK_I2C3_SEL_SHIFT			= 12,
+	CLK_I2C3_SEL_MASK			= 0x3 << CLK_I2C3_SEL_SHIFT,
+	CLK_I2C5_SEL_SHIFT			= 14,
+	CLK_I2C5_SEL_MASK			= 0x3 << CLK_I2C5_SEL_SHIFT,
+	CLK_SPI1_SEL_SHIFT			= 10,
+	CLK_SPI1_SEL_MASK			= 0x3 << CLK_SPI1_SEL_SHIFT,
+
+	/* CRU_CLKSEL_CON64 */
+	CLK_I2C6_SEL_SHIFT			= 0,
+	CLK_I2C6_SEL_MASK			= 0x3 << CLK_I2C6_SEL_SHIFT,
+
+	/* CRU_CLKSEL_CON74 */
+	CLK_SARADC_DIV_SHIFT			= 0,
+	CLK_SARADC_DIV_MASK			= 0x7 << CLK_SARADC_DIV_SHIFT,
+	CLK_TSADC_DIV_SHIFT			= 3,
+	CLK_TSADC_DIV_MASK			= 0x1F << CLK_TSADC_DIV_SHIFT,
+	CLK_TSADC_TSEN_DIV_SHIFT		= 8,
+	CLK_TSADC_TSEN_DIV_MASK			= 0x1F << CLK_TSADC_TSEN_DIV_SHIFT,
+
+	/* CRU_CLKSEL_CON79 */
+	CLK_I2C1_SEL_SHIFT			= 9,
+	CLK_I2C1_SEL_MASK			= 0x3 << CLK_I2C1_SEL_SHIFT,
+	CLK_I2C0_SEL_SHIFT			= 11,
+	CLK_I2C0_SEL_MASK			= 0x3 << CLK_I2C0_SEL_SHIFT,
+	CLK_SPI0_SEL_SHIFT			= 13,
+	CLK_SPI0_SEL_MASK			= 0x3 << CLK_SPI0_SEL_SHIFT,
+
+	/* CRU_CLKSEL_CON83 */
+	ACLK_VOP_ROOT_DIV_SHIFT			= 12,
+	ACLK_VOP_ROOT_DIV_MASK			= 0x7 << ACLK_VOP_ROOT_DIV_SHIFT,
+	ACLK_VOP_ROOT_SEL_SHIFT			= 15,
+	ACLK_VOP_ROOT_SEL_MASK			= 0x1 << ACLK_VOP_ROOT_SEL_SHIFT,
+
+	/* CRU_CLKSEL_CON84 */
+	DCLK_VOP0_SEL_SHIFT			= 0,
+	DCLK_VOP0_SEL_MASK			= 0x1 << DCLK_VOP0_SEL_SHIFT,
+	DCLK_VOP_SRC_SEL_CLK_GPLL_MUX		= 0U,
+	DCLK_VOP_SRC_SEL_CLK_CPLL_MUX		= 1U,
+	ACLK_VOP_ROOT_SEL_CLK_GPLL_MUX		= 0U,
+	ACLK_VOP_ROOT_SEL_CLK_CPLL_MUX		= 1U,
+	DCLK_VOP0_SEL_DCLK_VOP_SRC0		= 0U,
+	DCLK_VOP0_SEL_CLK_HDMIPHY_PIXEL_IO	= 1U,
+
+	/* CRU_CLKSEL_CON85 */
+	CLK_I2C4_SEL_SHIFT			= 13,
+	CLK_I2C4_SEL_MASK			= 0x3 << CLK_I2C4_SEL_SHIFT,
+	CLK_I2C7_SEL_SHIFT			= 0,
+	CLK_I2C7_SEL_MASK			= 0x3 << CLK_I2C7_SEL_SHIFT,
+	CLK_I2C3_SEL_CLK_MATRIX_200M_SRC	= 0U,
+	CLK_I2C3_SEL_CLK_MATRIX_100M_SRC	= 1U,
+	CLK_I2C3_SEL_CLK_MATRIX_50M_SRC		= 2U,
+	CLK_I2C3_SEL_XIN_OSC0_FUNC		= 3U,
+	CLK_SPI1_SEL_CLK_MATRIX_200M_SRC	= 0U,
+	CLK_SPI1_SEL_CLK_MATRIX_100M_SRC	= 1U,
+	CLK_SPI1_SEL_CLK_MATRIX_50M_SRC		= 2U,
+	CLK_SPI1_SEL_XIN_OSC0_FUNC		= 3U,
+	CCLK_SRC_SDMMC0_DIV_SHIFT		= 0,
+	CCLK_SRC_SDMMC0_DIV_MASK		= 0x3F << CCLK_SRC_SDMMC0_DIV_SHIFT,
+	CCLK_SRC_SDMMC0_SEL_SHIFT		= 6,
+	CCLK_SRC_SDMMC0_SEL_MASK		= 0x3 << CCLK_SRC_SDMMC0_SEL_SHIFT,
+	CCLK_SRC_EMMC_SEL_CLK_GPLL_MUX		= 0U,
+	CCLK_SRC_EMMC_SEL_CLK_CPLL_MUX		= 1U,
+	CCLK_SRC_EMMC_SEL_XIN_OSC0_FUNC		= 2U,
+	BCLK_EMMC_SEL_CLK_MATRIX_200M_SRC	= 0U,
+	BCLK_EMMC_SEL_CLK_MATRIX_100M_SRC	= 1U,
+	BCLK_EMMC_SEL_CLK_MATRIX_50M_SRC	= 2U,
+	BCLK_EMMC_SEL_XIN_OSC0_FUNC		= 3U,
+	CCLK_SRC_SDMMC0_SEL_CLK_GPLL_MUX	= 0U,
+	CCLK_SRC_SDMMC0_SEL_CLK_CPLL_MUX	= 1U,
+	CCLK_SRC_SDMMC0_SEL_XIN_OSC0_FUNC	= 2U,
+
+	/* CRU_CLKSEL_CON04 */
+	CLK_UART0_SRC_DIV_SHIFT			= 5,
+	CLK_UART0_SRC_DIV_MASK			= 0x1F << CLK_UART0_SRC_DIV_SHIFT,
+	/* CRU_CLKSEL_CON05 */
+	CLK_UART0_FRAC_DIV_SHIFT		= 0,
+	CLK_UART0_FRAC_DIV_MASK			= 0xFFFFFFFF << CLK_UART0_FRAC_DIV_SHIFT,
+	/* CRU_CLKSEL_CON06 */
+	SCLK_UART0_SRC_SEL_SHIFT		= 0,
+	SCLK_UART0_SRC_SEL_MASK			= 0x3 << SCLK_UART0_SRC_SEL_SHIFT,
+	CLK_UART1_SRC_DIV_SHIFT			= 2,
+	CLK_UART1_SRC_DIV_MASK			= 0x1F << CLK_UART1_SRC_DIV_SHIFT,
+	/* CRU_CLKSEL_CON07 */
+	CLK_UART1_FRAC_DIV_SHIFT		= 0,
+	CLK_UART1_FRAC_DIV_MASK			= 0xFFFFFFFF << CLK_UART1_FRAC_DIV_SHIFT,
+	/* CRU_CLKSEL_CON08 */
+	SCLK_UART1_SRC_SEL_SHIFT		= 0,
+	SCLK_UART1_SRC_SEL_MASK			= 0x3 << SCLK_UART1_SRC_SEL_SHIFT,
+	CLK_UART2_SRC_DIV_SHIFT			= 2,
+	CLK_UART2_SRC_DIV_MASK			= 0x1F << CLK_UART2_SRC_DIV_SHIFT,
+	/* CRU_CLKSEL_CON09 */
+	CLK_UART2_FRAC_DIV_SHIFT		= 0,
+	CLK_UART2_FRAC_DIV_MASK			= 0xFFFFFFFF << CLK_UART2_FRAC_DIV_SHIFT,
+	/* CRU_CLKSEL_CON10 */
+	SCLK_UART2_SRC_SEL_SHIFT		= 0,
+	SCLK_UART2_SRC_SEL_MASK			= 0x3 << SCLK_UART2_SRC_SEL_SHIFT,
+	CLK_UART3_SRC_DIV_SHIFT			= 2,
+	CLK_UART3_SRC_DIV_MASK			= 0x1F << CLK_UART3_SRC_DIV_SHIFT,
+	/* CRU_CLKSEL_CON11 */
+	CLK_UART3_FRAC_DIV_SHIFT		= 0,
+	CLK_UART3_FRAC_DIV_MASK			= 0xFFFFFFFF << CLK_UART3_FRAC_DIV_SHIFT,
+	/* CRU_CLKSEL_CON12 */
+	SCLK_UART3_SRC_SEL_SHIFT		= 0,
+	SCLK_UART3_SRC_SEL_MASK			= 0x3 << SCLK_UART3_SRC_SEL_SHIFT,
+	CLK_UART4_SRC_DIV_SHIFT			= 2,
+	CLK_UART4_SRC_DIV_MASK			= 0x1F << CLK_UART4_SRC_DIV_SHIFT,
+	/* CRU_CLKSEL_CON13 */
+	CLK_UART4_FRAC_DIV_SHIFT		= 0,
+	CLK_UART4_FRAC_DIV_MASK			= 0xFFFFFFFF << CLK_UART4_FRAC_DIV_SHIFT,
+	/* CRU_CLKSEL_CON14 */
+	SCLK_UART4_SRC_SEL_SHIFT		= 0,
+	SCLK_UART4_SRC_SEL_MASK			= 0x3 << SCLK_UART4_SRC_SEL_SHIFT,
+	CLK_UART5_SRC_DIV_SHIFT			= 2,
+	CLK_UART5_SRC_DIV_MASK			= 0x1F << CLK_UART5_SRC_DIV_SHIFT,
+	/* CRU_CLKSEL_CON15 */
+	CLK_UART5_FRAC_DIV_SHIFT		= 0,
+	CLK_UART5_FRAC_DIV_MASK			= 0xFFFFFFFF << CLK_UART5_FRAC_DIV_SHIFT,
+	/* CRU_CLKSEL_CON16 */
+	SCLK_UART5_SRC_SEL_SHIFT		= 0,
+	SCLK_UART5_SRC_SEL_MASK			= 0x3 << SCLK_UART5_SRC_SEL_SHIFT,
+	CLK_UART6_SRC_DIV_SHIFT			= 2,
+	CLK_UART6_SRC_DIV_MASK			= 0x1F << CLK_UART6_SRC_DIV_SHIFT,
+	/* CRU_CLKSEL_CON17 */
+	CLK_UART6_FRAC_DIV_SHIFT		= 0,
+	CLK_UART6_FRAC_DIV_MASK			= 0xFFFFFFFF << CLK_UART6_FRAC_DIV_SHIFT,
+	/* CRU_CLKSEL_CON18 */
+	SCLK_UART6_SRC_SEL_SHIFT		= 0,
+	SCLK_UART6_SRC_SEL_MASK			= 0x3 << SCLK_UART6_SRC_SEL_SHIFT,
+	CLK_UART7_SRC_DIV_SHIFT			= 2,
+	CLK_UART7_SRC_DIV_MASK			= 0x1F << CLK_UART7_SRC_DIV_SHIFT,
+	/* CRU_CLKSEL_CON19 */
+	CLK_UART7_FRAC_DIV_SHIFT		= 0,
+	CLK_UART7_FRAC_DIV_MASK			= 0xFFFFFFFF << CLK_UART7_FRAC_DIV_SHIFT,
+	/* CRU_CLKSEL_CON20 */
+	SCLK_UART7_SRC_SEL_SHIFT		= 0,
+	SCLK_UART7_SRC_SEL_MASK			= 0x3 << SCLK_UART7_SRC_SEL_SHIFT,
+	SCLK_UART0_SRC_SEL_CLK_UART0_SRC	= 0U,
+	SCLK_UART0_SRC_SEL_CLK_UART0_FRAC	= 1U,
+	SCLK_UART0_SRC_SEL_XIN_OSC0_FUNC	= 2U,
+
+	/* CRU_CLKSEL_CON60 */
+	CLK_GMAC1_VPU_25M_DIV_SHIFT		= 2,
+	CLK_GMAC1_VPU_25M_DIV_MASK		= 0xFF << CLK_GMAC1_VPU_25M_DIV_SHIFT,
+	/* CRU_CLKSEL_CON66 */
+	CLK_GMAC1_SRC_VPU_DIV_SHIFT		= 0,
+	CLK_GMAC1_SRC_VPU_DIV_MASK		= 0x3F << CLK_GMAC1_SRC_VPU_DIV_SHIFT,
+	/* CRU_CLKSEL_CON84 */
+	CLK_GMAC0_SRC_DIV_SHIFT			= 3,
+	CLK_GMAC0_SRC_DIV_MASK			= 0x3F << CLK_GMAC0_SRC_DIV_SHIFT,
+};
+
+#endif /* _ASM_ARCH_CRU_RK3528_H */
--- a/arch/arm/mach-rockchip/rk3528/Makefile
+++ b/arch/arm/mach-rockchip/rk3528/Makefile
@@ -1,4 +1,5 @@
 # SPDX-License-Identifier: GPL-2.0-or-later
 
 obj-y += rk3528.o
+obj-y += clk_rk3528.o
 obj-y += syscon_rk3528.o
--- /dev/null
+++ b/arch/arm/mach-rockchip/rk3528/clk_rk3528.c
@@ -0,0 +1,16 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+// Copyright Contributors to the U-Boot project.
+
+#include <dm.h>
+#include <asm/arch-rockchip/cru_rk3528.h>
+
+int rockchip_get_clk(struct udevice **devp)
+{
+	return uclass_get_device_by_driver(UCLASS_CLK,
+				DM_DRIVER_GET(rockchip_rk3528_cru), devp);
+}
+
+void *rockchip_get_cru(void)
+{
+	return RK3528_CRU_BASE;
+}
--- a/drivers/clk/rockchip/Makefile
+++ b/drivers/clk/rockchip/Makefile
@@ -15,6 +15,7 @@ obj-$(CONFIG_ROCKCHIP_RK3308) += clk_rk3
 obj-$(CONFIG_ROCKCHIP_RK3328) += clk_rk3328.o
 obj-$(CONFIG_ROCKCHIP_RK3368) += clk_rk3368.o
 obj-$(CONFIG_ROCKCHIP_RK3399) += clk_rk3399.o
+obj-$(CONFIG_ROCKCHIP_RK3528) += clk_rk3528.o
 obj-$(CONFIG_ROCKCHIP_RK3568) += clk_rk3568.o
 obj-$(CONFIG_ROCKCHIP_RK3588) += clk_rk3588.o
 obj-$(CONFIG_ROCKCHIP_RV1108) += clk_rv1108.o
--- a/drivers/clk/rockchip/clk_pll.c
+++ b/drivers/clk/rockchip/clk_pll.c
@@ -309,9 +309,11 @@ static int rk3036_pll_set_rate(struct ro
 	 * When power on or changing PLL setting,
 	 * we must force PLL into slow mode to ensure output stable clock.
 	 */
-	rk_clrsetreg(base + pll->mode_offset,
-		     pll->mode_mask << pll->mode_shift,
-		     RKCLK_PLL_MODE_SLOW << pll->mode_shift);
+	if (!(pll->pll_flags & ROCKCHIP_PLL_FIXED_MODE)) {
+		rk_clrsetreg(base + pll->mode_offset,
+			     pll->mode_mask << pll->mode_shift,
+			     RKCLK_PLL_MODE_SLOW << pll->mode_shift);
+	}
 
 	/* Power down */
 	rk_setreg(base + pll->con_offset + 0x4,
@@ -345,8 +347,11 @@ static int rk3036_pll_set_rate(struct ro
 	while (!(readl(base + pll->con_offset + 0x4) & (1 << pll->lock_shift)))
 		udelay(1);
 
-	rk_clrsetreg(base + pll->mode_offset, pll->mode_mask << pll->mode_shift,
-		     RKCLK_PLL_MODE_NORMAL << pll->mode_shift);
+	if (!(pll->pll_flags & ROCKCHIP_PLL_FIXED_MODE)) {
+		rk_clrsetreg(base + pll->mode_offset,
+			     pll->mode_mask << pll->mode_shift,
+			     RKCLK_PLL_MODE_NORMAL << pll->mode_shift);
+	}
 	debug("PLL at %p: con0=%x con1= %x con2= %x mode= %x\n",
 	      pll, readl(base + pll->con_offset),
 	      readl(base + pll->con_offset + 0x4),
@@ -362,12 +367,18 @@ static ulong rk3036_pll_get_rate(struct
 	u32 refdiv, fbdiv, postdiv1, postdiv2, dsmpd, frac;
 	u32 con = 0, shift, mask;
 	ulong rate;
+	int mode;
 
 	con = readl(base + pll->mode_offset);
 	shift = pll->mode_shift;
 	mask = pll->mode_mask << shift;
 
-	switch ((con & mask) >> shift) {
+	if (!(pll->pll_flags & ROCKCHIP_PLL_FIXED_MODE))
+		mode = (con & mask) >> shift;
+	else
+		mode = RKCLK_PLL_MODE_NORMAL;
+
+	switch (mode) {
 	case RKCLK_PLL_MODE_SLOW:
 		return OSC_HZ;
 	case RKCLK_PLL_MODE_NORMAL:
--- /dev/null
+++ b/drivers/clk/rockchip/clk_rk3528.c
@@ -0,0 +1,1744 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2022 Rockchip Electronics Co., Ltd.
+ * Author: Joseph Chen <chenjh@rock-chips.com>
+ */
+
+#include <bitfield.h>
+#include <clk-uclass.h>
+#include <dm.h>
+#include <errno.h>
+#include <syscon.h>
+#include <asm/arch-rockchip/clock.h>
+#include <asm/arch-rockchip/cru_rk3528.h>
+#include <asm/arch-rockchip/hardware.h>
+#include <dm/device-internal.h>
+#include <dm/lists.h>
+#include <dt-bindings/clock/rk3528-cru.h>
+#include <linux/delay.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define DIV_TO_RATE(input_rate, div)	((input_rate) / ((div) + 1))
+
+/*
+ *	PLL attention.
+ *
+ * [FRAC PLL]: GPLL, PPLL, DPLL
+ *   - frac mode: refdiv can be 1 or 2 only
+ *   - int mode:  refdiv has no special limit
+ *   - VCO range: [950, 3800] MHZ
+ *
+ * [INT PLL]:  CPLL, APLL
+ *   - int mode:  refdiv can be 1 or 2 only
+ *   - VCO range: [475, 1900] MHZ
+ *
+ * [PPLL]: normal mode only.
+ *
+ */
+static struct rockchip_pll_rate_table rk3528_pll_rates[] = {
+	/* _mhz, _refdiv, _fbdiv, _postdiv1, _postdiv2, _dsmpd, _frac */
+	RK3036_PLL_RATE(1896000000, 1, 79, 1, 1, 1, 0),
+	RK3036_PLL_RATE(1800000000, 1, 75, 1, 1, 1, 0),
+	RK3036_PLL_RATE(1704000000, 1, 71, 1, 1, 1, 0),
+	RK3036_PLL_RATE(1608000000, 1, 67, 1, 1, 1, 0),
+	RK3036_PLL_RATE(1512000000, 1, 63, 1, 1, 1, 0),
+	RK3036_PLL_RATE(1416000000, 1, 59, 1, 1, 1, 0),
+	RK3036_PLL_RATE(1296000000, 1, 54, 1, 1, 1, 0),
+	RK3036_PLL_RATE(1200000000, 1, 50, 1, 1, 1, 0),
+	RK3036_PLL_RATE(1188000000, 1, 99, 2, 1, 1, 0),		/* GPLL */
+	RK3036_PLL_RATE(1092000000, 2, 91, 1, 1, 1, 0),
+	RK3036_PLL_RATE(1008000000, 1, 42, 1, 1, 1, 0),
+	RK3036_PLL_RATE(1000000000, 1, 125, 3, 1, 1, 0),	/* PPLL */
+	RK3036_PLL_RATE(996000000, 2, 83, 1, 1, 1, 0),		/* CPLL */
+	RK3036_PLL_RATE(960000000, 1, 40, 1, 1, 1, 0),
+	RK3036_PLL_RATE(912000000, 1, 76, 2, 1, 1, 0),
+	RK3036_PLL_RATE(816000000, 1, 68, 2, 1, 1, 0),
+	RK3036_PLL_RATE(600000000, 1, 50, 2, 1, 1, 0),
+	RK3036_PLL_RATE(594000000, 2, 99, 2, 1, 1, 0),
+	RK3036_PLL_RATE(408000000, 1, 68, 2, 2, 1, 0),
+	RK3036_PLL_RATE(312000000, 1, 78, 6, 1, 1, 0),
+	RK3036_PLL_RATE(216000000, 1, 72, 4, 2, 1, 0),
+	RK3036_PLL_RATE(96000000, 1, 24, 3, 2, 1, 0),
+	{ /* sentinel */ },
+};
+
+static struct rockchip_pll_clock rk3528_pll_clks[] = {
+	[APLL] = PLL(pll_rk3328, PLL_APLL, RK3528_PLL_CON(0),
+		     RK3528_MODE_CON, 0, 10, 0, rk3528_pll_rates),
+
+	[CPLL] = PLL(pll_rk3328, PLL_CPLL, RK3528_PLL_CON(8),
+		     RK3528_MODE_CON, 2, 10, 0, rk3528_pll_rates),
+
+	[GPLL] = PLL(pll_rk3328, PLL_GPLL, RK3528_PLL_CON(24),
+		     RK3528_MODE_CON, 4, 10, 0, rk3528_pll_rates),
+
+	[PPLL] = PLL(pll_rk3328, PLL_PPLL, RK3528_PCIE_PLL_CON(32),
+		     RK3528_MODE_CON, 6, 10, ROCKCHIP_PLL_FIXED_MODE, rk3528_pll_rates),
+
+	[DPLL] = PLL(pll_rk3328, PLL_DPLL, RK3528_DDRPHY_PLL_CON(16),
+		     RK3528_DDRPHY_MODE_CON, 0, 10, 0, rk3528_pll_rates),
+};
+
+#define RK3528_CPUCLK_RATE(_rate, _aclk_m_core, _pclk_dbg)	\
+{								\
+	.rate = _rate##U,					\
+	.aclk_div = (_aclk_m_core),				\
+	.pclk_div = (_pclk_dbg),				\
+}
+
+/* sign-off: _aclk_m_core: 550M, _pclk_dbg: 137.5M, */
+static struct rockchip_cpu_rate_table rk3528_cpu_rates[] = {
+	RK3528_CPUCLK_RATE(1896000000, 1, 13),
+	RK3528_CPUCLK_RATE(1800000000, 1, 12),
+	RK3528_CPUCLK_RATE(1704000000, 1, 11),
+	RK3528_CPUCLK_RATE(1608000000, 1, 11),
+	RK3528_CPUCLK_RATE(1512000000, 1, 11),
+	RK3528_CPUCLK_RATE(1416000000, 1, 9),
+	RK3528_CPUCLK_RATE(1296000000, 1, 8),
+	RK3528_CPUCLK_RATE(1200000000, 1, 8),
+	RK3528_CPUCLK_RATE(1188000000, 1, 8),
+	RK3528_CPUCLK_RATE(1092000000, 1, 7),
+	RK3528_CPUCLK_RATE(1008000000, 1, 6),
+	RK3528_CPUCLK_RATE(1000000000, 1, 6),
+	RK3528_CPUCLK_RATE(996000000, 1, 6),
+	RK3528_CPUCLK_RATE(960000000, 1, 6),
+	RK3528_CPUCLK_RATE(912000000, 1, 6),
+	RK3528_CPUCLK_RATE(816000000, 1, 5),
+	RK3528_CPUCLK_RATE(600000000, 1, 3),
+	RK3528_CPUCLK_RATE(594000000, 1, 3),
+	RK3528_CPUCLK_RATE(408000000, 1, 2),
+	RK3528_CPUCLK_RATE(312000000, 1, 2),
+	RK3528_CPUCLK_RATE(216000000, 1, 1),
+	RK3528_CPUCLK_RATE(96000000, 1, 0),
+};
+
+/*
+ *
+ * rational_best_approximation(31415, 10000,
+ *		(1 << 8) - 1, (1 << 5) - 1, &n, &d);
+ *
+ * you may look at given_numerator as a fixed point number,
+ * with the fractional part size described in given_denominator.
+ *
+ * for theoretical background, see:
+ * http://en.wikipedia.org/wiki/Continued_fraction
+ */
+static void rational_best_approximation(unsigned long given_numerator,
+					unsigned long given_denominator,
+					unsigned long max_numerator,
+					unsigned long max_denominator,
+					unsigned long *best_numerator,
+					unsigned long *best_denominator)
+{
+	unsigned long n, d, n0, d0, n1, d1;
+
+	n = given_numerator;
+	d = given_denominator;
+	n0 = 0;
+	d1 = 0;
+	n1 = 1;
+	d0 = 1;
+	for (;;) {
+		unsigned long t, a;
+
+		if (n1 > max_numerator || d1 > max_denominator) {
+			n1 = n0;
+			d1 = d0;
+			break;
+		}
+		if (d == 0)
+			break;
+		t = d;
+		a = n / d;
+		d = n % d;
+		n = t;
+		t = n0 + a * n1;
+		n0 = n1;
+		n1 = t;
+		t = d0 + a * d1;
+		d0 = d1;
+		d1 = t;
+	}
+	*best_numerator = n1;
+	*best_denominator = d1;
+}
+
+static int rk3528_armclk_set_clk(struct rk3528_clk_priv *priv, ulong new_rate)
+{
+	const struct rockchip_cpu_rate_table *rate;
+	struct rk3528_cru *cru = priv->cru;
+	ulong old_rate;
+
+	rate = rockchip_get_cpu_settings(rk3528_cpu_rates, new_rate);
+	if (!rate) {
+		printf("%s unsupported rate\n", __func__);
+		return -EINVAL;
+	}
+
+	/*
+	 * set up dependent divisors for DBG and ACLK clocks.
+	 */
+	old_rate = rockchip_pll_get_rate(&rk3528_pll_clks[APLL], priv->cru, APLL);
+	if (old_rate > new_rate) {
+		if (rockchip_pll_set_rate(&rk3528_pll_clks[APLL],
+					  priv->cru, APLL, new_rate))
+			return -EINVAL;
+
+		rk_clrsetreg(&cru->clksel_con[40], RK3528_DIV_PCLK_DBG_MASK,
+			     rate->pclk_div << RK3528_DIV_PCLK_DBG_SHIFT);
+
+		rk_clrsetreg(&cru->clksel_con[39], RK3528_DIV_ACLK_M_CORE_MASK,
+			     rate->aclk_div << RK3528_DIV_ACLK_M_CORE_SHIFT);
+	} else if (old_rate < new_rate) {
+		rk_clrsetreg(&cru->clksel_con[40], RK3528_DIV_PCLK_DBG_MASK,
+			     rate->pclk_div << RK3528_DIV_PCLK_DBG_SHIFT);
+
+		rk_clrsetreg(&cru->clksel_con[39], RK3528_DIV_ACLK_M_CORE_MASK,
+			     rate->aclk_div << RK3528_DIV_ACLK_M_CORE_SHIFT);
+
+		if (rockchip_pll_set_rate(&rk3528_pll_clks[APLL],
+					  priv->cru, APLL, new_rate))
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static ulong rk3528_ppll_matrix_get_rate(struct rk3528_clk_priv *priv,
+					 ulong clk_id)
+{
+	struct rk3528_cru *cru = priv->cru;
+	u32 div, mask, shift;
+	void *reg;
+
+	switch (clk_id) {
+	case CLK_PPLL_50M_MATRIX:
+	case CLK_GMAC1_RMII_VPU:
+		mask = PCIE_CLK_MATRIX_50M_SRC_DIV_MASK;
+		shift = PCIE_CLK_MATRIX_50M_SRC_DIV_SHIFT;
+		reg = &cru->pcieclksel_con[1];
+		break;
+
+	case CLK_PPLL_100M_MATRIX:
+		mask = PCIE_CLK_MATRIX_100M_SRC_DIV_MASK;
+		shift = PCIE_CLK_MATRIX_100M_SRC_DIV_SHIFT;
+		reg = &cru->pcieclksel_con[1];
+		break;
+
+	case CLK_PPLL_125M_MATRIX:
+	case CLK_GMAC1_SRC_VPU:
+		mask = CLK_MATRIX_125M_SRC_DIV_MASK;
+		shift = CLK_MATRIX_125M_SRC_DIV_SHIFT;
+		reg = &cru->clksel_con[60];
+		break;
+
+	case CLK_GMAC1_VPU_25M:
+		mask = CLK_MATRIX_25M_SRC_DIV_MASK;
+		shift = CLK_MATRIX_25M_SRC_DIV_SHIFT;
+		reg = &cru->clksel_con[60];
+		break;
+	default:
+		return -ENOENT;
+	}
+
+	div = (readl(reg) & mask) >> shift;
+
+	return DIV_TO_RATE(priv->ppll_hz, div);
+}
+
+static ulong rk3528_ppll_matrix_set_rate(struct rk3528_clk_priv *priv,
+					 ulong clk_id, ulong rate)
+{
+	struct rk3528_cru *cru = priv->cru;
+	u32 id, div, mask, shift;
+	u8 is_pciecru = 0;
+
+	switch (clk_id) {
+	case CLK_PPLL_50M_MATRIX:
+		id = 1;
+		mask = PCIE_CLK_MATRIX_50M_SRC_DIV_MASK;
+		shift = PCIE_CLK_MATRIX_50M_SRC_DIV_SHIFT;
+		is_pciecru = 1;
+		break;
+
+	case CLK_PPLL_100M_MATRIX:
+		id = 1;
+		mask = PCIE_CLK_MATRIX_100M_SRC_DIV_MASK;
+		shift = PCIE_CLK_MATRIX_100M_SRC_DIV_SHIFT;
+		is_pciecru = 1;
+		break;
+
+	case CLK_PPLL_125M_MATRIX:
+		id = 60;
+		mask = CLK_MATRIX_125M_SRC_DIV_MASK;
+		shift = CLK_MATRIX_125M_SRC_DIV_SHIFT;
+		break;
+	case CLK_GMAC1_VPU_25M:
+		id = 60;
+		mask = CLK_MATRIX_25M_SRC_DIV_MASK;
+		shift = CLK_MATRIX_25M_SRC_DIV_SHIFT;
+		break;
+	default:
+		return -ENOENT;
+	}
+
+	div = DIV_ROUND_UP(priv->ppll_hz, rate);
+	if (is_pciecru)
+		rk_clrsetreg(&cru->pcieclksel_con[id], mask, (div - 1) << shift);
+	else
+		rk_clrsetreg(&cru->clksel_con[id], mask, (div - 1) << shift);
+
+	return rk3528_ppll_matrix_get_rate(priv, clk_id);
+}
+
+static ulong rk3528_cgpll_matrix_get_rate(struct rk3528_clk_priv *priv,
+					  ulong clk_id)
+{
+	struct rk3528_cru *cru = priv->cru;
+	u32 sel, div, mask, shift, con;
+	u32 sel_mask = 0, sel_shift;
+	u8 is_gpll_parent = 1;
+	u8 is_halfdiv = 0;
+	ulong prate;
+
+	switch (clk_id) {
+	case CLK_MATRIX_50M_SRC:
+		con = 0;
+		mask = CLK_MATRIX_50M_SRC_DIV_MASK;
+		shift = CLK_MATRIX_50M_SRC_DIV_SHIFT;
+		is_gpll_parent = 0;
+		break;
+
+	case CLK_MATRIX_100M_SRC:
+		con = 0;
+		mask = CLK_MATRIX_100M_SRC_DIV_MASK;
+		shift = CLK_MATRIX_100M_SRC_DIV_SHIFT;
+		is_gpll_parent = 0;
+		break;
+
+	case CLK_MATRIX_150M_SRC:
+		con = 1;
+		mask = CLK_MATRIX_150M_SRC_DIV_MASK;
+		shift = CLK_MATRIX_150M_SRC_DIV_SHIFT;
+		break;
+
+	case CLK_MATRIX_200M_SRC:
+		con = 1;
+		mask = CLK_MATRIX_200M_SRC_DIV_MASK;
+		shift = CLK_MATRIX_200M_SRC_DIV_SHIFT;
+		break;
+
+	case CLK_MATRIX_250M_SRC:
+		con = 1;
+		mask = CLK_MATRIX_250M_SRC_DIV_MASK;
+		shift = CLK_MATRIX_250M_SRC_DIV_SHIFT;
+		sel_mask = CLK_MATRIX_250M_SRC_SEL_MASK;
+		sel_shift = CLK_MATRIX_250M_SRC_SEL_SHIFT;
+		break;
+
+	case CLK_MATRIX_300M_SRC:
+		con = 2;
+		mask = CLK_MATRIX_300M_SRC_DIV_MASK;
+		shift = CLK_MATRIX_300M_SRC_DIV_SHIFT;
+		break;
+
+	case CLK_MATRIX_339M_SRC:
+		con = 2;
+		mask = CLK_MATRIX_339M_SRC_DIV_MASK;
+		shift = CLK_MATRIX_339M_SRC_DIV_SHIFT;
+		is_halfdiv = 1;
+		break;
+
+	case CLK_MATRIX_400M_SRC:
+		con = 2;
+		mask = CLK_MATRIX_400M_SRC_DIV_MASK;
+		shift = CLK_MATRIX_400M_SRC_DIV_SHIFT;
+		break;
+
+	case CLK_MATRIX_500M_SRC:
+		con = 3;
+		mask = CLK_MATRIX_500M_SRC_DIV_MASK;
+		shift = CLK_MATRIX_500M_SRC_DIV_SHIFT;
+		sel_mask = CLK_MATRIX_500M_SRC_SEL_MASK;
+		sel_shift = CLK_MATRIX_500M_SRC_SEL_SHIFT;
+		break;
+
+	case CLK_MATRIX_600M_SRC:
+		con = 4;
+		mask = CLK_MATRIX_600M_SRC_DIV_MASK;
+		shift = CLK_MATRIX_600M_SRC_DIV_SHIFT;
+		break;
+
+	case ACLK_BUS_VOPGL_ROOT:
+	case ACLK_BUS_VOPGL_BIU:
+		con = 43;
+		mask = ACLK_BUS_VOPGL_ROOT_DIV_MASK;
+		shift = ACLK_BUS_VOPGL_ROOT_DIV_SHIFT;
+		break;
+
+	default:
+		return -ENOENT;
+	}
+
+	if (sel_mask) {
+		sel = (readl(&cru->clksel_con[con]) & sel_mask) >> sel_shift;
+		if (sel == CLK_MATRIX_250M_SRC_SEL_CLK_GPLL_MUX) // TODO
+			prate = priv->gpll_hz;
+		else
+			prate = priv->cpll_hz;
+	} else {
+		if (is_gpll_parent)
+			prate = priv->gpll_hz;
+		else
+			prate = priv->cpll_hz;
+	}
+
+	div = (readl(&cru->clksel_con[con]) & mask) >> shift;
+
+	/* NOTE: '-1' to balance the DIV_TO_RATE() 'div+1' */
+	return is_halfdiv ? DIV_TO_RATE(prate * 2, (3 + 2 * div) - 1) : DIV_TO_RATE(prate, div);
+}
+
+static ulong rk3528_cgpll_matrix_set_rate(struct rk3528_clk_priv *priv,
+					  ulong clk_id, ulong rate)
+{
+	struct rk3528_cru *cru = priv->cru;
+	u32 sel, div, mask, shift, con;
+	u32 sel_mask = 0, sel_shift;
+	u8 is_gpll_parent = 1;
+	u8 is_halfdiv = 0;
+	ulong prate = 0;
+
+	switch (clk_id) {
+	case CLK_MATRIX_50M_SRC:
+		con = 0;
+		mask = CLK_MATRIX_50M_SRC_DIV_MASK;
+		shift = CLK_MATRIX_50M_SRC_DIV_SHIFT;
+		is_gpll_parent = 0;
+		break;
+
+	case CLK_MATRIX_100M_SRC:
+		con = 0;
+		mask = CLK_MATRIX_100M_SRC_DIV_MASK;
+		shift = CLK_MATRIX_100M_SRC_DIV_SHIFT;
+		is_gpll_parent = 0;
+		break;
+
+	case CLK_MATRIX_150M_SRC:
+		con = 1;
+		mask = CLK_MATRIX_150M_SRC_DIV_MASK;
+		shift = CLK_MATRIX_150M_SRC_DIV_SHIFT;
+		break;
+
+	case CLK_MATRIX_200M_SRC:
+		con = 1;
+		mask = CLK_MATRIX_200M_SRC_DIV_MASK;
+		shift = CLK_MATRIX_200M_SRC_DIV_SHIFT;
+		break;
+
+	case CLK_MATRIX_250M_SRC:
+		con = 1;
+		mask = CLK_MATRIX_250M_SRC_DIV_MASK;
+		shift = CLK_MATRIX_250M_SRC_DIV_SHIFT;
+		sel_mask = CLK_MATRIX_250M_SRC_SEL_MASK;
+		sel_shift = CLK_MATRIX_250M_SRC_SEL_SHIFT;
+		break;
+
+	case CLK_MATRIX_300M_SRC:
+		con = 2;
+		mask = CLK_MATRIX_300M_SRC_DIV_MASK;
+		shift = CLK_MATRIX_300M_SRC_DIV_SHIFT;
+		break;
+
+	case CLK_MATRIX_339M_SRC:
+		con = 2;
+		mask = CLK_MATRIX_339M_SRC_DIV_MASK;
+		shift = CLK_MATRIX_339M_SRC_DIV_SHIFT;
+		is_halfdiv = 1;
+		break;
+
+	case CLK_MATRIX_400M_SRC:
+		con = 2;
+		mask = CLK_MATRIX_400M_SRC_DIV_MASK;
+		shift = CLK_MATRIX_400M_SRC_DIV_SHIFT;
+		break;
+
+	case CLK_MATRIX_500M_SRC:
+		con = 3;
+		mask = CLK_MATRIX_500M_SRC_DIV_MASK;
+		shift = CLK_MATRIX_500M_SRC_DIV_SHIFT;
+		sel_mask = CLK_MATRIX_500M_SRC_SEL_MASK;
+		sel_shift = CLK_MATRIX_500M_SRC_SEL_SHIFT;
+		break;
+
+	case CLK_MATRIX_600M_SRC:
+		con = 4;
+		mask = CLK_MATRIX_600M_SRC_DIV_MASK;
+		shift = CLK_MATRIX_600M_SRC_DIV_SHIFT;
+		break;
+
+	case ACLK_BUS_VOPGL_ROOT:
+	case ACLK_BUS_VOPGL_BIU:
+		con = 43;
+		mask = ACLK_BUS_VOPGL_ROOT_DIV_MASK;
+		shift = ACLK_BUS_VOPGL_ROOT_DIV_SHIFT;
+		break;
+
+	default:
+		return -ENOENT;
+	}
+
+	if (sel_mask) {
+		if (priv->gpll_hz % rate == 0) {
+			sel = CLK_MATRIX_250M_SRC_SEL_CLK_GPLL_MUX; // TODO
+			prate = priv->gpll_hz;
+		} else {
+			sel = CLK_MATRIX_250M_SRC_SEL_CLK_CPLL_MUX;
+			prate = priv->cpll_hz;
+		}
+	} else {
+		if (is_gpll_parent)
+			prate = priv->gpll_hz;
+		else
+			prate = priv->cpll_hz;
+	}
+
+	if (is_halfdiv)
+		/* NOTE: '+1' to balance the following rk_clrsetreg() 'div-1' */
+		div = DIV_ROUND_UP((prate * 2) - (3 * rate), 2 * rate) + 1;
+	else
+		div = DIV_ROUND_UP(prate, rate);
+
+	rk_clrsetreg(&cru->clksel_con[con], mask, (div - 1) << shift);
+	if (sel_mask)
+		rk_clrsetreg(&cru->clksel_con[con], sel_mask, sel << sel_shift);
+
+	return rk3528_cgpll_matrix_get_rate(priv, clk_id);
+}
+
+static ulong rk3528_i2c_get_clk(struct rk3528_clk_priv *priv, ulong clk_id)
+{
+	struct rk3528_cru *cru = priv->cru;
+	u32 id, sel, con, mask, shift;
+	u8 is_pmucru = 0;
+	ulong rate;
+
+	switch (clk_id) {
+	case CLK_I2C0:
+		id = 79;
+		mask = CLK_I2C0_SEL_MASK;
+		shift = CLK_I2C0_SEL_SHIFT;
+		break;
+
+	case CLK_I2C1:
+		id = 79;
+		mask = CLK_I2C1_SEL_MASK;
+		shift = CLK_I2C1_SEL_SHIFT;
+		break;
+
+	case CLK_I2C2:
+		id = 0;
+		mask = CLK_I2C2_SEL_MASK;
+		shift = CLK_I2C2_SEL_SHIFT;
+		is_pmucru = 1;
+		break;
+
+	case CLK_I2C3:
+		id = 63;
+		mask = CLK_I2C3_SEL_MASK;
+		shift = CLK_I2C3_SEL_SHIFT;
+		break;
+
+	case CLK_I2C4:
+		id = 85;
+		mask = CLK_I2C4_SEL_MASK;
+		shift = CLK_I2C4_SEL_SHIFT;
+		break;
+
+	case CLK_I2C5:
+		id = 63;
+		mask = CLK_I2C5_SEL_MASK;
+		shift = CLK_I2C5_SEL_SHIFT;
+		break;
+
+	case CLK_I2C6:
+		id = 64;
+		mask = CLK_I2C6_SEL_MASK;
+		shift = CLK_I2C6_SEL_SHIFT;
+		break;
+
+	case CLK_I2C7:
+		id = 86;
+		mask = CLK_I2C7_SEL_MASK;
+		shift = CLK_I2C7_SEL_SHIFT;
+		break;
+
+	default:
+		return -ENOENT;
+	}
+
+	if (is_pmucru)
+		con = readl(&cru->pmuclksel_con[id]);
+	else
+		con = readl(&cru->clksel_con[id]);
+	sel = (con & mask) >> shift;
+	if (sel == CLK_I2C3_SEL_CLK_MATRIX_200M_SRC)
+		rate = 200 * MHz;
+	else if (sel == CLK_I2C3_SEL_CLK_MATRIX_100M_SRC)
+		rate = 100 * MHz;
+	else if (sel == CLK_I2C3_SEL_CLK_MATRIX_50M_SRC)
+		rate = 50 * MHz;
+	else
+		rate = OSC_HZ;
+
+	return rate;
+}
+
+static ulong rk3528_i2c_set_clk(struct rk3528_clk_priv *priv, ulong clk_id,
+				ulong rate)
+{
+	struct rk3528_cru *cru = priv->cru;
+	u32 id, sel, mask, shift;
+	u8 is_pmucru = 0;
+
+	if (rate >= 198 * MHz)
+		sel = CLK_I2C3_SEL_CLK_MATRIX_200M_SRC;
+	else if (rate >= 99 * MHz)
+		sel = CLK_I2C3_SEL_CLK_MATRIX_100M_SRC;
+	else if (rate >= 50 * MHz)
+		sel = CLK_I2C3_SEL_CLK_MATRIX_50M_SRC;
+	else
+		sel = CLK_I2C3_SEL_XIN_OSC0_FUNC;
+
+	switch (clk_id) {
+	case CLK_I2C0:
+		id = 79;
+		mask = CLK_I2C0_SEL_MASK;
+		shift = CLK_I2C0_SEL_SHIFT;
+		break;
+
+	case CLK_I2C1:
+		id = 79;
+		mask = CLK_I2C1_SEL_MASK;
+		shift = CLK_I2C1_SEL_SHIFT;
+		break;
+
+	case CLK_I2C2:
+		id = 0;
+		mask = CLK_I2C2_SEL_MASK;
+		shift = CLK_I2C2_SEL_SHIFT;
+		is_pmucru = 1;
+		break;
+
+	case CLK_I2C3:
+		id = 63;
+		mask = CLK_I2C3_SEL_MASK;
+		shift = CLK_I2C3_SEL_SHIFT;
+		break;
+
+	case CLK_I2C4:
+		id = 85;
+		mask = CLK_I2C4_SEL_MASK;
+		shift = CLK_I2C4_SEL_SHIFT;
+		break;
+
+	case CLK_I2C5:
+		id = 63;
+		mask = CLK_I2C5_SEL_MASK;
+		shift = CLK_I2C5_SEL_SHIFT;
+
+	case CLK_I2C6:
+		id = 64;
+		mask = CLK_I2C6_SEL_MASK;
+		shift = CLK_I2C6_SEL_SHIFT;
+		break;
+
+	case CLK_I2C7:
+		id = 86;
+		mask = CLK_I2C7_SEL_MASK;
+		shift = CLK_I2C7_SEL_SHIFT;
+		break;
+
+	default:
+		return -ENOENT;
+	}
+
+	if (is_pmucru)
+		rk_clrsetreg(&cru->pmuclksel_con[id], mask, sel << shift);
+	else
+		rk_clrsetreg(&cru->clksel_con[id], mask, sel << shift);
+
+	return rk3528_i2c_get_clk(priv, clk_id);
+}
+
+static ulong rk3528_spi_get_clk(struct rk3528_clk_priv *priv, ulong clk_id)
+{
+	struct rk3528_cru *cru = priv->cru;
+	u32 id, sel, con, mask, shift;
+	ulong rate;
+
+	switch (clk_id) {
+	case CLK_SPI0:
+		id = 79;
+		mask = CLK_SPI0_SEL_MASK;
+		shift = CLK_SPI0_SEL_SHIFT;
+		break;
+
+	case CLK_SPI1:
+		id = 63;
+		mask = CLK_SPI1_SEL_MASK;
+		shift = CLK_SPI1_SEL_SHIFT;
+		break;
+	default:
+		return -ENOENT;
+	}
+
+	con = readl(&cru->clksel_con[id]);
+	sel = (con & mask) >> shift;
+	if (sel == CLK_SPI1_SEL_CLK_MATRIX_200M_SRC)
+		rate = 200 * MHz;
+	else if (sel == CLK_SPI1_SEL_CLK_MATRIX_100M_SRC)
+		rate = 100 * MHz;
+	else if (sel == CLK_SPI1_SEL_CLK_MATRIX_50M_SRC)
+		rate = 50 * MHz;
+	else
+		rate = OSC_HZ;
+
+	return rate;
+}
+
+static ulong rk3528_spi_set_clk(struct rk3528_clk_priv *priv,
+				ulong clk_id, ulong rate)
+{
+	struct rk3528_cru *cru = priv->cru;
+	u32 id, sel, mask, shift;
+
+	if (rate >= 198 * MHz)
+		sel = CLK_SPI1_SEL_CLK_MATRIX_200M_SRC;
+	else if (rate >= 99 * MHz)
+		sel = CLK_SPI1_SEL_CLK_MATRIX_100M_SRC;
+	else if (rate >= 50 * MHz)
+		sel = CLK_SPI1_SEL_CLK_MATRIX_50M_SRC;
+	else
+		sel = CLK_SPI1_SEL_XIN_OSC0_FUNC;
+
+	switch (clk_id) {
+	case CLK_SPI0:
+		id = 79;
+		mask = CLK_SPI0_SEL_MASK;
+		shift = CLK_SPI0_SEL_SHIFT;
+		break;
+
+	case CLK_SPI1:
+		id = 63;
+		mask = CLK_SPI1_SEL_MASK;
+		shift = CLK_SPI1_SEL_SHIFT;
+		break;
+	default:
+		return -ENOENT;
+	}
+
+	rk_clrsetreg(&cru->clksel_con[id], mask, sel << shift);
+
+	return rk3528_spi_get_clk(priv, clk_id);
+}
+
+static ulong rk3528_pwm_get_clk(struct rk3528_clk_priv *priv, ulong clk_id)
+{
+	struct rk3528_cru *cru = priv->cru;
+	u32 id, sel, con, mask, shift;
+	ulong rate;
+
+	switch (clk_id) {
+	case CLK_PWM0:
+		id = 44;
+		mask = CLK_PWM0_SEL_MASK;
+		shift = CLK_PWM0_SEL_SHIFT;
+		break;
+
+	case CLK_PWM1:
+		id = 44;
+		mask = CLK_PWM1_SEL_MASK;
+		shift = CLK_PWM1_SEL_SHIFT;
+		break;
+
+	default:
+		return -ENOENT;
+	}
+
+	con = readl(&cru->clksel_con[id]);
+	sel = (con & mask) >> shift;
+	if (sel == CLK_PWM0_SEL_CLK_MATRIX_100M_SRC)
+		rate = 100 * MHz;
+	if (sel == CLK_PWM0_SEL_CLK_MATRIX_50M_SRC)
+		rate = 50 * MHz;
+	else
+		rate = OSC_HZ;
+
+	return rate;
+}
+
+static ulong rk3528_pwm_set_clk(struct rk3528_clk_priv *priv,
+				ulong clk_id, ulong rate)
+{
+	struct rk3528_cru *cru = priv->cru;
+	u32 id, sel, mask, shift;
+
+	if (rate >= 99 * MHz)
+		sel = CLK_PWM0_SEL_CLK_MATRIX_100M_SRC;
+	else if (rate >= 50 * MHz)
+		sel = CLK_PWM0_SEL_CLK_MATRIX_50M_SRC;
+	else
+		sel = CLK_PWM0_SEL_XIN_OSC0_FUNC;
+
+	switch (clk_id) {
+	case CLK_PWM0:
+		id = 44;
+		mask = CLK_PWM0_SEL_MASK;
+		shift = CLK_PWM0_SEL_SHIFT;
+		break;
+
+	case CLK_PWM1:
+		id = 44;
+		mask = CLK_PWM1_SEL_MASK;
+		shift = CLK_PWM1_SEL_SHIFT;
+		break;
+
+	default:
+		return -ENOENT;
+	}
+
+	rk_clrsetreg(&cru->clksel_con[id], mask, sel << shift);
+
+	return rk3528_pwm_get_clk(priv, clk_id);
+}
+
+static ulong rk3528_adc_get_clk(struct rk3528_clk_priv *priv, ulong clk_id)
+{
+	struct rk3528_cru *cru = priv->cru;
+	u32 div, con;
+
+	con = readl(&cru->clksel_con[74]);
+	switch (clk_id) {
+	case CLK_SARADC:
+		div = (con & CLK_SARADC_DIV_MASK) >>
+			CLK_SARADC_DIV_SHIFT;
+		break;
+
+	case CLK_TSADC_TSEN:
+		div = (con & CLK_TSADC_TSEN_DIV_MASK) >>
+			CLK_TSADC_TSEN_DIV_SHIFT;
+		break;
+
+	case CLK_TSADC:
+		div = (con & CLK_TSADC_DIV_MASK) >>
+			CLK_TSADC_DIV_SHIFT;
+		break;
+
+	default:
+		return -ENOENT;
+	}
+
+	return DIV_TO_RATE(OSC_HZ, div);
+}
+
+static ulong rk3528_adc_set_clk(struct rk3528_clk_priv *priv,
+				ulong clk_id, ulong rate)
+{
+	struct rk3528_cru *cru = priv->cru;
+	u32 div, mask, shift;
+
+	switch (clk_id) {
+	case CLK_SARADC:
+		mask = CLK_SARADC_DIV_MASK;
+		shift =	CLK_SARADC_DIV_SHIFT;
+		break;
+
+	case CLK_TSADC_TSEN:
+		mask = CLK_TSADC_TSEN_DIV_MASK;
+		shift =	CLK_TSADC_TSEN_DIV_SHIFT;
+		break;
+
+	case CLK_TSADC:
+		mask = CLK_TSADC_DIV_MASK;
+		shift =	CLK_TSADC_DIV_SHIFT;
+		break;
+
+	default:
+		return -ENOENT;
+	}
+
+	div = DIV_ROUND_UP(OSC_HZ, rate);
+	rk_clrsetreg(&cru->clksel_con[74], mask, (div - 1) << shift);
+
+	return rk3528_adc_get_clk(priv, clk_id);
+}
+
+static ulong rk3528_sdmmc_get_clk(struct rk3528_clk_priv *priv, ulong clk_id)
+{
+	struct rk3528_cru *cru = priv->cru;
+	u32 div, sel, con;
+	ulong prate;
+
+	con = readl(&cru->clksel_con[85]);
+	div = (con & CCLK_SRC_SDMMC0_DIV_MASK) >>
+		CCLK_SRC_SDMMC0_DIV_SHIFT;
+	sel = (con & CCLK_SRC_SDMMC0_SEL_MASK) >>
+		CCLK_SRC_SDMMC0_SEL_SHIFT;
+
+	if (sel == CCLK_SRC_SDMMC0_SEL_CLK_GPLL_MUX)
+		prate = priv->gpll_hz;
+	else if (sel == CCLK_SRC_SDMMC0_SEL_CLK_CPLL_MUX)
+		prate = priv->cpll_hz;
+	else
+		prate = OSC_HZ;
+
+	return DIV_TO_RATE(prate, div);
+}
+
+static ulong rk3528_sdmmc_set_clk(struct rk3528_clk_priv *priv,
+				  ulong clk_id, ulong rate)
+{
+	struct rk3528_cru *cru = priv->cru;
+	u32 div, sel;
+
+	if (OSC_HZ % rate == 0) {
+		div = DIV_ROUND_UP(OSC_HZ, rate);
+		sel = CCLK_SRC_SDMMC0_SEL_XIN_OSC0_FUNC;
+	} else if ((priv->cpll_hz % rate) == 0) {
+		div = DIV_ROUND_UP(priv->cpll_hz, rate);
+		sel = CCLK_SRC_SDMMC0_SEL_CLK_CPLL_MUX;
+	} else {
+		div = DIV_ROUND_UP(priv->gpll_hz, rate);
+		sel = CCLK_SRC_SDMMC0_SEL_CLK_GPLL_MUX;
+	}
+
+	assert(div - 1 <= 63);
+	rk_clrsetreg(&cru->clksel_con[85],
+		     CCLK_SRC_SDMMC0_SEL_MASK |
+		     CCLK_SRC_SDMMC0_DIV_MASK,
+		     sel << CCLK_SRC_SDMMC0_SEL_SHIFT |
+		     (div - 1) << CCLK_SRC_SDMMC0_DIV_SHIFT);
+
+	return rk3528_sdmmc_get_clk(priv, clk_id);
+}
+
+static ulong rk3528_sfc_get_clk(struct rk3528_clk_priv *priv)
+{
+	struct rk3528_cru *cru = priv->cru;
+	u32 div, sel, con, parent;
+
+	con = readl(&cru->clksel_con[61]);
+	div = (con & SCLK_SFC_DIV_MASK) >>
+		SCLK_SFC_DIV_SHIFT;
+	sel = (con & SCLK_SFC_SEL_MASK) >>
+		SCLK_SFC_SEL_SHIFT;
+	if (sel == SCLK_SFC_SEL_CLK_GPLL_MUX)
+		parent = priv->gpll_hz;
+	else if (sel == SCLK_SFC_SEL_CLK_CPLL_MUX)
+		parent = priv->cpll_hz;
+	else
+		parent = OSC_HZ;
+
+	return DIV_TO_RATE(parent, div);
+}
+
+static ulong rk3528_sfc_set_clk(struct rk3528_clk_priv *priv, ulong rate)
+{
+	struct rk3528_cru *cru = priv->cru;
+	int div, sel;
+
+	if (OSC_HZ % rate == 0) {
+		div = DIV_ROUND_UP(OSC_HZ, rate);
+		sel = SCLK_SFC_SEL_XIN_OSC0_FUNC;
+	} else if ((priv->cpll_hz % rate) == 0) {
+		div = DIV_ROUND_UP(priv->cpll_hz, rate);
+		sel = SCLK_SFC_SEL_CLK_CPLL_MUX;
+	} else {
+		div = DIV_ROUND_UP(priv->gpll_hz, rate);
+		sel = SCLK_SFC_SEL_CLK_GPLL_MUX;
+	}
+
+	assert(div - 1 <= 63);
+	rk_clrsetreg(&cru->clksel_con[61],
+		     SCLK_SFC_SEL_MASK |
+		     SCLK_SFC_DIV_MASK,
+		     sel << SCLK_SFC_SEL_SHIFT |
+		     (div - 1) << SCLK_SFC_DIV_SHIFT);
+
+	return rk3528_sfc_get_clk(priv);
+}
+
+static ulong rk3528_emmc_get_clk(struct rk3528_clk_priv *priv)
+{
+	struct rk3528_cru *cru = priv->cru;
+	u32 div, sel, con, parent;
+
+	con = readl(&cru->clksel_con[62]);
+	div = (con & CCLK_SRC_EMMC_DIV_MASK) >>
+		CCLK_SRC_EMMC_DIV_SHIFT;
+	sel = (con & CCLK_SRC_EMMC_SEL_MASK) >>
+		CCLK_SRC_EMMC_SEL_SHIFT;
+
+	if (sel == CCLK_SRC_EMMC_SEL_CLK_GPLL_MUX)
+		parent = priv->gpll_hz;
+	else if (sel == CCLK_SRC_EMMC_SEL_CLK_CPLL_MUX)
+		parent = priv->cpll_hz;
+	else
+		parent = OSC_HZ;
+
+	return DIV_TO_RATE(parent, div);
+}
+
+static ulong rk3528_emmc_set_clk(struct rk3528_clk_priv *priv, ulong rate)
+{
+	struct rk3528_cru *cru = priv->cru;
+	u32 div, sel;
+
+	if (OSC_HZ % rate == 0) {
+		div = DIV_ROUND_UP(OSC_HZ, rate);
+		sel = CCLK_SRC_EMMC_SEL_XIN_OSC0_FUNC;
+	} else if ((priv->cpll_hz % rate) == 0) {
+		div = DIV_ROUND_UP(priv->cpll_hz, rate);
+		sel = CCLK_SRC_EMMC_SEL_CLK_CPLL_MUX;
+	} else {
+		div = DIV_ROUND_UP(priv->gpll_hz, rate);
+		sel = CCLK_SRC_EMMC_SEL_CLK_GPLL_MUX;
+	}
+
+	assert(div - 1 <= 63);
+	rk_clrsetreg(&cru->clksel_con[62],
+		     CCLK_SRC_EMMC_SEL_MASK |
+		     CCLK_SRC_EMMC_DIV_MASK,
+		     sel << CCLK_SRC_EMMC_SEL_SHIFT |
+		     (div - 1) << CCLK_SRC_EMMC_DIV_SHIFT);
+
+	return rk3528_emmc_get_clk(priv);
+}
+
+static ulong rk3528_dclk_vop_get_clk(struct rk3528_clk_priv *priv, ulong clk_id)
+{
+	struct rk3528_cru *cru = priv->cru;
+	u32 div_mask, div_shift;
+	u32 sel_mask, sel_shift;
+	u32 id, con, sel, div;
+	ulong prate;
+
+	switch (clk_id) {
+	case DCLK_VOP0:
+		id = 32;
+		sel_mask = DCLK_VOP_SRC0_SEL_MASK;
+		sel_shift = DCLK_VOP_SRC0_SEL_SHIFT;
+		/* FIXME if need src: clk_hdmiphy_pixel_io */
+		div_mask = DCLK_VOP_SRC0_DIV_MASK;
+		div_shift = DCLK_VOP_SRC0_DIV_SHIFT;
+		break;
+
+	case DCLK_VOP1:
+		id = 33;
+		sel_mask = DCLK_VOP_SRC1_SEL_MASK;
+		sel_shift = DCLK_VOP_SRC1_SEL_SHIFT;
+		div_mask = DCLK_VOP_SRC1_DIV_MASK;
+		div_shift = DCLK_VOP_SRC1_DIV_SHIFT;
+		break;
+
+	default:
+		return -ENOENT;
+	}
+
+	con = readl(&cru->clksel_con[id]);
+	div = (con & div_mask) >> div_shift;
+	sel = (con & sel_mask) >> sel_shift;
+	if (sel == DCLK_VOP_SRC_SEL_CLK_GPLL_MUX)
+		prate = priv->gpll_hz;
+	else
+		prate = priv->cpll_hz;
+
+	return DIV_TO_RATE(prate, div);
+}
+
+static ulong rk3528_dclk_vop_set_clk(struct rk3528_clk_priv *priv,
+				     ulong clk_id, ulong rate)
+{
+	struct rk3528_cru *cru = priv->cru;
+	u32 div_mask, div_shift;
+	u32 sel_mask, sel_shift;
+	u32 id, sel, div;
+	ulong prate;
+
+	switch (clk_id) {
+	case DCLK_VOP0:
+		id = 32;
+		sel_mask = DCLK_VOP_SRC0_SEL_MASK;
+		sel_shift = DCLK_VOP_SRC0_SEL_SHIFT;
+		/* FIXME if need src: clk_hdmiphy_pixel_io */
+		div_mask = DCLK_VOP_SRC0_DIV_MASK;
+		div_shift = DCLK_VOP_SRC0_DIV_SHIFT;
+		break;
+
+	case DCLK_VOP1:
+		id = 33;
+		sel_mask = DCLK_VOP_SRC1_SEL_MASK;
+		sel_shift = DCLK_VOP_SRC1_SEL_SHIFT;
+		div_mask = DCLK_VOP_SRC1_DIV_MASK;
+		div_shift = DCLK_VOP_SRC1_DIV_SHIFT;
+		break;
+
+	default:
+		return -ENOENT;
+	}
+
+	if ((priv->gpll_hz % rate) == 0) {
+		prate = priv->gpll_hz;
+		sel = (DCLK_VOP_SRC_SEL_CLK_GPLL_MUX << sel_shift) & sel_mask;
+	} else {
+		prate = priv->cpll_hz;
+		sel = (DCLK_VOP_SRC_SEL_CLK_CPLL_MUX << sel_shift) & sel_mask;
+	}
+
+	div = ((DIV_ROUND_UP(prate, rate) - 1) << div_shift) & div_mask;
+	rk_clrsetreg(&cru->clksel_con[id], sel, div);
+
+	return rk3528_dclk_vop_get_clk(priv, clk_id);
+}
+
+static ulong rk3528_uart_get_rate(struct rk3528_clk_priv *priv, ulong clk_id)
+{
+	struct rk3528_cru *cru = priv->cru;
+	u32 sel_shift, sel_mask, div_shift, div_mask;
+	u32 sel, id, con, frac_div, div;
+	ulong m, n, rate;
+
+	switch (clk_id) {
+	case SCLK_UART0:
+		id = 6;
+		sel_shift = SCLK_UART0_SRC_SEL_SHIFT;
+		sel_mask = SCLK_UART0_SRC_SEL_MASK;
+		div_shift = CLK_UART0_SRC_DIV_SHIFT;
+		div_mask = CLK_UART0_SRC_DIV_MASK;
+		break;
+
+	case SCLK_UART1:
+		id = 8;
+		sel_shift = SCLK_UART1_SRC_SEL_SHIFT;
+		sel_mask = SCLK_UART1_SRC_SEL_MASK;
+		div_shift = CLK_UART1_SRC_DIV_SHIFT;
+		div_mask = CLK_UART1_SRC_DIV_MASK;
+		break;
+
+	case SCLK_UART2:
+		id = 10;
+		sel_shift = SCLK_UART2_SRC_SEL_SHIFT;
+		sel_mask = SCLK_UART2_SRC_SEL_MASK;
+		div_shift = CLK_UART2_SRC_DIV_SHIFT;
+		div_mask = CLK_UART2_SRC_DIV_MASK;
+		break;
+
+	case SCLK_UART3:
+		id = 12;
+		sel_shift = SCLK_UART3_SRC_SEL_SHIFT;
+		sel_mask = SCLK_UART3_SRC_SEL_MASK;
+		div_shift = CLK_UART3_SRC_DIV_SHIFT;
+		div_mask = CLK_UART3_SRC_DIV_MASK;
+		break;
+
+	case SCLK_UART4:
+		id = 14;
+		sel_shift = SCLK_UART4_SRC_SEL_SHIFT;
+		sel_mask = SCLK_UART4_SRC_SEL_MASK;
+		div_shift = CLK_UART4_SRC_DIV_SHIFT;
+		div_mask = CLK_UART4_SRC_DIV_MASK;
+		break;
+
+	case SCLK_UART5:
+		id = 16;
+		sel_shift = SCLK_UART5_SRC_SEL_SHIFT;
+		sel_mask = SCLK_UART5_SRC_SEL_MASK;
+		div_shift = CLK_UART5_SRC_DIV_SHIFT;
+		div_mask = CLK_UART5_SRC_DIV_MASK;
+		break;
+
+	case SCLK_UART6:
+		id = 18;
+		sel_shift = SCLK_UART6_SRC_SEL_SHIFT;
+		sel_mask = SCLK_UART6_SRC_SEL_MASK;
+		div_shift = CLK_UART6_SRC_DIV_SHIFT;
+		div_mask = CLK_UART6_SRC_DIV_MASK;
+		break;
+
+	case SCLK_UART7:
+		id = 20;
+		sel_shift = SCLK_UART7_SRC_SEL_SHIFT;
+		sel_mask = SCLK_UART7_SRC_SEL_MASK;
+		div_shift = CLK_UART7_SRC_DIV_SHIFT;
+		div_mask = CLK_UART7_SRC_DIV_MASK;
+		break;
+
+	default:
+		return -ENOENT;
+	}
+
+	con = readl(&cru->clksel_con[id - 2]);
+	div = (con & div_mask) >> div_shift;
+
+	con = readl(&cru->clksel_con[id]);
+	sel = (con & sel_mask) >> sel_shift;
+
+	if (sel == SCLK_UART0_SRC_SEL_CLK_UART0_SRC) {
+		rate = DIV_TO_RATE(priv->gpll_hz, div);
+	} else if (sel == SCLK_UART0_SRC_SEL_CLK_UART0_FRAC) {
+		frac_div = readl(&cru->clksel_con[id - 1]);
+		n = (frac_div & 0xffff0000) >> 16;
+		m = frac_div & 0x0000ffff;
+		rate = DIV_TO_RATE(priv->gpll_hz, div) * n / m;
+	} else {
+		rate = OSC_HZ;
+	}
+
+	return rate;
+}
+
+static ulong rk3528_uart_set_rate(struct rk3528_clk_priv *priv,
+				  ulong clk_id, ulong rate)
+{
+	struct rk3528_cru *cru = priv->cru;
+	u32 sel_shift, sel_mask, div_shift, div_mask;
+	u32 sel, id, div;
+	ulong m = 0, n = 0, val;
+
+	if (rate == OSC_HZ) {
+		sel = SCLK_UART0_SRC_SEL_XIN_OSC0_FUNC;
+		div = DIV_ROUND_UP(OSC_HZ, rate);
+	} else if (priv->gpll_hz % rate == 0) {
+		sel = SCLK_UART0_SRC_SEL_CLK_UART0_SRC;
+		div = DIV_ROUND_UP(priv->gpll_hz, rate);
+	} else {
+		sel = SCLK_UART0_SRC_SEL_CLK_UART0_FRAC;
+		div = 2;
+		rational_best_approximation(rate, priv->gpll_hz / div,
+					    GENMASK(16 - 1, 0),
+					    GENMASK(16 - 1, 0),
+					    &n, &m);
+	}
+
+	switch (clk_id) {
+	case SCLK_UART0:
+		id = 6;
+		sel_shift = SCLK_UART0_SRC_SEL_SHIFT;
+		sel_mask = SCLK_UART0_SRC_SEL_MASK;
+		div_shift = CLK_UART0_SRC_DIV_SHIFT;
+		div_mask = CLK_UART0_SRC_DIV_MASK;
+		break;
+
+	case SCLK_UART1:
+		id = 8;
+		sel_shift = SCLK_UART1_SRC_SEL_SHIFT;
+		sel_mask = SCLK_UART1_SRC_SEL_MASK;
+		div_shift = CLK_UART1_SRC_DIV_SHIFT;
+		div_mask = CLK_UART1_SRC_DIV_MASK;
+		break;
+
+	case SCLK_UART2:
+		id = 10;
+		sel_shift = SCLK_UART2_SRC_SEL_SHIFT;
+		sel_mask = SCLK_UART2_SRC_SEL_MASK;
+		div_shift = CLK_UART2_SRC_DIV_SHIFT;
+		div_mask = CLK_UART2_SRC_DIV_MASK;
+		break;
+
+	case SCLK_UART3:
+		id = 12;
+		sel_shift = SCLK_UART3_SRC_SEL_SHIFT;
+		sel_mask = SCLK_UART3_SRC_SEL_MASK;
+		div_shift = CLK_UART3_SRC_DIV_SHIFT;
+		div_mask = CLK_UART3_SRC_DIV_MASK;
+		break;
+
+	case SCLK_UART4:
+		id = 14;
+		sel_shift = SCLK_UART4_SRC_SEL_SHIFT;
+		sel_mask = SCLK_UART4_SRC_SEL_MASK;
+		div_shift = CLK_UART4_SRC_DIV_SHIFT;
+		div_mask = CLK_UART4_SRC_DIV_MASK;
+		break;
+
+	case SCLK_UART5:
+		id = 16;
+		sel_shift = SCLK_UART5_SRC_SEL_SHIFT;
+		sel_mask = SCLK_UART5_SRC_SEL_MASK;
+		div_shift = CLK_UART5_SRC_DIV_SHIFT;
+		div_mask = CLK_UART5_SRC_DIV_MASK;
+		break;
+
+	case SCLK_UART6:
+		id = 18;
+		sel_shift = SCLK_UART6_SRC_SEL_SHIFT;
+		sel_mask = SCLK_UART6_SRC_SEL_MASK;
+		div_shift = CLK_UART6_SRC_DIV_SHIFT;
+		div_mask = CLK_UART6_SRC_DIV_MASK;
+		break;
+
+	case SCLK_UART7:
+		id = 20;
+		sel_shift = SCLK_UART7_SRC_SEL_SHIFT;
+		sel_mask = SCLK_UART7_SRC_SEL_MASK;
+		div_shift = CLK_UART7_SRC_DIV_SHIFT;
+		div_mask = CLK_UART7_SRC_DIV_MASK;
+		break;
+
+	default:
+		return -ENOENT;
+	}
+
+	rk_clrsetreg(&cru->clksel_con[id - 2], div_mask, (div - 1) << div_shift);
+	rk_clrsetreg(&cru->clksel_con[id], sel_mask, sel << sel_shift);
+	if (m && n) {
+		val = n << 16 | m;
+		writel(val, &cru->clksel_con[id - 1]);
+	}
+
+	return rk3528_uart_get_rate(priv, clk_id);
+}
+
+static ulong rk3528_clk_get_rate(struct clk *clk)
+{
+	struct rk3528_clk_priv *priv = dev_get_priv(clk->dev);
+	ulong rate = 0;
+
+	if (!priv->gpll_hz || !priv->cpll_hz) {
+		printf("%s: gpll=%lu, cpll=%ld\n",
+		       __func__, priv->gpll_hz, priv->cpll_hz);
+		return -ENOENT;
+	}
+
+	switch (clk->id) {
+	case PLL_APLL:
+	case ARMCLK:
+		rate = rockchip_pll_get_rate(&rk3528_pll_clks[APLL], priv->cru,
+					     APLL);
+		break;
+	case PLL_CPLL:
+		rate = rockchip_pll_get_rate(&rk3528_pll_clks[CPLL], priv->cru,
+					     CPLL);
+		break;
+	case PLL_GPLL:
+		rate = rockchip_pll_get_rate(&rk3528_pll_clks[GPLL], priv->cru,
+					     GPLL);
+		break;
+
+	case PLL_PPLL:
+		rate = rockchip_pll_get_rate(&rk3528_pll_clks[PPLL], priv->cru,
+					     PPLL);
+		break;
+	case PLL_DPLL:
+		rate = rockchip_pll_get_rate(&rk3528_pll_clks[DPLL], priv->cru,
+					     DPLL);
+		break;
+
+	case TCLK_WDT_NS:
+		rate = OSC_HZ;
+		break;
+	case CLK_I2C0:
+	case CLK_I2C1:
+	case CLK_I2C2:
+	case CLK_I2C3:
+	case CLK_I2C4:
+	case CLK_I2C5:
+	case CLK_I2C6:
+	case CLK_I2C7:
+		rate = rk3528_i2c_get_clk(priv, clk->id);
+		break;
+	case CLK_SPI0:
+	case CLK_SPI1:
+		rate = rk3528_spi_get_clk(priv, clk->id);
+		break;
+	case CLK_PWM0:
+	case CLK_PWM1:
+		rate = rk3528_pwm_get_clk(priv, clk->id);
+		break;
+	case CLK_SARADC:
+	case CLK_TSADC:
+	case CLK_TSADC_TSEN:
+		rate = rk3528_adc_get_clk(priv, clk->id);
+		break;
+	case CCLK_SRC_EMMC:
+		rate = rk3528_emmc_get_clk(priv);
+		break;
+	case HCLK_SDMMC0:
+	case CCLK_SRC_SDMMC0:
+		rate = rk3528_sdmmc_get_clk(priv, clk->id);
+		break;
+	case SCLK_SFC:
+		rate = rk3528_sfc_get_clk(priv);
+		break;
+	case DCLK_VOP0:
+	case DCLK_VOP1:
+		rate = rk3528_dclk_vop_get_clk(priv, clk->id);
+		break;
+	case DCLK_CVBS:
+		rate = rk3528_dclk_vop_get_clk(priv, DCLK_VOP1) / 4;
+		break;
+	case DCLK_4X_CVBS:
+		rate = rk3528_dclk_vop_get_clk(priv, DCLK_VOP1);
+		break;
+	case SCLK_UART0:
+	case SCLK_UART1:
+	case SCLK_UART2:
+	case SCLK_UART3:
+	case SCLK_UART4:
+	case SCLK_UART5:
+	case SCLK_UART6:
+	case SCLK_UART7:
+		rate = rk3528_uart_get_rate(priv, clk->id);
+		break;
+	case CLK_MATRIX_50M_SRC:
+	case CLK_MATRIX_100M_SRC:
+	case CLK_MATRIX_150M_SRC:
+	case CLK_MATRIX_200M_SRC:
+	case CLK_MATRIX_250M_SRC:
+	case CLK_MATRIX_300M_SRC:
+	case CLK_MATRIX_339M_SRC:
+	case CLK_MATRIX_400M_SRC:
+	case CLK_MATRIX_500M_SRC:
+	case CLK_MATRIX_600M_SRC:
+	case ACLK_BUS_VOPGL_BIU:
+		rate = rk3528_cgpll_matrix_get_rate(priv, clk->id);
+		break;
+	case CLK_PPLL_50M_MATRIX:
+	case CLK_PPLL_100M_MATRIX:
+	case CLK_PPLL_125M_MATRIX:
+	case CLK_GMAC1_VPU_25M:
+	case CLK_GMAC1_RMII_VPU:
+	case CLK_GMAC1_SRC_VPU:
+		rate = rk3528_ppll_matrix_get_rate(priv, clk->id);
+		break;
+	default:
+		return -ENOENT;
+	}
+
+	return rate;
+};
+
+static ulong rk3528_clk_set_rate(struct clk *clk, ulong rate)
+{
+	struct rk3528_clk_priv *priv = dev_get_priv(clk->dev);
+	ulong ret = 0;
+
+	if (!priv->gpll_hz) {
+		printf("%s gpll=%lu\n", __func__, priv->gpll_hz);
+		return -ENOENT;
+	}
+
+	switch (clk->id) {
+	case PLL_APLL:
+	case ARMCLK:
+		if (priv->armclk_hz)
+			rk3528_armclk_set_clk(priv, rate);
+		priv->armclk_hz = rate;
+		break;
+	case PLL_CPLL:
+		ret = rockchip_pll_set_rate(&rk3528_pll_clks[CPLL], priv->cru,
+					    CPLL, rate);
+		priv->cpll_hz = rockchip_pll_get_rate(&rk3528_pll_clks[CPLL],
+						      priv->cru, CPLL);
+		break;
+	case PLL_GPLL:
+		ret = rockchip_pll_set_rate(&rk3528_pll_clks[GPLL], priv->cru,
+					    GPLL, rate);
+		priv->gpll_hz = rockchip_pll_get_rate(&rk3528_pll_clks[GPLL],
+						      priv->cru, GPLL);
+		break;
+	case PLL_PPLL:
+		ret = rockchip_pll_set_rate(&rk3528_pll_clks[PPLL], priv->cru,
+					    PPLL, rate);
+		priv->ppll_hz = rockchip_pll_get_rate(&rk3528_pll_clks[PPLL],
+						      priv->cru, PPLL);
+		break;
+	case TCLK_WDT_NS:
+		return (rate == OSC_HZ) ? 0 : -EINVAL;
+	case CLK_I2C0:
+	case CLK_I2C1:
+	case CLK_I2C2:
+	case CLK_I2C3:
+	case CLK_I2C4:
+	case CLK_I2C5:
+	case CLK_I2C6:
+	case CLK_I2C7:
+		ret = rk3528_i2c_set_clk(priv, clk->id, rate);
+		break;
+	case CLK_SPI0:
+	case CLK_SPI1:
+		ret = rk3528_spi_set_clk(priv, clk->id, rate);
+		break;
+	case CLK_PWM0:
+	case CLK_PWM1:
+		ret = rk3528_pwm_set_clk(priv, clk->id, rate);
+		break;
+	case CLK_SARADC:
+	case CLK_TSADC:
+	case CLK_TSADC_TSEN:
+		ret = rk3528_adc_set_clk(priv, clk->id, rate);
+		break;
+	case HCLK_SDMMC0:
+	case CCLK_SRC_SDMMC0:
+		ret = rk3528_sdmmc_set_clk(priv, clk->id, rate);
+		break;
+	case SCLK_SFC:
+		ret = rk3528_sfc_set_clk(priv, rate);
+		break;
+	case CCLK_SRC_EMMC:
+		ret = rk3528_emmc_set_clk(priv, rate);
+		break;
+	case DCLK_VOP0:
+	case DCLK_VOP1:
+		ret = rk3528_dclk_vop_set_clk(priv, clk->id, rate);
+		break;
+	case SCLK_UART0:
+	case SCLK_UART1:
+	case SCLK_UART2:
+	case SCLK_UART3:
+	case SCLK_UART4:
+	case SCLK_UART5:
+	case SCLK_UART6:
+	case SCLK_UART7:
+		ret = rk3528_uart_set_rate(priv, clk->id, rate);
+		break;
+	case CLK_MATRIX_50M_SRC:
+	case CLK_MATRIX_100M_SRC:
+	case CLK_MATRIX_150M_SRC:
+	case CLK_MATRIX_200M_SRC:
+	case CLK_MATRIX_250M_SRC:
+	case CLK_MATRIX_300M_SRC:
+	case CLK_MATRIX_339M_SRC:
+	case CLK_MATRIX_400M_SRC:
+	case CLK_MATRIX_500M_SRC:
+	case CLK_MATRIX_600M_SRC:
+	case ACLK_BUS_VOPGL_BIU:
+		ret = rk3528_cgpll_matrix_set_rate(priv, clk->id, rate);
+		break;
+	case CLK_PPLL_50M_MATRIX:
+	case CLK_PPLL_100M_MATRIX:
+	case CLK_PPLL_125M_MATRIX:
+	case CLK_GMAC1_VPU_25M:
+		ret = rk3528_ppll_matrix_set_rate(priv, clk->id, rate);
+		break;
+	case CLK_GMAC1_RMII_VPU:
+	case CLK_GMAC1_SRC_VPU:
+		/* dummy set */
+		ret = rk3528_ppll_matrix_get_rate(priv, clk->id);
+		break;
+	default:
+		return -ENOENT;
+	}
+
+	return ret;
+};
+
+static struct clk_ops rk3528_clk_ops = {
+	.get_rate = rk3528_clk_get_rate,
+	.set_rate = rk3528_clk_set_rate,
+};
+
+#ifdef CONFIG_XPL_BUILD
+
+#define COREGRF_BASE	0xff300000
+#define PVTPLL_CON0_L	0x0
+#define PVTPLL_CON0_H	0x4
+
+static int rk3528_cpu_pvtpll_set_rate(struct rk3528_clk_priv *priv, ulong rate)
+{
+	struct rk3528_cru *cru = priv->cru;
+	u32 length;
+
+	if (rate >= 1200000000)
+		length = 8;
+	else if (rate >= 1008000000)
+		length = 11;
+	else
+		length = 17;
+
+	/* set pclk dbg div to 9 */
+	rk_clrsetreg(&cru->clksel_con[40], RK3528_DIV_PCLK_DBG_MASK,
+		     9 << RK3528_DIV_PCLK_DBG_SHIFT);
+	/* set aclk_m_core div to 1 */
+	rk_clrsetreg(&cru->clksel_con[39], RK3528_DIV_ACLK_M_CORE_MASK,
+		     1 << RK3528_DIV_ACLK_M_CORE_SHIFT);
+
+	/* set ring sel = 1 */
+	writel(0x07000000 | (1 << 8), COREGRF_BASE + PVTPLL_CON0_L);
+	/* set length */
+	writel(0x007f0000 | length, COREGRF_BASE + PVTPLL_CON0_H);
+	/* enable pvtpll */
+	writel(0x00020002, COREGRF_BASE + PVTPLL_CON0_L);
+	/* start monitor */
+	writel(0x00010001, COREGRF_BASE + PVTPLL_CON0_L);
+
+	/* set core mux pvtpll */
+	writel(0x00010001, &cru->clksel_con[40]);
+	writel(0x00100010, &cru->clksel_con[39]);
+
+	/* set pclk dbg div to 8 */
+	rk_clrsetreg(&cru->clksel_con[40], RK3528_DIV_PCLK_DBG_MASK,
+		     8 << RK3528_DIV_PCLK_DBG_SHIFT);
+
+	return 0;
+}
+#endif
+
+static int rk3528_clk_init(struct rk3528_clk_priv *priv)
+{
+	int ret;
+
+	priv->sync_kernel = false;
+
+#ifdef CONFIG_XPL_BUILD
+	/*
+	 * BOOTROM:
+	 *	CPU 1902/2(postdiv1)=546M
+	 *	CPLL 996/2(postdiv1)=498M
+	 *	GPLL 1188/2(postdiv1)=594M
+	 *	   |-- clk_matrix_200m_src_div=1 => rate: 300M
+	 *	   |-- clk_matrix_300m_src_div=2 => rate: 200M
+	 *
+	 * Avoid overclocking when change GPLL rate:
+	 *	Change clk_matrix_200m_src_div to 5.
+	 *	Change clk_matrix_300m_src_div to 3.
+	 */
+	writel(0x01200120, &priv->cru->clksel_con[1]);
+	writel(0x00030003, &priv->cru->clksel_con[2]);
+
+	if (!priv->armclk_enter_hz) {
+		priv->armclk_enter_hz =
+			rockchip_pll_get_rate(&rk3528_pll_clks[APLL],
+					      priv->cru, APLL);
+		priv->armclk_init_hz = priv->armclk_enter_hz;
+	}
+
+	if (priv->armclk_init_hz != APLL_HZ) {
+		ret = rk3528_armclk_set_clk(priv, APLL_HZ);
+		if (!ret)
+			priv->armclk_init_hz = APLL_HZ;
+	}
+
+	if (!rk3528_cpu_pvtpll_set_rate(priv, CPU_PVTPLL_HZ)) {
+		debug("cpu pvtpll %d KHz\n", CPU_PVTPLL_HZ / 1000);
+		priv->armclk_init_hz = CPU_PVTPLL_HZ;
+	}
+#endif
+
+	if (priv->cpll_hz != CPLL_HZ) {
+		ret = rockchip_pll_set_rate(&rk3528_pll_clks[CPLL], priv->cru,
+					    CPLL, CPLL_HZ);
+		if (!ret)
+			priv->cpll_hz = CPLL_HZ;
+	}
+
+	if (priv->gpll_hz != GPLL_HZ) {
+		ret = rockchip_pll_set_rate(&rk3528_pll_clks[GPLL], priv->cru,
+					    GPLL, GPLL_HZ);
+		if (!ret)
+			priv->gpll_hz = GPLL_HZ;
+	}
+
+	if (priv->ppll_hz != PPLL_HZ) {
+		ret = rockchip_pll_set_rate(&rk3528_pll_clks[PPLL], priv->cru,
+					    PPLL, PPLL_HZ);
+		if (!ret)
+			priv->ppll_hz = PPLL_HZ;
+	}
+
+#ifdef CONFIG_XPL_BUILD
+	/* Init to override bootrom config */
+	rk3528_cgpll_matrix_set_rate(priv, CLK_MATRIX_50M_SRC,   50000000);
+	rk3528_cgpll_matrix_set_rate(priv, CLK_MATRIX_100M_SRC, 100000000);
+	rk3528_cgpll_matrix_set_rate(priv, CLK_MATRIX_150M_SRC, 150000000);
+	rk3528_cgpll_matrix_set_rate(priv, CLK_MATRIX_200M_SRC, 200000000);
+	rk3528_cgpll_matrix_set_rate(priv, CLK_MATRIX_250M_SRC, 250000000);
+	rk3528_cgpll_matrix_set_rate(priv, CLK_MATRIX_300M_SRC, 300000000);
+	rk3528_cgpll_matrix_set_rate(priv, CLK_MATRIX_339M_SRC, 340000000);
+	rk3528_cgpll_matrix_set_rate(priv, CLK_MATRIX_400M_SRC, 400000000);
+	rk3528_cgpll_matrix_set_rate(priv, CLK_MATRIX_500M_SRC, 500000000);
+	rk3528_cgpll_matrix_set_rate(priv, CLK_MATRIX_600M_SRC, 600000000);
+	rk3528_cgpll_matrix_set_rate(priv, ACLK_BUS_VOPGL_BIU,  500000000);
+
+	/* The default rate is 100Mhz, it's not friendly for remote IR module */
+	rk3528_pwm_set_clk(priv, CLK_PWM0, 24000000);
+	rk3528_pwm_set_clk(priv, CLK_PWM1, 24000000);
+#endif
+	return 0;
+}
+
+static int rk3528_clk_probe(struct udevice *dev)
+{
+	struct rk3528_clk_priv *priv = dev_get_priv(dev);
+	int ret;
+
+	ret = rk3528_clk_init(priv);
+	if (ret)
+		return ret;
+
+	/* Process 'assigned-{clocks/clock-parents/clock-rates}' properties */
+	ret = clk_set_defaults(dev, 1);
+	if (ret)
+		debug("%s clk_set_defaults failed %d\n", __func__, ret);
+	else
+		priv->sync_kernel = true;
+
+	return 0;
+}
+
+static int rk3528_clk_ofdata_to_platdata(struct udevice *dev)
+{
+	struct rk3528_clk_priv *priv = dev_get_priv(dev);
+
+	priv->cru = dev_read_addr_ptr(dev);
+
+	return 0;
+}
+
+static int rk3528_clk_bind(struct udevice *dev)
+{
+	struct udevice *sys_child;
+	struct sysreset_reg *priv;
+	int ret;
+
+	/* The reset driver does not have a device node, so bind it here */
+	ret = device_bind_driver(dev, "rockchip_sysreset", "sysreset",
+				 &sys_child);
+	if (ret) {
+		debug("Warning: No sysreset driver: ret=%d\n", ret);
+	} else {
+		priv = malloc(sizeof(struct sysreset_reg));
+		priv->glb_srst_fst_value = offsetof(struct rk3528_cru,
+						    glb_srst_fst);
+		priv->glb_srst_snd_value = offsetof(struct rk3528_cru,
+						    glb_srst_snd);
+		dev_set_priv(sys_child, priv);
+	}
+
+#if CONFIG_IS_ENABLED(RESET_ROCKCHIP)
+	ret = offsetof(struct rk3528_cru, softrst_con[0]);
+	ret = rockchip_reset_bind(dev, ret, 47);
+	if (ret)
+		debug("Warning: software reset driver bind failed\n");
+#endif
+
+	return 0;
+}
+
+static const struct udevice_id rk3528_clk_ids[] = {
+	{ .compatible = "rockchip,rk3528-cru" },
+	{ }
+};
+
+U_BOOT_DRIVER(rockchip_rk3528_cru) = {
+	.name		= "rockchip_rk3528_cru",
+	.id		= UCLASS_CLK,
+	.of_match	= rk3528_clk_ids,
+	.priv_auto	= sizeof(struct rk3528_clk_priv),
+	.of_to_plat	= rk3528_clk_ofdata_to_platdata,
+	.ops		= &rk3528_clk_ops,
+	.bind		= rk3528_clk_bind,
+	.probe		= rk3528_clk_probe,
+};
--- /dev/null
+++ b/include/dt-bindings/clock/rk3528-cru.h
@@ -0,0 +1,751 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (c) 2022 Rockchip Electronics Co. Ltd.
+ * Author: Joseph Chen <chenjh@rock-chips.com>
+ */
+
+#ifndef _DT_BINDINGS_CLK_ROCKCHIP_RK3528_H
+#define _DT_BINDINGS_CLK_ROCKCHIP_RK3528_H
+
+/* cru-clocks indices */
+
+/* core clocks */
+#define PLL_APLL			1
+#define PLL_CPLL			2
+#define PLL_GPLL			3
+#define PLL_PPLL			4
+#define PLL_DPLL			5
+#define ARMCLK				6
+
+#define XIN_OSC0_HALF			8
+#define CLK_MATRIX_50M_SRC		9
+#define CLK_MATRIX_100M_SRC		10
+#define CLK_MATRIX_150M_SRC		11
+#define CLK_MATRIX_200M_SRC		12
+#define CLK_MATRIX_250M_SRC		13
+#define CLK_MATRIX_300M_SRC		14
+#define CLK_MATRIX_339M_SRC		15
+#define CLK_MATRIX_400M_SRC		16
+#define CLK_MATRIX_500M_SRC		17
+#define CLK_MATRIX_600M_SRC		18
+#define CLK_UART0_SRC			19
+#define CLK_UART0_FRAC			20
+#define SCLK_UART0			21
+#define CLK_UART1_SRC			22
+#define CLK_UART1_FRAC			23
+#define SCLK_UART1			24
+#define CLK_UART2_SRC			25
+#define CLK_UART2_FRAC			26
+#define SCLK_UART2			27
+#define CLK_UART3_SRC			28
+#define CLK_UART3_FRAC			29
+#define SCLK_UART3			30
+#define CLK_UART4_SRC			31
+#define CLK_UART4_FRAC			32
+#define SCLK_UART4			33
+#define CLK_UART5_SRC			34
+#define CLK_UART5_FRAC			35
+#define SCLK_UART5			36
+#define CLK_UART6_SRC			37
+#define CLK_UART6_FRAC			38
+#define SCLK_UART6			39
+#define CLK_UART7_SRC			40
+#define CLK_UART7_FRAC			41
+#define SCLK_UART7			42
+#define CLK_I2S0_2CH_SRC		43
+#define CLK_I2S0_2CH_FRAC		44
+#define MCLK_I2S0_2CH_SAI_SRC		45
+#define CLK_I2S3_8CH_SRC		46
+#define CLK_I2S3_8CH_FRAC		47
+#define MCLK_I2S3_8CH_SAI_SRC		48
+#define CLK_I2S1_8CH_SRC		49
+#define CLK_I2S1_8CH_FRAC		50
+#define MCLK_I2S1_8CH_SAI_SRC		51
+#define CLK_I2S2_2CH_SRC		52
+#define CLK_I2S2_2CH_FRAC		53
+#define MCLK_I2S2_2CH_SAI_SRC		54
+#define CLK_SPDIF_SRC			55
+#define CLK_SPDIF_FRAC			56
+#define MCLK_SPDIF_SRC			57
+#define DCLK_VOP_SRC0			58
+#define DCLK_VOP_SRC1			59
+#define CLK_HSM				60
+#define CLK_CORE_SRC_ACS		63
+#define CLK_CORE_SRC_PVTMUX		65
+#define CLK_CORE_SRC			66
+#define CLK_CORE			67
+#define ACLK_M_CORE_BIU			68
+#define CLK_CORE_PVTPLL_SRC		69
+#define PCLK_DBG			70
+#define SWCLKTCK			71
+#define CLK_SCANHS_CORE			72
+#define CLK_SCANHS_ACLKM_CORE		73
+#define CLK_SCANHS_PCLK_DBG		74
+#define CLK_SCANHS_PCLK_CPU_BIU		76
+#define PCLK_CPU_ROOT			77
+#define PCLK_CORE_GRF			78
+#define PCLK_DAPLITE_BIU		79
+#define PCLK_CPU_BIU			80
+#define CLK_REF_PVTPLL_CORE		81
+#define ACLK_BUS_VOPGL_ROOT		85
+#define ACLK_BUS_VOPGL_BIU		86
+#define ACLK_BUS_H_ROOT			87
+#define ACLK_BUS_H_BIU			88
+#define ACLK_BUS_ROOT			89
+#define HCLK_BUS_ROOT			90
+#define PCLK_BUS_ROOT			91
+#define ACLK_BUS_M_ROOT			92
+#define ACLK_SYSMEM_BIU			93
+#define CLK_TIMER_ROOT			95
+#define ACLK_BUS_BIU			96
+#define HCLK_BUS_BIU			97
+#define PCLK_BUS_BIU			98
+#define PCLK_DFT2APB			99
+#define PCLK_BUS_GRF			100
+#define ACLK_BUS_M_BIU			101
+#define ACLK_GIC			102
+#define ACLK_SPINLOCK			103
+#define ACLK_DMAC			104
+#define PCLK_TIMER			105
+#define CLK_TIMER0			106
+#define CLK_TIMER1			107
+#define CLK_TIMER2			108
+#define CLK_TIMER3			109
+#define CLK_TIMER4			110
+#define CLK_TIMER5			111
+#define PCLK_JDBCK_DAP			112
+#define CLK_JDBCK_DAP			113
+#define PCLK_WDT_NS			114
+#define TCLK_WDT_NS			115
+#define HCLK_TRNG_NS			116
+#define PCLK_UART0			117
+#define CLK_CORE_CRYPTO			119
+#define CLK_PKA_CRYPTO			120
+#define ACLK_CRYPTO			121
+#define HCLK_CRYPTO			122
+#define PCLK_DMA2DDR			123
+#define ACLK_DMA2DDR			124
+#define PCLK_PWM0			126
+#define CLK_PWM0			127
+#define CLK_CAPTURE_PWM0		128
+#define PCLK_PWM1			129
+#define CLK_PWM1			130
+#define CLK_CAPTURE_PWM1		131
+#define PCLK_SCR			134
+#define ACLK_DCF			135
+#define PCLK_INTMUX			138
+#define CLK_PPLL_I			141
+#define CLK_PPLL_MUX			142
+#define CLK_PPLL_100M_MATRIX		143
+#define CLK_PPLL_50M_MATRIX		144
+#define CLK_REF_PCIE_INNER_PHY		145
+#define CLK_REF_PCIE_100M_PHY		146
+#define ACLK_VPU_L_ROOT			147
+#define CLK_GMAC1_VPU_25M		148
+#define CLK_PPLL_125M_MATRIX		149
+#define ACLK_VPU_ROOT			150
+#define HCLK_VPU_ROOT			151
+#define PCLK_VPU_ROOT			152
+#define ACLK_VPU_BIU			153
+#define HCLK_VPU_BIU			154
+#define PCLK_VPU_BIU			155
+#define ACLK_VPU			156
+#define HCLK_VPU			157
+#define PCLK_CRU_PCIE			158
+#define PCLK_VPU_GRF			159
+#define HCLK_SFC			160
+#define SCLK_SFC			161
+#define CCLK_SRC_EMMC			163
+#define HCLK_EMMC			164
+#define ACLK_EMMC			165
+#define BCLK_EMMC			166
+#define TCLK_EMMC			167
+#define PCLK_GPIO1			168
+#define DBCLK_GPIO1			169
+#define ACLK_VPU_L_BIU			172
+#define PCLK_VPU_IOC			173
+#define HCLK_SAI_I2S0			174
+#define MCLK_SAI_I2S0			175
+#define HCLK_SAI_I2S2			176
+#define MCLK_SAI_I2S2			177
+#define PCLK_ACODEC			178
+#define MCLK_ACODEC_TX			179
+#define PCLK_GPIO3			186
+#define DBCLK_GPIO3			187
+#define PCLK_SPI1			189
+#define CLK_SPI1			190
+#define SCLK_IN_SPI1			191
+#define PCLK_UART2			192
+#define PCLK_UART5			194
+#define PCLK_UART6			196
+#define PCLK_UART7			198
+#define PCLK_I2C3			200
+#define CLK_I2C3			201
+#define PCLK_I2C5			202
+#define CLK_I2C5			203
+#define PCLK_I2C6			204
+#define CLK_I2C6			205
+#define ACLK_MAC_VPU			206
+#define PCLK_MAC_VPU			207
+#define CLK_GMAC1_RMII_VPU		209
+#define CLK_GMAC1_SRC_VPU		210
+#define PCLK_PCIE			215
+#define CLK_PCIE_AUX			216
+#define ACLK_PCIE			217
+#define HCLK_PCIE_SLV			218
+#define HCLK_PCIE_DBI			219
+#define PCLK_PCIE_PHY			220
+#define PCLK_PIPE_GRF			221
+#define CLK_PIPE_USB3OTG_COMBO		230
+#define CLK_UTMI_USB3OTG		232
+#define CLK_PCIE_PIPE_PHY		235
+#define CCLK_SRC_SDIO0			240
+#define HCLK_SDIO0			241
+#define CCLK_SRC_SDIO1			244
+#define HCLK_SDIO1			245
+#define CLK_TS_0			246
+#define CLK_TS_1			247
+#define PCLK_CAN2			250
+#define CLK_CAN2			251
+#define PCLK_CAN3			252
+#define CLK_CAN3			253
+#define PCLK_SARADC			256
+#define CLK_SARADC			257
+#define PCLK_TSADC			258
+#define CLK_TSADC			259
+#define CLK_TSADC_TSEN			260
+#define ACLK_USB3OTG			261
+#define CLK_REF_USB3OTG			262
+#define CLK_SUSPEND_USB3OTG		263
+#define ACLK_GPU_ROOT			269
+#define PCLK_GPU_ROOT			270
+#define ACLK_GPU_BIU			271
+#define PCLK_GPU_BIU			272
+#define ACLK_GPU			273
+#define CLK_GPU_PVTPLL_SRC		274
+#define ACLK_GPU_MALI			275
+#define HCLK_RKVENC_ROOT		281
+#define ACLK_RKVENC_ROOT		282
+#define PCLK_RKVENC_ROOT		283
+#define HCLK_RKVENC_BIU			284
+#define ACLK_RKVENC_BIU			285
+#define PCLK_RKVENC_BIU			286
+#define HCLK_RKVENC			287
+#define ACLK_RKVENC			288
+#define CLK_CORE_RKVENC			289
+#define HCLK_SAI_I2S1			290
+#define MCLK_SAI_I2S1			291
+#define PCLK_I2C1			292
+#define CLK_I2C1			293
+#define PCLK_I2C0			294
+#define CLK_I2C0			295
+#define CLK_UART_JTAG			296
+#define PCLK_SPI0			297
+#define CLK_SPI0			298
+#define SCLK_IN_SPI0			299
+#define PCLK_GPIO4			300
+#define DBCLK_GPIO4			301
+#define PCLK_RKVENC_IOC			302
+#define HCLK_SPDIF			308
+#define MCLK_SPDIF			309
+#define HCLK_PDM			310
+#define MCLK_PDM			311
+#define PCLK_UART1			315
+#define PCLK_UART3			317
+#define PCLK_RKVENC_GRF			319
+#define PCLK_CAN0			320
+#define CLK_CAN0			321
+#define PCLK_CAN1			322
+#define CLK_CAN1			323
+#define ACLK_VO_ROOT			324
+#define HCLK_VO_ROOT			325
+#define PCLK_VO_ROOT			326
+#define ACLK_VO_BIU			327
+#define HCLK_VO_BIU			328
+#define PCLK_VO_BIU			329
+#define HCLK_RGA2E			330
+#define ACLK_RGA2E			331
+#define CLK_CORE_RGA2E			332
+#define HCLK_VDPP			333
+#define ACLK_VDPP			334
+#define CLK_CORE_VDPP			335
+#define PCLK_VO_GRF			336
+#define PCLK_CRU			337
+#define ACLK_VOP_ROOT			338
+#define ACLK_VOP_BIU			339
+#define HCLK_VOP			340
+#define DCLK_VOP0			341
+#define DCLK_VOP1			342
+#define ACLK_VOP			343
+#define PCLK_HDMI			344
+#define CLK_SFR_HDMI			345
+#define CLK_CEC_HDMI			346
+#define CLK_SPDIF_HDMI			347
+#define CLK_HDMIPHY_TMDSSRC		348
+#define CLK_HDMIPHY_PREP		349
+#define PCLK_HDMIPHY			352
+#define HCLK_HDCP_KEY			354
+#define ACLK_HDCP			355
+#define HCLK_HDCP			356
+#define PCLK_HDCP			357
+#define HCLK_CVBS			358
+#define DCLK_CVBS			359
+#define DCLK_4X_CVBS			360
+#define ACLK_JPEG_DECODER		361
+#define HCLK_JPEG_DECODER		362
+#define ACLK_VO_L_ROOT			375
+#define ACLK_VO_L_BIU			376
+#define ACLK_MAC_VO			377
+#define PCLK_MAC_VO			378
+#define CLK_GMAC0_SRC			379
+#define CLK_GMAC0_RMII_50M		380
+#define CLK_GMAC0_TX			381
+#define CLK_GMAC0_RX			382
+#define ACLK_JPEG_ROOT			385
+#define ACLK_JPEG_BIU			386
+#define HCLK_SAI_I2S3			387
+#define MCLK_SAI_I2S3			388
+#define CLK_MACPHY			398
+#define PCLK_VCDCPHY			399
+#define PCLK_GPIO2			404
+#define DBCLK_GPIO2			405
+#define PCLK_VO_IOC			406
+#define CCLK_SRC_SDMMC0			407
+#define HCLK_SDMMC0			408
+#define PCLK_OTPC_NS			411
+#define CLK_SBPI_OTPC_NS		412
+#define CLK_USER_OTPC_NS		413
+#define CLK_HDMIHDP0			415
+#define HCLK_USBHOST			416
+#define HCLK_USBHOST_ARB		417
+#define CLK_USBHOST_OHCI		418
+#define CLK_USBHOST_UTMI		419
+#define PCLK_UART4			420
+#define PCLK_I2C4			422
+#define CLK_I2C4			423
+#define PCLK_I2C7			424
+#define CLK_I2C7			425
+#define PCLK_USBPHY			426
+#define CLK_REF_USBPHY			427
+#define HCLK_RKVDEC_ROOT		433
+#define ACLK_RKVDEC_ROOT_NDFT		434
+#define PCLK_DDRPHY_CRU			435
+#define HCLK_RKVDEC_BIU			436
+#define ACLK_RKVDEC_BIU			437
+#define ACLK_RKVDEC			439
+#define HCLK_RKVDEC			440
+#define CLK_HEVC_CA_RKVDEC		441
+#define ACLK_RKVDEC_PVTMUX_ROOT		442
+#define CLK_RKVDEC_PVTPLL_SRC		443
+#define PCLK_DDR_ROOT			449
+#define PCLK_DDR_BIU			450
+#define PCLK_DDRC			451
+#define PCLK_DDRMON			452
+#define CLK_TIMER_DDRMON		453
+#define PCLK_MSCH_BIU			454
+#define PCLK_DDR_GRF			455
+#define PCLK_DDR_HWLP			456
+#define PCLK_DDRPHY			457
+#define CLK_MSCH_BIU			463
+#define ACLK_DDR_UPCTL			464
+#define CLK_DDR_UPCTL			465
+#define CLK_DDRMON			466
+#define ACLK_DDR_SCRAMBLE		467
+#define ACLK_SPLIT			468
+#define CLK_DDRC_SRC			470
+#define CLK_DDR_PHY			471
+#define PCLK_OTPC_S			472
+#define CLK_SBPI_OTPC_S			473
+#define CLK_USER_OTPC_S			474
+#define PCLK_KEYREADER			475
+#define PCLK_BUS_SGRF			476
+#define PCLK_STIMER			477
+#define CLK_STIMER0			478
+#define CLK_STIMER1			479
+#define PCLK_WDT_S			480
+#define TCLK_WDT_S			481
+#define HCLK_TRNG_S			482
+#define PCLK_KLAD			483
+#define HCLK_CRYPTO_S			484
+#define HCLK_KLAD			485
+#define HCLK_BOOTROM			486
+#define PCLK_DCF			487
+#define ACLK_SYSMEM			488
+#define HCLK_TSP			489
+#define ACLK_TSP			490
+#define CLK_CORE_TSP			491
+#define CLK_OTPC_ARB			492
+#define PCLK_OTP_MASK			493
+#define CLK_PMC_OTP			494
+#define PCLK_PMU_ROOT			495
+#define HCLK_PMU_ROOT			496
+#define PCLK_I2C2			497
+#define CLK_I2C2			498
+#define HCLK_PMU_BIU			500
+#define PCLK_PMU_BIU			501
+#define FCLK_MCU			502
+#define RTC_CLK_MCU			504
+#define PCLK_OSCCHK			505
+#define CLK_PMU_MCU_JTAG		506
+#define PCLK_PMU			508
+#define PCLK_GPIO0			509
+#define DBCLK_GPIO0			510
+#define XIN_OSC0_DIV			511
+#define CLK_DEEPSLOW			512
+#define CLK_DDR_FAIL_SAFE		513
+#define PCLK_PMU_HP_TIMER		514
+#define CLK_PMU_HP_TIMER		515
+#define CLK_PMU_32K_HP_TIMER		516
+#define PCLK_PMU_IOC			517
+#define PCLK_PMU_CRU			518
+#define PCLK_PMU_GRF			519
+#define PCLK_PMU_WDT			520
+#define TCLK_PMU_WDT			521
+#define PCLK_PMU_MAILBOX		522
+#define PCLK_SCRKEYGEN			524
+#define CLK_SCRKEYGEN			525
+#define CLK_PVTM_OSCCHK			526
+#define CLK_REFOUT			530
+#define CLK_PVTM_PMU			532
+#define PCLK_PVTM_PMU			533
+#define PCLK_PMU_SGRF			534
+#define HCLK_PMU_SRAM			535
+#define CLK_UART0			536
+#define CLK_UART1			537
+#define CLK_UART2			538
+#define CLK_UART3			539
+#define CLK_UART4			540
+#define CLK_UART5			541
+#define CLK_UART6			542
+#define CLK_UART7			543
+#define MCLK_I2S0_2CH_SAI_SRC_PRE	544
+#define MCLK_I2S1_8CH_SAI_SRC_PRE	545
+#define MCLK_I2S2_2CH_SAI_SRC_PRE	546
+#define MCLK_I2S3_8CH_SAI_SRC_PRE	547
+#define MCLK_SDPDIF_SRC_PRE		548
+
+/* grf-clocks indices */
+#define SCLK_SDMMC_DRV			1
+#define SCLK_SDMMC_SAMPLE		2
+#define SCLK_SDIO0_DRV			3
+#define SCLK_SDIO0_SAMPLE		4
+#define SCLK_SDIO1_DRV			5
+#define SCLK_SDIO1_SAMPLE		6
+
+/* scmi-clocks indices */
+#define SCMI_PCLK_KEYREADER		0
+#define SCMI_HCLK_KLAD			1
+#define SCMI_PCLK_KLAD			2
+#define SCMI_HCLK_TRNG_S		3
+#define SCMI_HCLK_CRYPTO_S		4
+#define SCMI_PCLK_WDT_S			5
+#define SCMI_TCLK_WDT_S			6
+#define SCMI_PCLK_STIMER		7
+#define SCMI_CLK_STIMER0		8
+#define SCMI_CLK_STIMER1		9
+#define SCMI_PCLK_OTP_MASK		10
+#define SCMI_PCLK_OTPC_S		11
+#define SCMI_CLK_SBPI_OTPC_S		12
+#define SCMI_CLK_USER_OTPC_S		13
+#define SCMI_CLK_PMC_OTP		14
+#define SCMI_CLK_OTPC_ARB		15
+#define SCMI_CLK_CORE_TSP		16
+#define SCMI_ACLK_TSP			17
+#define SCMI_HCLK_TSP			18
+#define SCMI_PCLK_DCF			19
+#define SCMI_CLK_DDR			20
+#define SCMI_CLK_CPU			21
+#define SCMI_CLK_GPU			22
+#define SCMI_CORE_CRYPTO		23
+#define SCMI_ACLK_CRYPTO		24
+#define SCMI_PKA_CRYPTO			25
+#define SCMI_HCLK_CRYPTO		26
+#define SCMI_CORE_CRYPTO_S		27
+#define SCMI_ACLK_CRYPTO_S		28
+#define SCMI_PKA_CRYPTO_S		29
+#define SCMI_CORE_KLAD			30
+#define SCMI_ACLK_KLAD			31
+#define SCMI_HCLK_TRNG			32
+
+// CRU_SOFTRST_CON03(Offset:0xA0C)
+#define SRST_NCOREPORESET0		0x00000030
+#define SRST_NCOREPORESET1		0x00000031
+#define SRST_NCOREPORESET2		0x00000032
+#define SRST_NCOREPORESET3		0x00000033
+#define SRST_NCORESET0			0x00000034
+#define SRST_NCORESET1			0x00000035
+#define SRST_NCORESET2			0x00000036
+#define SRST_NCORESET3			0x00000037
+#define SRST_NL2RESET			0x00000038
+#define SRST_ARESETN_M_CORE_BIU		0x00000039
+#define SRST_RESETN_CORE_CRYPTO		0x0000003A
+
+// CRU_SOFTRST_CON05(Offset:0xA14)
+#define SRST_PRESETN_DBG		0x0000005D
+#define SRST_POTRESETN_DBG		0x0000005E
+#define SRST_NTRESETN_DBG		0x0000005F
+
+// CRU_SOFTRST_CON06(Offset:0xA18)
+#define SRST_PRESETN_CORE_GRF		0x00000062
+#define SRST_PRESETN_DAPLITE_BIU	0x00000063
+#define SRST_PRESETN_CPU_BIU		0x00000064
+#define SRST_RESETN_REF_PVTPLL_CORE	0x00000067
+
+// CRU_SOFTRST_CON08(Offset:0xA20)
+#define SRST_ARESETN_BUS_VOPGL_BIU	0x00000081
+#define SRST_ARESETN_BUS_H_BIU		0x00000083
+#define SRST_ARESETN_SYSMEM_BIU		0x00000088
+#define SRST_ARESETN_BUS_BIU		0x0000008A
+#define SRST_HRESETN_BUS_BIU		0x0000008B
+#define SRST_PRESETN_BUS_BIU		0x0000008C
+#define SRST_PRESETN_DFT2APB		0x0000008D
+#define SRST_PRESETN_BUS_GRF		0x0000008F
+
+// CRU_SOFTRST_CON09(Offset:0xA24)
+#define SRST_ARESETN_BUS_M_BIU		0x00000090
+#define SRST_ARESETN_GIC		0x00000091
+#define SRST_ARESETN_SPINLOCK		0x00000092
+#define SRST_ARESETN_DMAC		0x00000094
+#define SRST_PRESETN_TIMER		0x00000095
+#define SRST_RESETN_TIMER0		0x00000096
+#define SRST_RESETN_TIMER1		0x00000097
+#define SRST_RESETN_TIMER2		0x00000098
+#define SRST_RESETN_TIMER3		0x00000099
+#define SRST_RESETN_TIMER4		0x0000009A
+#define SRST_RESETN_TIMER5		0x0000009B
+#define SRST_PRESETN_JDBCK_DAP		0x0000009C
+#define SRST_RESETN_JDBCK_DAP		0x0000009D
+#define SRST_PRESETN_WDT_NS		0x0000009F
+
+// CRU_SOFTRST_CON10(Offset:0xA28)
+#define SRST_TRESETN_WDT_NS		0x000000A0
+#define SRST_HRESETN_TRNG_NS		0x000000A3
+#define SRST_PRESETN_UART0		0x000000A7
+#define SRST_SRESETN_UART0		0x000000A8
+#define SRST_RESETN_PKA_CRYPTO		0x000000AA
+#define SRST_ARESETN_CRYPTO		0x000000AB
+#define SRST_HRESETN_CRYPTO		0x000000AC
+#define SRST_PRESETN_DMA2DDR		0x000000AD
+#define SRST_ARESETN_DMA2DDR		0x000000AE
+
+// CRU_SOFTRST_CON11(Offset:0xA2C)
+#define SRST_PRESETN_PWM0		0x000000B4
+#define SRST_RESETN_PWM0		0x000000B5
+#define SRST_PRESETN_PWM1		0x000000B7
+#define SRST_RESETN_PWM1		0x000000B8
+#define SRST_PRESETN_SCR		0x000000BA
+#define SRST_ARESETN_DCF		0x000000BB
+#define SRST_PRESETN_INTMUX		0x000000BC
+
+// CRU_SOFTRST_CON25(Offset:0xA64)
+#define SRST_ARESETN_VPU_BIU		0x00000196
+#define SRST_HRESETN_VPU_BIU		0x00000197
+#define SRST_PRESETN_VPU_BIU		0x00000198
+#define SRST_ARESETN_VPU		0x00000199
+#define SRST_HRESETN_VPU		0x0000019A
+#define SRST_PRESETN_CRU_PCIE		0x0000019B
+#define SRST_PRESETN_VPU_GRF		0x0000019C
+#define SRST_HRESETN_SFC		0x0000019D
+#define SRST_SRESETN_SFC		0x0000019E
+#define SRST_CRESETN_EMMC		0x0000019F
+
+// CRU_SOFTRST_CON26(Offset:0xA68)
+#define SRST_HRESETN_EMMC		0x000001A0
+#define SRST_ARESETN_EMMC		0x000001A1
+#define SRST_BRESETN_EMMC		0x000001A2
+#define SRST_TRESETN_EMMC		0x000001A3
+#define SRST_PRESETN_GPIO1		0x000001A4
+#define SRST_DBRESETN_GPIO1		0x000001A5
+#define SRST_ARESETN_VPU_L_BIU		0x000001A6
+#define SRST_PRESETN_VPU_IOC		0x000001A8
+#define SRST_HRESETN_SAI_I2S0		0x000001A9
+#define SRST_MRESETN_SAI_I2S0		0x000001AA
+#define SRST_HRESETN_SAI_I2S2		0x000001AB
+#define SRST_MRESETN_SAI_I2S2		0x000001AC
+#define SRST_PRESETN_ACODEC		0x000001AD
+
+// CRU_SOFTRST_CON27(Offset:0xA6C)
+#define SRST_PRESETN_GPIO3		0x000001B0
+#define SRST_DBRESETN_GPIO3		0x000001B1
+#define SRST_PRESETN_SPI1		0x000001B4
+#define SRST_RESETN_SPI1		0x000001B5
+#define SRST_PRESETN_UART2		0x000001B7
+#define SRST_SRESETN_UART2		0x000001B8
+#define SRST_PRESETN_UART5		0x000001B9
+#define SRST_SRESETN_UART5		0x000001BA
+#define SRST_PRESETN_UART6		0x000001BB
+#define SRST_SRESETN_UART6		0x000001BC
+#define SRST_PRESETN_UART7		0x000001BD
+#define SRST_SRESETN_UART7		0x000001BE
+#define SRST_PRESETN_I2C3		0x000001BF
+
+// CRU_SOFTRST_CON28(Offset:0xA70)
+#define SRST_RESETN_I2C3		0x000001C0
+#define SRST_PRESETN_I2C5		0x000001C1
+#define SRST_RESETN_I2C5		0x000001C2
+#define SRST_PRESETN_I2C6		0x000001C3
+#define SRST_RESETN_I2C6		0x000001C4
+#define SRST_ARESETN_MAC		0x000001C5
+
+// CRU_SOFTRST_CON30(Offset:0xA78)
+#define SRST_PRESETN_PCIE		0x000001E1
+#define SRST_RESETN_PCIE_PIPE_PHY	0x000001E2
+#define SRST_RESETN_PCIE_POWER_UP	0x000001E3
+#define SRST_PRESETN_PCIE_PHY		0x000001E6
+#define SRST_PRESETN_PIPE_GRF		0x000001E7
+
+// CRU_SOFTRST_CON32(Offset:0xA80)
+#define SRST_HRESETN_SDIO0		0x00000202
+#define SRST_HRESETN_SDIO1		0x00000204
+#define SRST_RESETN_TS_0		0x00000205
+#define SRST_RESETN_TS_1		0x00000206
+#define SRST_PRESETN_CAN2		0x00000207
+#define SRST_RESETN_CAN2		0x00000208
+#define SRST_PRESETN_CAN3		0x00000209
+#define SRST_RESETN_CAN3		0x0000020A
+#define SRST_PRESETN_SARADC		0x0000020B
+#define SRST_RESETN_SARADC		0x0000020C
+#define SRST_RESETN_SARADC_PHY		0x0000020D
+#define SRST_PRESETN_TSADC		0x0000020E
+#define SRST_RESETN_TSADC		0x0000020F
+
+// CRU_SOFTRST_CON33(Offset:0xA84)
+#define SRST_ARESETN_USB3OTG		0x00000211
+
+// CRU_SOFTRST_CON34(Offset:0xA88)
+#define SRST_ARESETN_GPU_BIU		0x00000223
+#define SRST_PRESETN_GPU_BIU		0x00000225
+#define SRST_ARESETN_GPU		0x00000228
+#define SRST_RESETN_REF_PVTPLL_GPU	0x00000229
+
+// CRU_SOFTRST_CON36(Offset:0xA90)
+#define SRST_HRESETN_RKVENC_BIU		0x00000243
+#define SRST_ARESETN_RKVENC_BIU		0x00000244
+#define SRST_PRESETN_RKVENC_BIU		0x00000245
+#define SRST_HRESETN_RKVENC		0x00000246
+#define SRST_ARESETN_RKVENC		0x00000247
+#define SRST_RESETN_CORE_RKVENC		0x00000248
+#define SRST_HRESETN_SAI_I2S1		0x00000249
+#define SRST_MRESETN_SAI_I2S1		0x0000024A
+#define SRST_PRESETN_I2C1		0x0000024B
+#define SRST_RESETN_I2C1		0x0000024C
+#define SRST_PRESETN_I2C0		0x0000024D
+#define SRST_RESETN_I2C0		0x0000024E
+
+// CRU_SOFTRST_CON37(Offset:0xA94)
+#define SRST_PRESETN_SPI0		0x00000252
+#define SRST_RESETN_SPI0		0x00000253
+#define SRST_PRESETN_GPIO4		0x00000258
+#define SRST_DBRESETN_GPIO4		0x00000259
+#define SRST_PRESETN_RKVENC_IOC		0x0000025A
+#define SRST_HRESETN_SPDIF		0x0000025E
+#define SRST_MRESETN_SPDIF		0x0000025F
+
+// CRU_SOFTRST_CON38(Offset:0xA98)
+#define SRST_HRESETN_PDM		0x00000260
+#define SRST_MRESETN_PDM		0x00000261
+#define SRST_PRESETN_UART1		0x00000262
+#define SRST_SRESETN_UART1		0x00000263
+#define SRST_PRESETN_UART3		0x00000264
+#define SRST_SRESETN_UART3		0x00000265
+#define SRST_PRESETN_RKVENC_GRF		0x00000266
+#define SRST_PRESETN_CAN0		0x00000267
+#define SRST_RESETN_CAN0		0x00000268
+#define SRST_PRESETN_CAN1		0x00000269
+#define SRST_RESETN_CAN1		0x0000026A
+
+// CRU_SOFTRST_CON39(Offset:0xA9C)
+#define SRST_ARESETN_VO_BIU		0x00000273
+#define SRST_HRESETN_VO_BIU		0x00000274
+#define SRST_PRESETN_VO_BIU		0x00000275
+#define SRST_HRESETN_RGA2E		0x00000277
+#define SRST_ARESETN_RGA2E		0x00000278
+#define SRST_RESETN_CORE_RGA2E		0x00000279
+#define SRST_HRESETN_VDPP		0x0000027A
+#define SRST_ARESETN_VDPP		0x0000027B
+#define SRST_RESETN_CORE_VDPP		0x0000027C
+#define SRST_PRESETN_VO_GRF		0x0000027D
+#define SRST_PRESETN_CRU		0x0000027F
+
+// CRU_SOFTRST_CON40(Offset:0xAA0)
+#define SRST_ARESETN_VOP_BIU		0x00000281
+#define SRST_HRESETN_VOP		0x00000282
+#define SRST_DRESETN_VOP0		0x00000283
+#define SRST_DRESETN_VOP1		0x00000284
+#define SRST_ARESETN_VOP		0x00000285
+#define SRST_PRESETN_HDMI		0x00000286
+#define SRST_HDMI_RESETN		0x00000287
+#define SRST_PRESETN_HDMIPHY		0x0000028E
+#define SRST_HRESETN_HDCP_KEY		0x0000028F
+
+// CRU_SOFTRST_CON41(Offset:0xAA4)
+#define SRST_ARESETN_HDCP		0x00000290
+#define SRST_HRESETN_HDCP		0x00000291
+#define SRST_PRESETN_HDCP		0x00000292
+#define SRST_HRESETN_CVBS		0x00000293
+#define SRST_DRESETN_CVBS_VOP		0x00000294
+#define SRST_DRESETN_4X_CVBS_VOP	0x00000295
+#define SRST_ARESETN_JPEG_DECODER	0x00000296
+#define SRST_HRESETN_JPEG_DECODER	0x00000297
+#define SRST_ARESETN_VO_L_BIU		0x00000299
+#define SRST_ARESETN_MAC_VO		0x0000029A
+
+// CRU_SOFTRST_CON42(Offset:0xAA8)
+#define SRST_ARESETN_JPEG_BIU		0x000002A0
+#define SRST_HRESETN_SAI_I2S3		0x000002A1
+#define SRST_MRESETN_SAI_I2S3		0x000002A2
+#define SRST_RESETN_MACPHY		0x000002A3
+#define SRST_PRESETN_VCDCPHY		0x000002A4
+#define SRST_PRESETN_GPIO2		0x000002A5
+#define SRST_DBRESETN_GPIO2		0x000002A6
+#define SRST_PRESETN_VO_IOC		0x000002A7
+#define SRST_HRESETN_SDMMC0		0x000002A9
+#define SRST_PRESETN_OTPC_NS		0x000002AB
+#define SRST_RESETN_SBPI_OTPC_NS	0x000002AC
+#define SRST_RESETN_USER_OTPC_NS	0x000002AD
+
+// CRU_SOFTRST_CON43(Offset:0xAAC)
+#define SRST_RESETN_HDMIHDP0		0x000002B2
+#define SRST_HRESETN_USBHOST		0x000002B3
+#define SRST_HRESETN_USBHOST_ARB	0x000002B4
+#define SRST_RESETN_HOST_UTMI		0x000002B6
+#define SRST_PRESETN_UART4		0x000002B7
+#define SRST_SRESETN_UART4		0x000002B8
+#define SRST_PRESETN_I2C4		0x000002B9
+#define SRST_RESETN_I2C4		0x000002BA
+#define SRST_PRESETN_I2C7		0x000002BB
+#define SRST_RESETN_I2C7		0x000002BC
+#define SRST_PRESETN_USBPHY		0x000002BD
+#define SRST_RESETN_USBPHY_POR		0x000002BE
+#define SRST_RESETN_USBPHY_OTG		0x000002BF
+
+// CRU_SOFTRST_CON44(Offset:0xAB0)
+#define SRST_RESETN_USBPHY_HOST		0x000002C0
+#define SRST_PRESETN_DDRPHY_CRU		0x000002C4
+#define SRST_HRESETN_RKVDEC_BIU		0x000002C6
+#define SRST_ARESETN_RKVDEC_BIU		0x000002C7
+#define SRST_ARESETN_RKVDEC		0x000002C8
+#define SRST_HRESETN_RKVDEC		0x000002C9
+#define SRST_RESETN_HEVC_CA_RKVDEC	0x000002CB
+#define SRST_RESETN_REF_PVTPLL_RKVDEC	0x000002CC
+
+// CRU_SOFTRST_CON45(Offset:0xAB4)
+#define SRST_PRESETN_DDR_BIU		0x000002D1
+#define SRST_PRESETN_DDRC		0x000002D2
+#define SRST_PRESETN_DDRMON		0x000002D3
+#define SRST_RESETN_TIMER_DDRMON	0x000002D4
+#define SRST_PRESETN_MSCH_BIU		0x000002D5
+#define SRST_PRESETN_DDR_GRF		0x000002D6
+#define SRST_PRESETN_DDR_HWLP		0x000002D8
+#define SRST_PRESETN_DDRPHY		0x000002D9
+#define SRST_RESETN_MSCH_BIU		0x000002DA
+#define SRST_ARESETN_DDR_UPCTL		0x000002DB
+#define SRST_RESETN_DDR_UPCTL		0x000002DC
+#define SRST_RESETN_DDRMON		0x000002DD
+#define SRST_ARESETN_DDR_SCRAMBLE	0x000002DE
+#define SRST_ARESETN_SPLIT		0x000002DF
+
+// CRU_SOFTRST_CON46(Offset:0xAB8)
+#define SRST_RESETN_DDR_PHY		0x000002E0
+
+#endif
