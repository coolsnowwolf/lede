From: =?UTF-8?q?Rog=C3=A9rio=20Brito?= <rbrito@ime.usp.br>
Date: Thu, 24 Oct 2013 01:11:21 -0200
Subject: Rename custom macro nil with NULL

---
 fsck_hfs.tproj/dfalib/BTree.c         | 142 +++++++++++++++++-----------------
 fsck_hfs.tproj/dfalib/BTreeAllocate.c |  14 ++--
 fsck_hfs.tproj/dfalib/BTreeMiscOps.c  |  26 +++----
 fsck_hfs.tproj/dfalib/BTreeNodeOps.c  |  30 +++----
 fsck_hfs.tproj/dfalib/BTreeTreeOps.c  |  38 ++++-----
 fsck_hfs.tproj/dfalib/SControl.c      |  56 +++++++-------
 fsck_hfs.tproj/dfalib/SRepair.c       |   6 +-
 fsck_hfs.tproj/dfalib/SUtils.c        |   6 +-
 fsck_hfs.tproj/dfalib/SVerify1.c      |  32 ++++----
 fsck_hfs.tproj/dfalib/SVerify2.c      |   4 +-
 10 files changed, 177 insertions(+), 177 deletions(-)

--- a/fsck_hfs.tproj/dfalib/BTree.c
+++ b/fsck_hfs.tproj/dfalib/BTree.c
@@ -163,21 +163,21 @@ OSStatus	BTInitialize		(FCB					*filePtr
 
 	////////////////////// Preliminary Error Checking ///////////////////////////
 
-	headerNode.buffer	= nil;
+	headerNode.buffer	= NULL;
 
-	if (pathPtr										== nil)	return  paramErr;
+	if (pathPtr == NULL)	return  paramErr;
 
 	setEndOfForkProc	= pathPtr->agentPtr->agent.setEndOfForkProc;
 	setBlockSizeProc	= pathPtr->agentPtr->agent.setBlockSizeProc;
 
-	if (pathPtr->agentPtr->agent.getBlockProc		== nil)	return  E_NoGetBlockProc;
-	if (pathPtr->agentPtr->agent.releaseBlockProc	== nil)	return  E_NoReleaseBlockProc;
-	if (setEndOfForkProc							== nil)	return  E_NoSetEndOfForkProc;
-	if (setBlockSizeProc							== nil)	return  E_NoSetBlockSizeProc;
+	if (pathPtr->agentPtr->agent.getBlockProc == NULL)	return  E_NoGetBlockProc;
+	if (pathPtr->agentPtr->agent.releaseBlockProc == NULL)	return  E_NoReleaseBlockProc;
+	if (setEndOfForkProc == NULL)	return  E_NoSetEndOfForkProc;
+	if (setBlockSizeProc == NULL)	return  E_NoSetBlockSizeProc;
 
 	forkPtr = pathPtr->path.forkPtr;
 
-	if (forkPtr->fork.btreePtr != nil)						return	fsBTrFileAlreadyOpenErr;
+	if (forkPtr->fork.btreePtr != NULL) return	fsBTrFileAlreadyOpenErr;
 
 	if ((maxKeyLength == 0) ||
 		(maxKeyLength >  kMaxKeyLength))					return	fsBTInvalidKeyLengthErr;
@@ -209,7 +209,7 @@ OSStatus	BTInitialize		(FCB					*filePtr
 	//////////////////////// Allocate Control Block /////////////////////////////
 
 	M_RESIDENT_ALLOCATE_FIXED_CLEAR( &btreePtr, sizeof( BTreeControlBlock ), kFSBTreeControlBlockType );
-	if (btreePtr == nil)
+	if (btreePtr == NULL)
 	{
 		err = memFullErr;
 		goto ErrorExit;
@@ -220,7 +220,7 @@ OSStatus	BTInitialize		(FCB					*filePtr
 	btreePtr->flags				= 0;
 	btreePtr->attributes		= 0;
 	btreePtr->forkPtr			= forkPtr;
-	btreePtr->keyCompareProc	= nil;
+	btreePtr->keyCompareProc	= NULL;
 	btreePtr->keyDescPtr		= keyDescPtr;
 	btreePtr->btreeType			= btreeType;
 	btreePtr->treeDepth			= 0;
@@ -282,7 +282,7 @@ OSStatus	BTInitialize		(FCB					*filePtr
 
 	///////////////////// Copy Key Descriptor To Header /////////////////////////
 #if SupportsKeyDescriptors
-	if (keyDescPtr != nil)
+	if (keyDescPtr != NULL)
 	{
 		err = CheckKeyDescriptor (keyDescPtr, maxKeyLength);
 		M_ExitOnError (err);
@@ -309,7 +309,7 @@ OSStatus	BTInitialize		(FCB					*filePtr
 	err = UpdateHeader (btreePtr);
 	M_ExitOnError (err);
 
-	pathPtr->path.forkPtr->fork.btreePtr = nil;
+	pathPtr->path.forkPtr->fork.btreePtr = NULL;
 	M_RESIDENT_DEALLOCATE_FIXED( btreePtr, sizeof( BTreeControlBlock ), kFSBTreeControlBlockType );
 
 	return	noErr;
@@ -320,7 +320,7 @@ OSStatus	BTInitialize		(FCB					*filePtr
 ErrorExit:
 
 	(void) ReleaseNode (btreePtr, &headerNode);
-	if (btreePtr != nil)
+	if (btreePtr != NULL)
 		M_RESIDENT_DEALLOCATE_FIXED( btreePtr, sizeof( BTreeControlBlock ), kFSBTreeControlBlockType );
 
 	return	err;
@@ -342,7 +342,7 @@ Input:		filePtr				- pointer to file to
 			setEndOfForkProc	- pointer to client's SetEOF function
 
 Result:		noErr				- success
-			paramErr			- required ptr was nil
+			paramErr			- required ptr was NULL
 			fsBTInvalidFileErr				-
 			memFullErr			-
 			!= noErr			- failure
@@ -364,16 +364,16 @@ OSStatus	BTOpenPath			(SFCB					*filePtr
 
 	////////////////////// Preliminary Error Checking ///////////////////////////
 
-	if ( filePtr == nil				||
-		 getBlockProc == nil		||
-		 releaseBlockProc == nil	||
-		 setEndOfForkProc == nil	||
-		 setBlockSizeProc == nil )
+	if (filePtr == NULL ||
+		 getBlockProc == NULL ||
+		 releaseBlockProc == NULL ||
+		 setEndOfForkProc == NULL ||
+		 setBlockSizeProc == NULL)
 	{
 		return  paramErr;
 	}
 
-	if ( filePtr->fcbBtree != nil )			// already has a BTreeCB
+	if (filePtr->fcbBtree != NULL)			// already has a BTreeCB
 		return noErr;
 
 												// is file large enough to contain header node?
@@ -384,7 +384,7 @@ OSStatus	BTOpenPath			(SFCB					*filePtr
 	//////////////////////// Allocate Control Block /////////////////////////////
 
 	btreePtr = (BTreeControlBlock*) AllocateClearMemory( sizeof( BTreeControlBlock ) );
-	if (btreePtr == nil)
+	if (btreePtr == NULL)
 	{
 		Panic ("\pBTOpen: no memory for btreePtr.");
 		return	memFullErr;
@@ -397,7 +397,7 @@ OSStatus	BTOpenPath			(SFCB					*filePtr
 
 	/////////////////////////// Read Header Node ////////////////////////////////
 
-	nodeRec.buffer				= nil;				// so we can call ReleaseNode
+	nodeRec.buffer				= NULL;				// so we can call ReleaseNode
 	
 	btreePtr->fcbPtr			= filePtr;
 	filePtr->fcbBtree			= (void *) btreePtr;	// attach btree cb to file
@@ -487,7 +487,7 @@ OSStatus	BTOpenPath			(SFCB					*filePtr
 
 	////////////////////////// Get Key Descriptor ///////////////////////////////
 #if SupportsKeyDescriptors
-	if ( keyCompareProc == nil )		// 	if no key compare proc then get key descriptor
+	if (keyCompareProc == NULL)		// 	if no key compare proc then get key descriptor
 	{
 		err = GetKeyDescriptor (btreePtr, nodeRec.buffer);	//본 it should check amount of memory allocated...
 		M_ExitOnError (err);
@@ -499,7 +499,7 @@ OSStatus	BTOpenPath			(SFCB					*filePtr
 	else
 #endif
 	{
-		btreePtr->keyDescPtr = nil;			// clear it so we don't dispose garbage later
+		btreePtr->keyDescPtr = NULL;			// clear it so we don't dispose garbage later
 	}
 
 	err = ReleaseNode (btreePtr, &nodeRec);
@@ -528,7 +528,7 @@ OSStatus	BTOpenPath			(SFCB					*filePtr
 
 ErrorExit:
 
-	filePtr->fcbBtree = nil;
+	filePtr->fcbBtree = NULL;
 	(void) ReleaseNode (btreePtr, &nodeRec);
 	DisposeMemory( btreePtr );
 
@@ -567,7 +567,7 @@ OSStatus	BTClosePath			(SFCB					*filePt
 
 	btreePtr = (BTreeControlBlockPtr) filePtr->fcbBtree;
 
-	if (btreePtr == nil)
+	if (btreePtr == NULL)
 		return fsBTInvalidFileErr;
 
 	////////////////////// Check for other BTree Paths //////////////////////////
@@ -603,14 +603,14 @@ OSStatus	BTClosePath			(SFCB					*filePt
 	M_ExitOnError (err);
 
 #if SupportsKeyDescriptors
-	if (btreePtr->keyDescPtr != nil)			// deallocate keyDescriptor, if any
+	if (btreePtr->keyDescPtr != NULL)			// deallocate keyDescriptor, if any
 	{
 		DisposeMemory( btreePtr->keyDescPtr );
 	}
 #endif
 
 	DisposeMemory( btreePtr );
-	filePtr->fcbBtree = nil;
+	filePtr->fcbBtree = NULL;
 
 //	LogEndTime(kTraceCloseBTree, noErr);
 
@@ -643,7 +643,7 @@ Function:	Search for position in B*Tree
 
 Input:		pathPtr			- pointer to path for BTree file.
 			searchKey		- pointer to search key to match.
-			hintPtr			- pointer to hint (may be nil)
+			hintPtr			- pointer to hint (may be NULL)
 
 Output:		record			- pointer to BufferDescriptor containing record
 			recordLen		- length of data at recordPtr
@@ -678,14 +678,14 @@ OSStatus	BTSearchRecord		(SFCB						*fil
 
 //	LogStartTime(kTraceSearchBTree);
 
-	if (filePtr == nil)									return	paramErr;
-	if (searchIterator == nil)							return	paramErr;
+	if (filePtr == NULL)		return	paramErr;
+	if (searchIterator == NULL)	return	paramErr;
 
 	btreePtr = (BTreeControlBlockPtr) filePtr->fcbBtree;
-	if (btreePtr == nil)								return	fsBTInvalidFileErr;
+	if (btreePtr == NULL)		return	fsBTInvalidFileErr;
 
 #if SupportsKeyDescriptors
-	if (btreePtr->keyCompareProc == nil)		// CheckKey if we using Key Descriptor
+	if (btreePtr->keyCompareProc == NULL)		// CheckKey if we using Key Descriptor
 	{
 		err = CheckKey (&searchIterator->key, btreePtr->keyDescPtr, btreePtr->maxKeyLength);
 		M_ExitOnError (err);
@@ -775,9 +775,9 @@ OSStatus	BTSearchRecord		(SFCB						*fil
 		//본 Should check for errors! Or BlockMove could choke on recordPtr!!!
 		GetRecordByIndex (btreePtr, node.buffer, index, &keyPtr, &recordPtr, &len);
 
-		if (recordLen != nil)			*recordLen = len;
+		if (recordLen != NULL)	*recordLen = len;
 
-		if (record != nil)
+		if (record != NULL)
 		{
 			ByteCount recordSize;
 
@@ -794,7 +794,7 @@ OSStatus	BTSearchRecord		(SFCB						*fil
 
 	/////////////////////// Success - Update Iterator ///////////////////////////
 
-	if (resultIterator != nil)
+	if (resultIterator != NULL)
 	{
 		resultIterator->hint.writeCount	= btreePtr->writeCount;
 		resultIterator->hint.nodeNum	= nodeNum;
@@ -825,10 +825,10 @@ OSStatus	BTSearchRecord		(SFCB						*fil
 
 ErrorExit:
 
-	if (recordLen != nil)
+	if (recordLen != NULL)
 		*recordLen = 0;
 
-	if (resultIterator != nil)
+	if (resultIterator != NULL)
 	{
 		resultIterator->hint.writeCount	= 0;
 		resultIterator->hint.nodeNum	= 0;
@@ -892,18 +892,18 @@ OSStatus	BTIterateRecord		(SFCB						*fi
 
 	////////////////////////// Priliminary Checks ///////////////////////////////
 
-	left.buffer		= nil;
-	right.buffer	= nil;
-	node.buffer		= nil;
+	left.buffer		= NULL;
+	right.buffer	= NULL;
+	node.buffer		= NULL;
 
 
-	if (filePtr == nil)
+	if (filePtr == NULL)
 	{
 		return	paramErr;
 	}
 
 	btreePtr = (BTreeControlBlockPtr) filePtr->fcbBtree;
-	if (btreePtr == nil)
+	if (btreePtr == NULL)
 	{
 		return	fsBTInvalidFileErr;			//본 handle properly
 	}
@@ -968,7 +968,7 @@ OSStatus	BTIterateRecord		(SFCB						*fi
 		}
 		else
 		{
-			if (left.buffer == nil)
+			if (left.buffer == NULL)
 			{
 				nodeNum = ((NodeDescPtr) node.buffer)->bLink;
 				if ( nodeNum > 0)
@@ -981,13 +981,13 @@ OSStatus	BTIterateRecord		(SFCB						*fi
 				}
 			}
 			//	Before we stomp on "right", we'd better release it if needed
-			if (right.buffer != nil) {
+			if (right.buffer != NULL) {
 				err = ReleaseNode(btreePtr, &right);
 				M_ExitOnError(err);
 			}
 			right		= node;
 			node		= left;
-			left.buffer	= nil;
+			left.buffer	= NULL;
 			index 		= ((NodeDescPtr) node.buffer)->numRecords -1;
 		}
 	}
@@ -1012,7 +1012,7 @@ OSStatus	BTIterateRecord		(SFCB						*fi
 		}
 		else
 		{
-			if (right.buffer == nil)
+			if (right.buffer == NULL)
 			{
 				nodeNum = ((NodeDescPtr) node.buffer)->fLink;
 				if ( nodeNum > 0)
@@ -1025,13 +1025,13 @@ OSStatus	BTIterateRecord		(SFCB						*fi
 				}
 			}
 			//	Before we stomp on "left", we'd better release it if needed
-			if (left.buffer != nil) {
+			if (left.buffer != NULL) {
 				err = ReleaseNode(btreePtr, &left);
 				M_ExitOnError(err);
 			}
 			left		 = node;
 			node		 = right;
-			right.buffer = nil;
+			right.buffer = NULL;
 			index		 = 0;
 		}
 	}
@@ -1054,9 +1054,9 @@ CopyData:
 	err = GetRecordByIndex (btreePtr, node.buffer, index, &keyPtr, &recordPtr, &len);
 	M_ExitOnError (err);
 
-	if (recordLen != nil)			*recordLen = len;
+	if (recordLen != NULL)			*recordLen = len;
 
-	if (record != nil)
+	if (record != NULL)
 	{
 		ByteCount recordSize;
 
@@ -1069,7 +1069,7 @@ CopyData:
 		CopyMemory (recordPtr, record->bufferAddress, len);
 	}
 
-	if (iterator != nil)						// first & last do not require iterator
+	if (iterator != NULL)						// first & last do not require iterator
 	{
 		iterator->hint.writeCount	= btreePtr->writeCount;
 		iterator->hint.nodeNum		= nodeNum;
@@ -1089,13 +1089,13 @@ CopyData:
 	err = ReleaseNode (btreePtr, &node);
 	M_ExitOnError (err);
 
-	if (left.buffer != nil)
+	if (left.buffer != NULL)
 	{
 		err = ReleaseNode (btreePtr, &left);
 		M_ExitOnError (err);
 	}
 
-	if (right.buffer != nil)
+	if (right.buffer != NULL)
 	{
 		err = ReleaseNode (btreePtr, &right);
 		M_ExitOnError (err);
@@ -1113,10 +1113,10 @@ ErrorExit:
 	(void)	ReleaseNode (btreePtr, &node);
 	(void)	ReleaseNode (btreePtr, &right);
 
-	if (recordLen != nil)
+	if (recordLen != NULL)
 		*recordLen = 0;
 
-	if (iterator != nil)
+	if (iterator != NULL)
 	{
 		iterator->hint.writeCount	= 0;
 		iterator->hint.nodeNum		= 0;
@@ -1157,7 +1157,7 @@ OSStatus	BTInsertRecord		(SFCB						*fil
 
 	////////////////////////// Priliminary Checks ///////////////////////////////
 
-	nodeRec.buffer = nil;					// so we can call ReleaseNode
+	nodeRec.buffer = NULL;					// so we can call ReleaseNode
 
 	err = CheckInsertParams (filePtr, iterator, record, recordLen);
 	if (err != noErr)
@@ -1317,7 +1317,7 @@ OSStatus	BTSetRecord			(SFCB						*fileP
 
 	////////////////////////// Priliminary Checks ///////////////////////////////
 
-	nodeRec.buffer = nil;					// so we can call ReleaseNode
+	nodeRec.buffer = NULL;					// so we can call ReleaseNode
 
 	err = CheckInsertParams (filePtr, iterator, record, recordLen);
 	if (err != noErr)
@@ -1506,7 +1506,7 @@ OSStatus	BTReplaceRecord		(SFCB						*fi
 
 	////////////////////////// Priliminary Checks ///////////////////////////////
 
-	nodeRec.buffer = nil;					// so we can call ReleaseNode
+	nodeRec.buffer = NULL;					// so we can call ReleaseNode
 
 	err = CheckInsertParams (filePtr, iterator, record, recordLen);
 	if (err != noErr)
@@ -1645,20 +1645,20 @@ OSStatus	BTDeleteRecord		(SFCB						*fil
 
 	////////////////////////// Priliminary Checks ///////////////////////////////
 
-	nodeRec.buffer = nil;					// so we can call ReleaseNode
+	nodeRec.buffer = NULL;					// so we can call ReleaseNode
 
-	M_ReturnErrorIf (filePtr == nil, 	paramErr);
-	M_ReturnErrorIf (iterator == nil,	paramErr);
+	M_ReturnErrorIf (filePtr == NULL, 	paramErr);
+	M_ReturnErrorIf (iterator == NULL,	paramErr);
 
 	btreePtr = (BTreeControlBlockPtr) filePtr->fcbBtree;
-	if (btreePtr == nil)
+	if (btreePtr == NULL)
 	{
 		err = fsBTInvalidFileErr;
 		goto ErrorExit;
 	}
 
 #if SupportsKeyDescriptors
-	if (btreePtr->keyDescPtr != nil)
+	if (btreePtr->keyDescPtr != NULL)
 	{
 		err = CheckKey (&iterator->key, btreePtr->keyDescPtr, btreePtr->maxKeyLength);
 		M_ExitOnError (err);
@@ -1712,12 +1712,12 @@ OSStatus	BTGetInformation	(SFCB					*fil
 	BTreeControlBlockPtr	btreePtr;
 
 
-	M_ReturnErrorIf (filePtr == nil, 	paramErr);
+	M_ReturnErrorIf (filePtr == NULL, 	paramErr);
 
 	btreePtr = (BTreeControlBlockPtr) filePtr->fcbBtree;
 
-	M_ReturnErrorIf (btreePtr == nil,	fsBTInvalidFileErr);
-	M_ReturnErrorIf (info == nil,		paramErr);
+	M_ReturnErrorIf (btreePtr == NULL,	fsBTInvalidFileErr);
+	M_ReturnErrorIf (info == NULL,		paramErr);
 
 	//본 check version?
 
@@ -1730,7 +1730,7 @@ OSStatus	BTGetInformation	(SFCB					*fil
 	info->keyDescriptor	= btreePtr->keyDescPtr;	//본 this won't do at all...
 	info->reserved		= 0;
 
-	if (btreePtr->keyDescPtr == nil)
+	if (btreePtr->keyDescPtr == NULL)
 		info->keyDescLength	= 0;
 	else
 		info->keyDescLength	= (UInt32) btreePtr->keyDescPtr->length;
@@ -1762,11 +1762,11 @@ OSStatus	BTFlushPath				(SFCB					*fileP
 
 //	LogStartTime(kTraceFlushBTree);
 
-	M_ReturnErrorIf (filePtr == nil, 	paramErr);
+	M_ReturnErrorIf (filePtr == NULL, 	paramErr);
 
 	btreePtr = (BTreeControlBlockPtr) filePtr->fcbBtree;
 
-	M_ReturnErrorIf (btreePtr == nil,	fsBTInvalidFileErr);
+	M_ReturnErrorIf (btreePtr == NULL,	fsBTInvalidFileErr);
 
 	err = UpdateHeader (btreePtr);
 
@@ -1788,13 +1788,13 @@ Input:		iterator	- pointer to BTreeItera
 Output:		iterator	- iterator with the hint.nodeNum cleared
 
 Result:		noErr			- success
-			paramErr	- iterator == nil
+			paramErr	- iterator == NULL
 -------------------------------------------------------------------------------*/
 
 
 OSStatus	BTInvalidateHint	(BTreeIterator				*iterator )
 {
-	if (iterator == nil)
+	if (iterator == NULL)
 		return	paramErr;
 
 	iterator->hint.nodeNum = 0;
--- a/fsck_hfs.tproj/dfalib/BTreeAllocate.c
+++ b/fsck_hfs.tproj/dfalib/BTreeAllocate.c
@@ -83,7 +83,7 @@ OSStatus	AllocateNode (BTreeControlBlock
 	
 	
 	nodeNumber		= 0;				// first node number of header map record
-	node.buffer		= nil;				// clear node.buffer to get header node
+	node.buffer		= NULL;				// clear node.buffer to get header node
 										//	- and for ErrorExit
 	
 	while (true)
@@ -192,7 +192,7 @@ OSStatus	FreeNode (BTreeControlBlockPtr
 
 	//////////////////////////// Find Map Record ////////////////////////////////
 	nodeIndex			= 0;				// first node number of header map record
-	node.buffer			= nil;				// invalidate node.buffer to get header node
+	node.buffer			= NULL;				// invalidate node.buffer to get header node
 	
 	while (nodeNum >= nodeIndex)
 	{
@@ -278,8 +278,8 @@ OSStatus	ExtendBTree	(BTreeControlBlockP
 	nodeSize			= btreePtr->nodeSize;
 	filePtr				= btreePtr->fcbPtr;
 	
-	mapNode.buffer		= nil;
-	newNode.buffer		= nil;
+	mapNode.buffer		= NULL;
+	newNode.buffer		= NULL;
 
 	mapNodeRecSize	= nodeSize - sizeof(BTNodeDescriptor) - 6;	// 2 bytes of free space (see note)
 
@@ -448,7 +448,7 @@ ErrorExit:
 Routine:	GetMapNode	-	Get the next map node and pointer to the map record.
 
 Function:	Given a BlockDescriptor to a map node in nodePtr, GetMapNode releases
-			it and gets the next node. If nodePtr->buffer is nil, then the header
+			it and gets the next node. If nodePtr->buffer is NULL, then the header
 			node is retrieved.
 
 
@@ -474,7 +474,7 @@ OSStatus	GetMapNode (BTreeControlBlockPt
 	UInt16		mapIndex;
 	UInt32		nextNodeNum;
 	
-	if (nodePtr->buffer != nil)		// if iterator is valid...
+	if (nodePtr->buffer != NULL)		// if iterator is valid...
 	{
 		nextNodeNum = ((NodeDescPtr)nodePtr->buffer)->fLink;
 		if (nextNodeNum == 0)
@@ -521,7 +521,7 @@ ErrorExit:
 	
 	(void) ReleaseNode (btreePtr, nodePtr);
 	
-	*mapPtr		= nil;
+	*mapPtr		= NULL;
 	*mapSize	= 0;
 	
 	return	err;
--- a/fsck_hfs.tproj/dfalib/BTreeMiscOps.c
+++ b/fsck_hfs.tproj/dfalib/BTreeMiscOps.c
@@ -236,13 +236,13 @@ OSStatus	FindIteratorPosition	(BTreeCont
 	// assume index points to UInt16
 	// assume foundRecord points to Boolean
 	
-	left->buffer		= nil;
-	middle->buffer		= nil;
-	right->buffer		= nil;
+	left->buffer		= NULL;
+	middle->buffer		= NULL;
+	right->buffer		= NULL;
 	
 	foundIt				= false;
 	
-	if (iterator == nil)						// do we have an iterator?
+	if (iterator == NULL)						// do we have an iterator?
 	{
 		err = fsBTInvalidIteratorErr;
 		goto ErrorExit;
@@ -250,7 +250,7 @@ OSStatus	FindIteratorPosition	(BTreeCont
 
 #if SupportsKeyDescriptors
 	//본 verify iterator key (change CheckKey to take btreePtr instead of keyDescPtr?)
-	if (btreePtr->keyDescPtr != nil)
+	if (btreePtr->keyDescPtr != NULL)
 	{
 		err = CheckKey (&iterator->key, btreePtr->keyDescPtr, btreePtr->maxKeyLength );
 		M_ExitOnError (err);
@@ -309,7 +309,7 @@ OSStatus	FindIteratorPosition	(BTreeCont
 		{
 			*right			= *middle;
 			*middle			= *left;
-			left->buffer	= nil;
+			left->buffer	= NULL;
 			index			= leftIndex;
 			
 			goto SuccessfulExit;
@@ -330,7 +330,7 @@ OSStatus	FindIteratorPosition	(BTreeCont
 		{
 			*right			= *middle;
 			*middle			= *left;
-			left->buffer	= nil;
+			left->buffer	= NULL;
 			index			= leftIndex;
 			
 			goto SuccessfulExit;
@@ -363,7 +363,7 @@ OSStatus	FindIteratorPosition	(BTreeCont
 		{
 			*left			= *middle;
 			*middle			= *right;
-			right->buffer	= nil;
+			right->buffer	= NULL;
 			index			= rightIndex;
 			
 			goto SuccessfulExit;
@@ -427,15 +427,15 @@ OSStatus	CheckInsertParams		(SFCB						*
 {
 	BTreeControlBlockPtr	btreePtr;
 	
-	if (filePtr == nil)									return	paramErr;
+	if (filePtr == NULL)									return	paramErr;
 
 	btreePtr = (BTreeControlBlockPtr) filePtr->fcbBtree;
-	if (btreePtr == nil)								return	fsBTInvalidFileErr;
-	if (iterator == nil)								return	paramErr;
-	if (record	 == nil)								return	paramErr;
+	if (btreePtr == NULL)								return	fsBTInvalidFileErr;
+	if (iterator == NULL)								return	paramErr;
+	if (record	 == NULL)								return	paramErr;
 	
 #if SupportsKeyDescriptors
-	if (btreePtr->keyDescPtr != nil)
+	if (btreePtr->keyDescPtr != NULL)
 	{
 		OSStatus	err;
 
--- a/fsck_hfs.tproj/dfalib/BTreeNodeOps.c
+++ b/fsck_hfs.tproj/dfalib/BTreeNodeOps.c
@@ -105,7 +105,7 @@ Function:	Gets an existing BTree node fr
 Input:		btreePtr	- pointer to BTree control block
 			nodeNum		- number of node to request
 			
-Output:		nodePtr		- pointer to beginning of node (nil if error)
+Output:		nodePtr		- pointer to beginning of node (NULL if error)
 			
 Result:
 			noErr		- success
@@ -139,7 +139,7 @@ OSStatus	GetNode		(BTreeControlBlockPtr
 	if (err != noErr)
 	{
 		Panic ("\pGetNode: getNodeProc returned error.");
-		nodePtr->buffer = nil;
+		nodePtr->buffer = NULL;
 		goto ErrorExit;
 	}
 	++btreePtr->numGetNodes;
@@ -156,8 +156,8 @@ OSStatus	GetNode		(BTreeControlBlockPtr
 	return noErr;
 
 ErrorExit:
-	nodePtr->buffer			= nil;
-	nodePtr->blockHeader	= nil;
+	nodePtr->buffer		= NULL;
+	nodePtr->blockHeader	= NULL;
 	
 //	LogEndTime(kTraceGetNode, err);
 
@@ -176,7 +176,7 @@ Function:	Gets a new BTree node from FS
 Input:		btreePtr		- pointer to BTree control block
 			nodeNum			- number of node to request
 			
-Output:		returnNodePtr	- pointer to beginning of node (nil if error)
+Output:		returnNodePtr	- pointer to beginning of node (NULL if error)
 			
 Result:		noErr		- success
 			!= noErr	- failure
@@ -203,7 +203,7 @@ OSStatus	GetNewNode	(BTreeControlBlockPt
 	if (err != noErr)
 	{
 		Panic ("\pGetNewNode: getNodeProc returned error.");
-		returnNodePtr->buffer = nil;
+		returnNodePtr->buffer = NULL;
 		return err;
 	}
 	++btreePtr->numGetNewNodes;
@@ -248,7 +248,7 @@ OSStatus	ReleaseNode	(BTreeControlBlockP
 
 	err = noErr;
 	
-	if (nodePtr->buffer != nil)
+	if (nodePtr->buffer != NULL)
 	{
 		/*
 		 * The nodes must remain in the cache as big endian!
@@ -267,8 +267,8 @@ OSStatus	ReleaseNode	(BTreeControlBlockP
 		++btreePtr->numReleaseNodes;
 	}
 	
-	nodePtr->buffer = nil;
-	nodePtr->blockHeader = nil;
+	nodePtr->buffer = NULL;
+	nodePtr->blockHeader = NULL;
 	
 //	LogEndTime(kTraceReleaseNode, err);
 
@@ -299,7 +299,7 @@ OSStatus	TrashNode	(BTreeControlBlockPtr
 
 	err = noErr;
 	
-	if (nodePtr->buffer != nil)
+	if (nodePtr->buffer != NULL)
 	{
 		releaseNodeProc = btreePtr->releaseBlockProc;
 		err = releaseNodeProc (btreePtr->fcbPtr,
@@ -309,8 +309,8 @@ OSStatus	TrashNode	(BTreeControlBlockPtr
 		++btreePtr->numReleaseNodes;
 	}
 
-	nodePtr->buffer			= nil;
-	nodePtr->blockHeader	= nil;
+	nodePtr->buffer		= NULL;
+	nodePtr->blockHeader	= NULL;
 	
 	return err;
 }
@@ -338,7 +338,7 @@ OSStatus	UpdateNode	(BTreeControlBlockPt
 	
 	err = noErr;
 		
-	if (nodePtr->buffer != nil)			//본 why call UpdateNode if nil ?!?
+	if (nodePtr->buffer != NULL)			//본 why call UpdateNode if NULL ?!?
 	{
 	//	LogStartTime(kTraceReleaseNode);
 		err = hfs_swap_BTNode(nodePtr, btreePtr->fcbPtr, kSwapBTNodeHostToBig);
@@ -358,8 +358,8 @@ OSStatus	UpdateNode	(BTreeControlBlockPt
 		++btreePtr->numUpdateNodes;
 	}
 	
-	nodePtr->buffer			= nil;
-	nodePtr->blockHeader	= nil;
+	nodePtr->buffer		= NULL;
+	nodePtr->blockHeader	= NULL;
 
 	return	noErr;
 
--- a/fsck_hfs.tproj/dfalib/BTreeTreeOps.c
+++ b/fsck_hfs.tproj/dfalib/BTreeTreeOps.c
@@ -177,7 +177,7 @@ Output:		nodeNum			- number of the node
 			
 Result:		noErr			- key found, index is record index
 			fsBTRecordNotFoundErr	- key not found, index is insert index
-			fsBTEmptyErr		- key not found, return params are nil
+			fsBTEmptyErr		- key not found, return params are NULL
 			otherwise			- catastrophic failure (GetNode/ReleaseNode failed)
 -------------------------------------------------------------------------------*/
 
@@ -321,8 +321,8 @@ ReleaseAndExit:
 ErrorExit:
 	
 	*nodeNum					= 0;
-	nodePtr->buffer				= nil;
-	nodePtr->blockHeader		= nil;
+	nodePtr->buffer				= NULL;
+	nodePtr->blockHeader		= NULL;
 	*returnIndex				= 0;
 
 	return	err;
@@ -354,7 +354,7 @@ OSStatus	InsertTree ( BTreeControlBlockP
 	primaryKey.replacingKey	= replacingKey;
 	primaryKey.skipRotate	= false;
 
-	err	= InsertLevel (btreePtr, treePathTable, &primaryKey, nil,
+	err	= InsertLevel (btreePtr, treePathTable, &primaryKey, NULL,
 					   targetNode, index, level, insertNode );
 						
 	return err;
@@ -385,7 +385,7 @@ OSStatus	InsertLevel (BTreeControlBlockP
 #if defined(applec) && !defined(__SC__)
 	PanicIf ((level == 1) && (((NodeDescPtr)targetNode->buffer)->kind != kBTLeafNode), "\P InsertLevel: non-leaf at level 1! ");
 #endif
-	siblingNode.buffer = nil;
+	siblingNode.buffer = NULL;
 	targetNodeNum = treePathTable [level].node;
 
 	insertParent = false;
@@ -420,7 +420,7 @@ OSStatus	InsertLevel (BTreeControlBlockP
 	
 	////// process second insert (if any) //////
 
-	if  ( secondaryKey != nil )
+	if (secondaryKey != NULL)
 	{
 		Boolean				temp;
 
@@ -446,7 +446,7 @@ OSStatus	InsertLevel (BTreeControlBlockP
 		UInt8 *				recPtr;
 		UInt16				recSize;
 		
-		secondaryKey = nil;
+		secondaryKey = NULL;
 		
 		PanicIf ( (level == btreePtr->treeDepth), "InsertLevel: unfinished insert!?");
 
@@ -606,9 +606,9 @@ static OSErr	InsertNode	(BTreeControlBlo
 	
 	if ( leftNodeNum > 0 )
 	{
-		PanicIf ( siblingNode->buffer != nil, "InsertNode: siblingNode already aquired!");
+		PanicIf(siblingNode->buffer != NULL, "InsertNode: siblingNode already aquired!");
 
-		if ( siblingNode->buffer == nil )
+		if (siblingNode->buffer == NULL)
 		{
 			err = GetNode (btreePtr, leftNodeNum, siblingNode);	// will be released by caller or a split below
 			M_ExitOnError (err);
@@ -703,7 +703,7 @@ OSStatus	DeleteTree			(BTreeControlBlock
 
 	targetNodeNum = treePathTable[level].node;
 	targetNodePtr = targetNode->buffer;
-	PanicIf (targetNodePtr == nil, "DeleteTree: targetNode has nil buffer!");
+	PanicIf (targetNodePtr == NULL, "DeleteTree: targetNode has NULL buffer!");
 
 	DeleteRecord (btreePtr, targetNodePtr, index);
 		
@@ -766,7 +766,7 @@ OSStatus	DeleteTree			(BTreeControlBlock
 		deleteRequired = false;
 		updateRequired = false;
 		
-		if ( targetNode->buffer == nil )	// then root was freed and the btree is empty
+		if (targetNode->buffer == NULL)	// then root was freed and the btree is empty
 		{
 			btreePtr->rootNode  = 0;
 			btreePtr->treeDepth = 0;
@@ -1124,7 +1124,7 @@ static OSStatus	SplitLeft		(BTreeControl
 	if ( (right->height == 1) && (right->kind != kBTLeafNode) )
 		return	fsBTInvalidNodeErr;
 	
-	if ( left != nil )
+	if (left != NULL)
 	{
 		if ( left->fLink != rightNodeNum )
 			return fsBTInvalidNodeErr;										//본 E_BadSibling ?
@@ -1145,7 +1145,7 @@ static OSStatus	SplitLeft		(BTreeControl
 
 	/////////////// Update Forward Link In Original Left Node ///////////////////
 
-	if ( left != nil )
+	if (left != NULL)
 	{
 		left->fLink	= newNodeNum;
 		err = UpdateNode (btreePtr, leftNode);
@@ -1240,8 +1240,8 @@ static OSStatus	AddNewRootNode	(BTreeCon
 	Boolean				didItFit;
 	UInt16				keyLength;	
 	
-	PanicIf (leftNode == nil, "AddNewRootNode: leftNode == nil");
-	PanicIf (rightNode == nil, "AddNewRootNode: rightNode == nil");
+	PanicIf (leftNode == NULL, "AddNewRootNode: leftNode == NULL");
+	PanicIf (rightNode == NULL, "AddNewRootNode: rightNode == NULL");
 	
 	
 	/////////////////////// Initialize New Root Node ////////////////////////////
@@ -1362,7 +1362,7 @@ static OSStatus	SplitRight		(BTreeContro
 	if ( (leftPtr->height == 1) && (leftPtr->kind != kBTLeafNode) )
 		return	fsBTInvalidNodeErr;
 	
-	if ( rightPtr != nil )
+	if (rightPtr != NULL)
 	{
 		if ( rightPtr->bLink != nodeNum )
 			return fsBTInvalidNodeErr;										//본 E_BadSibling ?
@@ -1382,7 +1382,7 @@ static OSStatus	SplitRight		(BTreeContro
 
 	/////////////// Update backward Link In Original Right Node ///////////////////
 
-	if ( rightPtr != nil )
+	if (rightPtr != NULL)
 	{
 		rightPtr->bLink	= newNodeNum;
 		err = UpdateNode (btreePtr, rightNodePtr);
@@ -1739,7 +1739,7 @@ static int DoKeyCheck( NodeDescPtr nodeP
 	UInt16				keyLength;
 	KeyPtr 				keyPtr;
 	UInt8				*dataPtr;
-	KeyPtr				prevkeyP	= nil;
+	KeyPtr				prevkeyP	= NULL;
 
 
 	if ( nodeP->numRecords == 0 )
@@ -1766,7 +1766,7 @@ static int DoKeyCheck( NodeDescPtr nodeP
 				return( -1 );
 			}
 	
-			if ( prevkeyP != nil )
+			if (prevkeyP != NULL)
 			{
 				if ( CompareKeys( (BTreeControlBlockPtr)btcb, prevkeyP, keyPtr ) >= 0 )
 				{
--- a/fsck_hfs.tproj/dfalib/SControl.c
+++ b/fsck_hfs.tproj/dfalib/SControl.c
@@ -82,7 +82,7 @@ CheckHFS( 	int fsReadRef, int fsWriteRef
 {
 	SGlob				dataArea;	// Allocate the scav globals
 	short				temp; 	
-	FileIdentifierTable	*fileIdentifierTable	= nil;
+	FileIdentifierTable	*fileIdentifierTable	= NULL;
 	OSErr				err = noErr;
 	OSErr				scavError = 0;
 	int					scanCount = 0;
@@ -228,7 +228,7 @@ DoAgain:
 	}
 
 	//	Set up structures for post processing
-	if ( (autoRepair == true) && (dataArea.fileIdentifierTable != nil) )
+	if ((autoRepair == true) && (dataArea.fileIdentifierTable != NULL))
 	{
 	//	*repairInfo = *repairInfo | kVolumeHadOverlappingExtents;	//	Report back that volume has overlapping extents
 		fileIdentifierTable	= (FileIdentifierTable *) AllocateMemory( GetHandleSize( (Handle) dataArea.fileIdentifierTable ) );
@@ -239,7 +239,7 @@ DoAgain:
 	//
 	//	Post processing
 	//
-	if ( fileIdentifierTable != nil )
+	if (fileIdentifierTable != NULL)
 	{
 		DisposeMemory( fileIdentifierTable );
 	}
@@ -682,7 +682,7 @@ short CheckForStop( SGlob *GPtr )
 
 	//if ( ((ticks - 10) > GPtr->lastTickCount) || (dfaStage == kAboutToRepairStage) )			//	To reduce cursor flicker on fast machines, call through on a timed interval
 	//{
-		if ( GPtr->userCancelProc != nil )
+		if (GPtr->userCancelProc != NULL)
 		{
 			UInt64	progress = 0;
 			Boolean	progressChanged;
@@ -761,7 +761,7 @@ static int ScavSetUp( SGlob *GPtr)
 	short	ioRefNum;
 #endif
 
-	GPtr->MinorRepairsP = nil;
+	GPtr->MinorRepairsP = NULL;
 	
 	GPtr->itemsProcessed = 0;
 	GPtr->lastProgress = 0;
@@ -774,7 +774,7 @@ static int ScavSetUp( SGlob *GPtr)
 		ScavStaticStructures	*pointer;
 		
 		pointer = (ScavStaticStructures *) AllocateClearMemory( sizeof(ScavStaticStructures) );
-		if ( pointer == nil ) {
+		if (pointer == NULL) {
 			if ( GPtr->logLevel >= kDebugLog ) {
 				printf( "\t error %d - could not allocate %i bytes of memory \n",
 					R_NoMem, sizeof(ScavStaticStructures) );
@@ -831,7 +831,7 @@ static int ScavSetUp( SGlob *GPtr)
 	//	Save current value of vcbWrCnt, to detect modifications to volume by other apps etc
 	if ( GPtr->volumeFeatures & volumeIsMountedMask )
 	{
-		FlushVol( nil, GPtr->realVCB->vcbVRefNum );	//	Ask HFS to update all changes to disk
+		FlushVol(NULL, GPtr->realVCB->vcbVRefNum);	//	Ask HFS to update all changes to disk
 		GPtr->wrCnt = GPtr->realVCB->vcbWrCnt;		//	Remember write count after writing changes
 	}
 #endif
@@ -949,7 +949,7 @@ static int ScavSetUp( SGlob *GPtr)
  	
 	// Keep a valid file id list for HFS volumes
 	GPtr->validFilesList = (UInt32**)NewHandle( 0 );
-	if ( GPtr->validFilesList == nil ) {
+	if (GPtr->validFilesList == NULL) {
 		if ( GPtr->logLevel >= kDebugLog ) {
 			printf( "\t error %d - could not allocate file ID list \n", R_NoMem );
 		}
@@ -995,17 +995,17 @@ static int ScavTerm( SGlobPtr GPtr )
 
 	(void) BitMapCheckEnd();
 
-	while( (rP = GPtr->MinorRepairsP) != nil )		//	loop freeing leftover (undone) repair orders
+	while((rP = GPtr->MinorRepairsP) != NULL)		//	loop freeing leftover (undone) repair orders
 	{
 		GPtr->MinorRepairsP = rP->link;				//	(in case repairs were not made)
 		DisposeMemory(rP);
 		err = MemError();
 	}
 	
-	if( GPtr->validFilesList != nil )
+	if (GPtr->validFilesList != NULL)
 		DisposeHandle( (Handle) GPtr->validFilesList );
 	
-	if( GPtr->overlappedExtents != nil ) {
+	if (GPtr->overlappedExtents != NULL) {
  		extentsTableH = GPtr->overlappedExtents;
  	
 		/* Overlapped extents list also allocated memory for attribute name */
@@ -1021,44 +1021,44 @@ static int ScavTerm( SGlobPtr GPtr )
 		DisposeHandle( (Handle) GPtr->overlappedExtents );
 	}
 	
-	if( GPtr->fileIdentifierTable != nil )
+	if (GPtr->fileIdentifierTable != NULL)
 		DisposeHandle( (Handle) GPtr->fileIdentifierTable );
 	
-	if( GPtr->calculatedVCB == nil )								//	already freed?
+	if (GPtr->calculatedVCB == NULL)								//	already freed?
 		return( noErr );
 
 	//	If the FCB's and BTCB's have been set up, dispose of them
 	fcbP = GPtr->calculatedExtentsFCB;	// release extent file BTree bit map
-	if ( fcbP != nil )
+	if (fcbP != NULL)
 	{
 		btcbP = (BTreeControlBlock*)fcbP->fcbBtree;
-		if ( btcbP != nil)
+		if (btcbP != NULL)
 		{
-			if( btcbP->refCon != nil )
+			if (btcbP->refCon != NULL)
 			{
-				if(((BTreeExtensionsRec*)btcbP->refCon)->BTCBMPtr != nil)
+				if (((BTreeExtensionsRec*)btcbP->refCon)->BTCBMPtr != NULL)
 				{
 					DisposeMemory(((BTreeExtensionsRec*)btcbP->refCon)->BTCBMPtr);
 					err = MemError();
 				}
 				DisposeMemory( (Ptr)btcbP->refCon );
 				err = MemError();
-				btcbP->refCon = nil;
+				btcbP->refCon = NULL;
 			}
 				
 			fcbP = GPtr->calculatedCatalogFCB;	//	release catalog BTree bit map
 			btcbP = (BTreeControlBlock*)fcbP->fcbBtree;
 				
-			if( btcbP->refCon != nil )
+			if (btcbP->refCon != NULL)
 			{
-				if(((BTreeExtensionsRec*)btcbP->refCon)->BTCBMPtr != nil)
+				if (((BTreeExtensionsRec*)btcbP->refCon)->BTCBMPtr != NULL)
 				{
 					DisposeMemory(((BTreeExtensionsRec*)btcbP->refCon)->BTCBMPtr);
 					err = MemError();
 				}
 				DisposeMemory( (Ptr)btcbP->refCon );
 				err = MemError();
-				btcbP->refCon = nil;
+				btcbP->refCon = NULL;
 			}
 		}
 	}
@@ -1066,7 +1066,7 @@ static int ScavTerm( SGlobPtr GPtr )
 	DisposeMemory( GPtr->calculatedVCB );						//	Release our block of data structures	
 	err = MemError();
 
-	GPtr->calculatedVCB = nil;
+	GPtr->calculatedVCB = NULL;
 
 	return( noErr );
 }
@@ -1113,7 +1113,7 @@ Boolean IsBlueBoxSharedDrive ( DrvQElPtr
 	// Now look at the name of the Driver name. If it is .BlueBoxShared keep it out of the list of available disks.
 	driverDCtlHandle = GetDCtlEntry(dqPtr->dQRefNum);
 	driverDCtlPtr = *driverDCtlHandle;
-	if((((driverDCtlPtr->dCtlFlags) & Is_Native_Mask) == 0) && (driverDCtlPtr->dCtlDriver != nil))
+	if((((driverDCtlPtr->dCtlFlags) & Is_Native_Mask) == 0) && (driverDCtlPtr->dCtlDriver != NULL))
 	{
 		if (((driverDCtlPtr->dCtlFlags) & Is_Ram_Based_Mask) == 0)
 		{
@@ -1127,19 +1127,19 @@ Boolean IsBlueBoxSharedDrive ( DrvQElPtr
 			
 		}
 		driverName = (StringPtr)&(drvrHeaderPtr->drvrName);
-		if (!(IdenticalString(driverName,blueBoxSharedDriverName,nil)))
+		if (!(IdenticalString(driverName,blueBoxSharedDriverName,NULL)))
 		{
 			return( true );
 		}
 
 		// Special case for the ".Sony" floppy driver which might be accessed in Shared mode inside the Blue Box
 		// Test its "where" string instead of the driver name.
-		if (!(IdenticalString(driverName,sonyDriverName,nil)))
+		if (!(IdenticalString(driverName,sonyDriverName,NULL)))
 		{
 			CntrlParam			paramBlock;
 		
-			paramBlock.ioCompletion	= nil;
-			paramBlock.ioNamePtr	= nil;
+			paramBlock.ioCompletion	= NULL;
+			paramBlock.ioNamePtr	= NULL;
 			paramBlock.ioVRefNum	= dqPtr->dQDrive;
 			paramBlock.ioCRefNum	= dqPtr->dQRefNum;
 			paramBlock.csCode		= kDriveIcon;						// return physical icon
@@ -1152,7 +1152,7 @@ Boolean IsBlueBoxSharedDrive ( DrvQElPtr
 				
 				iconAndStringRecPtr = * (IconAndStringRecPtr*) & paramBlock.csParam;
 				whereStringPtr = (StringPtr) & iconAndStringRecPtr->string;
-				if (!(IdenticalString(whereStringPtr,blueBoxFloppyWhereString,nil)))
+				if (!(IdenticalString(whereStringPtr,blueBoxFloppyWhereString,NULL)))
 				{
 					return( true );
 				}
--- a/fsck_hfs.tproj/dfalib/SRepair.c
+++ b/fsck_hfs.tproj/dfalib/SRepair.c
@@ -844,7 +844,7 @@ static	int	DelFThd( SGlobPtr GPtr, UInt3
 
 	isHFSPlus = VolumeObjectIsHFSPlus( );
 	
-	BuildCatalogKey( fid, (const CatalogName*) nil, isHFSPlus, &key );
+	BuildCatalogKey(fid, NULL, isHFSPlus, &key);
 	result = SearchBTreeRecord( GPtr->calculatedCatalogFCB, &key, kNoHint, &foundKey, &record, &recSize, &hint );
 	
 	if ( result )	return ( IntError( GPtr, result ) );
@@ -910,7 +910,7 @@ static	OSErr	FixDirThread( SGlobPtr GPtr
 
 	isHFSPlus = VolumeObjectIsHFSPlus( );
 
-	BuildCatalogKey( did, (const CatalogName*) nil, isHFSPlus, &key );
+	BuildCatalogKey(did, NULL, isHFSPlus, &key);
 	result = SearchBTreeRecord( GPtr->calculatedCatalogFCB, &key, kNoHint, &foundKey, &record, &recSize, &hint );
 	
 	if ( result )
@@ -2171,7 +2171,7 @@ static	OSErr	FixOrphanedFiles ( SGlobPtr
 				}
 
 				//-- Build the key for the file thread
-				BuildCatalogKey( cNodeID, nil, isHFSPlus, &key );
+				BuildCatalogKey(cNodeID, NULL, isHFSPlus, &key);
 
 				err = SearchBTreeRecord( GPtr->calculatedCatalogFCB, &key, kNoHint, 
 										 &tempKey, &threadRecord, &recordSize, &hint2 );
--- a/fsck_hfs.tproj/dfalib/SUtils.c
+++ b/fsck_hfs.tproj/dfalib/SUtils.c
@@ -395,11 +395,11 @@ OSErr GetVolumeFeatures( SGlobPtr GPtr )
 	err = GetVCBDriveNum( &GPtr->realVCB, GPtr->DrvNum );
 	ReturnIfError( err );
 
-	if ( GPtr->realVCB != nil )
+	if (GPtr->realVCB != NULL)
 	{
 		GPtr->volumeFeatures	|= volumeIsMountedMask;
 
-		pb.ioParam.ioNamePtr	= nil;
+		pb.ioParam.ioNamePtr	= NULL;
 		pb.ioParam.ioVRefNum	= GPtr->realVCB->vcbVRefNum;
 		pb.ioParam.ioBuffer		= (Ptr) &buffer;
 		pb.ioParam.ioReqCount	= sizeof( buffer );
@@ -2282,7 +2282,7 @@ void print_prime_buckets(PrimeBuckets *c
  *     	   	4. btreetye - can be kHFSPlusCatalogRecord or kHFSPlusAttributeRecord
  *                            indicates which btree prime number bucket should be incremented
  *
- * Output:	nil
+ * Output:	NULL
  */
 void RecordXAttrBits(SGlobPtr GPtr, UInt16 flags, HFSCatalogNodeID fileid, UInt16 btreetype) 
 {
--- a/fsck_hfs.tproj/dfalib/SVerify1.c
+++ b/fsck_hfs.tproj/dfalib/SVerify1.c
@@ -790,13 +790,13 @@ OSErr	CreateExtentsBTreeControlBlock( SG
 	//	set up our DFA extended BTCB area.  Will we have enough memory on all HFS+ volumes.
 	//
 	btcb->refCon = AllocateClearMemory( sizeof(BTreeExtensionsRec) );			// allocate space for our BTCB extensions
-	if ( btcb->refCon == nil ) {
+	if (btcb->refCon == NULL) {
 		err = R_NoMem;
 		goto exit;
 	}
 	size = (btcb->totalNodes + 7) / 8;											//	size of BTree bit map
 	((BTreeExtensionsRec*)btcb->refCon)->BTCBMPtr = AllocateClearMemory(size);			//	get precleared bitmap
-	if ( ((BTreeExtensionsRec*)btcb->refCon)->BTCBMPtr == nil )
+	if (((BTreeExtensionsRec*)btcb->refCon)->BTCBMPtr == NULL)
 	{
 		err = R_NoMem;
 		goto exit;
@@ -1145,13 +1145,13 @@ OSErr	CreateCatalogBTreeControlBlock( SG
 	//
 
 	btcb->refCon = AllocateClearMemory( sizeof(BTreeExtensionsRec) );			// allocate space for our BTCB extensions
-	if ( btcb->refCon == nil ) {
+	if (btcb->refCon == NULL) {
 		err = R_NoMem;
 		goto exit;
 	}
 	size = (btcb->totalNodes + 7) / 8;											//	size of BTree bit map
 	((BTreeExtensionsRec*)btcb->refCon)->BTCBMPtr = AllocateClearMemory(size);			//	get precleared bitmap
-	if ( ((BTreeExtensionsRec*)btcb->refCon)->BTCBMPtr == nil )
+	if (((BTreeExtensionsRec*)btcb->refCon)->BTCBMPtr == NULL)
 	{
 		err = R_NoMem;
 		goto exit;
@@ -1339,7 +1339,7 @@ OSErr CatHChk( SGlobPtr GPtr )
 	
 	//본 Can we ignore this part by just taking advantage of setting the selCode = 0x8001;
 	{ 
-		BuildCatalogKey( 1, (const CatalogName *)nil, isHFSPlus, &key );
+		BuildCatalogKey(1, NULL, isHFSPlus, &key);
 		result = SearchBTreeRecord( GPtr->calculatedCatalogFCB, &key, kNoHint, &foundKey, &threadRecord, &recSize, &hint );
 	
 		GPtr->TarBlock = hint;									/* set target block */
@@ -1443,7 +1443,7 @@ OSErr CatHChk( SGlobPtr GPtr )
 				/* 
 				 * Find thread record
 				 */
-				BuildCatalogKey( dprP->directoryID, (const CatalogName *) nil, isHFSPlus, &key );
+				BuildCatalogKey(dprP->directoryID, NULL, isHFSPlus, &key);
 				result = SearchBTreeRecord( GPtr->calculatedCatalogFCB, &key, kNoHint, &foundKey, &threadRecord, &recSize, &hint );
 				if ( result != noErr ) {
 					char idStr[16];
@@ -1780,26 +1780,26 @@ OSErr	CreateAttributesBTreeControlBlock(
 	//	set up our DFA extended BTCB area.  Will we have enough memory on all HFS+ volumes.
 	//
 	btcb->refCon = AllocateClearMemory( sizeof(BTreeExtensionsRec) );			// allocate space for our BTCB extensions
-	if ( btcb->refCon == nil ) {
+	if (btcb->refCon == NULL) {
 		err = R_NoMem;
 		goto exit;
 	}
 
 	if (btcb->totalNodes == 0)
 	{
-		((BTreeExtensionsRec*)btcb->refCon)->BTCBMPtr			= nil;
+		((BTreeExtensionsRec*)btcb->refCon)->BTCBMPtr			= NULL;
 		((BTreeExtensionsRec*)btcb->refCon)->BTCBMSize			= 0;
 		((BTreeExtensionsRec*)btcb->refCon)->realFreeNodeCount	= 0;
 	}
 	else
 	{
-		if ( btcb->refCon == nil ) {
+		if (btcb->refCon == NULL) {
 			err = R_NoMem;
 			goto exit;
 		}
 		size = (btcb->totalNodes + 7) / 8;											//	size of BTree bit map
 		((BTreeExtensionsRec*)btcb->refCon)->BTCBMPtr = AllocateClearMemory(size);			//	get precleared bitmap
-		if ( ((BTreeExtensionsRec*)btcb->refCon)->BTCBMPtr == nil )
+		if (((BTreeExtensionsRec*)btcb->refCon)->BTCBMPtr == NULL)
 		{
 			err = R_NoMem;
 			goto exit;
@@ -2358,7 +2358,7 @@ static	OSErr	RcdMDBEmbededVolDescription
 	RcdError( GPtr, type );												//	first, record the error
 	
 	p = AllocMinorRepairOrder( GPtr, sizeof(EmbededVolDescription) );	//	get the node
-	if ( p == nil )	return( R_NoMem );
+	if (p == NULL)	return( R_NoMem );
 	
 	p->type							=  type;							//	save error info
 	desc							=  (EmbededVolDescription *) &(p->name);
@@ -2397,7 +2397,7 @@ static	OSErr	RcdInvalidWrapperExtents( S
 	RcdError( GPtr, type );												//	first, record the error
 	
 	p = AllocMinorRepairOrder( GPtr, 0 );	//	get the node
-	if ( p == nil )	return( R_NoMem );
+	if (p == NULL)	return( R_NoMem );
 	
 	p->type							=  type;							//	save error info
 	
@@ -3029,7 +3029,7 @@ OSErr	CheckFileExtents( SGlobPtr GPtr, U
 	foundBadExtent = false;
 	lastExtentIndex = GPtr->numExtents;
 	
-	while ( (extents != nil) && (err == noErr) )
+	while ((extents != NULL) && (err == noErr))
 	{	
 		//	checkout the extent record first
 		err = ChkExtRec( GPtr, extents, &lastExtentIndex );
@@ -3105,7 +3105,7 @@ OSErr	CheckFileExtents( SGlobPtr GPtr, U
 			if ( err == btNotFound )
 			{
 				err = noErr;								//	 no more extent records
-				extents = nil;
+				extents = NULL;
 				break;
 			}
 			else if ( err != noErr )
@@ -3121,7 +3121,7 @@ OSErr	CheckFileExtents( SGlobPtr GPtr, U
 			if ( err == btNotFound )
 			{
 				err = noErr;								//	 no more extent records
-				extents = nil;
+				extents = NULL;
 				break;
 			}
 			else if ( err != noErr )
@@ -3205,7 +3205,7 @@ static OSErr	AddExtentToOverlapList( SGl
 	}
 	
 	//	If it's uninitialized
-	if ( GPtr->overlappedExtents == nil )
+	if (GPtr->overlappedExtents == NULL)
 	{
 		GPtr->overlappedExtents	= (ExtentsTable **) NewHandleClear( sizeof(ExtentsTable) );
 		extentsTableH	= GPtr->overlappedExtents;
--- a/fsck_hfs.tproj/dfalib/SVerify2.c
+++ b/fsck_hfs.tproj/dfalib/SVerify2.c
@@ -1013,7 +1013,7 @@ static int BTKeyChk( SGlobPtr GPtr, Node
 	UInt16				keyLength;
 	KeyPtr 				keyPtr;
 	UInt8				*dataPtr;
-	KeyPtr				prevkeyP	= nil;
+	KeyPtr				prevkeyP	= NULL;
 
 
 	if ( nodeP->numRecords == 0 )
@@ -1044,7 +1044,7 @@ static int BTKeyChk( SGlobPtr GPtr, Node
 				return( E_KeyLen );
 			}
 	
-			if ( prevkeyP != nil )
+			if (prevkeyP != NULL)
 			{
 				if ( CompareKeys( (BTreeControlBlockPtr)btcb, prevkeyP, keyPtr ) >= 0 )
 				{
